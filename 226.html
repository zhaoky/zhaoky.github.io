<!DOCTYPE html><html lang="zh-CN"><head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#3eaf7c">
<meta name="generator" content="Hexo 5.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/apple-touch-icon.png" color="#3eaf7c">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.1/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.flqin.com","root":"/","images":"/images","scheme":"Pisces","version":"8.0.2","exturl":true,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="原文链接 https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html  各位 JavaScript 程序员，是时候承认了，我们在使用 promise 的时候，会写出许多有问题的 promise 代码。 当然并不是 promise 本身的问题，A+ spec 规范定义的 promise 非常棒。 在过去的几年中，笔者看到了">
<meta property="og:type" content="article">
<meta property="og:title" content="（转载）谈谈使用 promise 时候的一些反模式">
<meta property="og:url" content="https://blog.flqin.com/226.html">
<meta property="og:site_name" content="前端轻语">
<meta property="og:description" content="原文链接 https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html  各位 JavaScript 程序员，是时候承认了，我们在使用 promise 的时候，会写出许多有问题的 promise 代码。 当然并不是 promise 本身的问题，A+ spec 规范定义的 promise 非常棒。 在过去的几年中，笔者看到了">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2018-05-15T14:28:18.000Z">
<meta property="article:modified_time" content="2018-05-15T14:28:18.000Z">
<meta property="article:author" content="Korey">
<meta property="article:tag" content="前端,前端开发,css,html,js,css3,前端开发博客,fe,技术文档">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://blog.flqin.com/226.html">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>（转载）谈谈使用 promise 时候的一些反模式 | 前端轻语</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?c8dec20f0d0449c8ece3c0dbab4e8f31";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">前端轻语</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">korey的前端笔记</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">97</span></a>

  </li>
        <li class="menu-item menu-item-map">

    <a href="/map/" rel="section"><i class="fa fa-sitemap fa-fw"></i>map</a>

  </li>
        <li class="menu-item menu-item-link">

    <a href="/link/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>link</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <section class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Promise-%E7%9A%84%E8%B5%B7%E6%BA%90"><span class="nav-number">1.</span> <span class="nav-text">Promise 的起源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><span class="nav-number">2.</span> <span class="nav-text">常见错误</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E6%89%8B%E9%94%99%E8%AF%AF-1%EF%BC%9ACallback-hell"><span class="nav-number">2.1.</span> <span class="nav-text">新手错误 1：Callback hell</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E6%89%8B%E9%94%99%E8%AF%AF-2%EF%BC%9A%E6%80%8E%E6%A0%B7%E7%94%A8-forEach-%E5%A4%84%E7%90%86-promise"><span class="nav-number">2.2.</span> <span class="nav-text">新手错误 2：怎样用 forEach() 处理 promise</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E6%89%8B%E9%94%99%E8%AF%AF-3%EF%BC%9A%E5%BF%98%E8%AE%B0%E6%B7%BB%E5%8A%A0-catch-%E6%96%B9%E6%B3%95"><span class="nav-number">2.3.</span> <span class="nav-text">新手错误 3：忘记添加 catch() 方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E6%89%8B%E9%94%99%E8%AF%AF-4%EF%BC%9A%E4%BD%BF%E7%94%A8-%E2%80%9Cdeferred%E2%80%9D"><span class="nav-number">2.4.</span> <span class="nav-text">新手错误 4：使用 “deferred”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E6%89%8B%E9%94%99%E8%AF%AF-5%EF%BC%9A%E4%B8%8D%E6%98%BE%E5%BC%8F%E8%B0%83%E7%94%A8-return"><span class="nav-number">2.5.</span> <span class="nav-text">新手错误 5：不显式调用 return</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E5%8F%A6%E4%B8%80%E4%B8%AA-promise-%E5%AF%B9%E8%B1%A1"><span class="nav-number">2.5.1.</span> <span class="nav-text">返回另一个 promise 对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%90%8C%E6%AD%A5%E7%9A%84%E5%80%BC%E6%88%96%E8%80%85%E6%98%AF-undefined"><span class="nav-number">2.5.2.</span> <span class="nav-text">返回一个同步的值或者是 undefined</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%9B%E5%87%BA%E4%B8%80%E4%B8%AA%E5%90%8C%E6%AD%A5%E7%9A%84%E9%94%99%E8%AF%AF"><span class="nav-number">2.5.3.</span> <span class="nav-text">抛出一个同步的错误</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6%E9%94%99%E8%AF%AF"><span class="nav-number">3.</span> <span class="nav-text">进阶错误</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6%E9%94%99%E8%AF%AF-1%EF%BC%9A%E4%B8%8D%E4%BA%86%E8%A7%A3-Promise-resolve"><span class="nav-number">3.1.</span> <span class="nav-text">进阶错误 1：不了解 Promise.resolve()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6%E9%94%99%E8%AF%AF-2%EF%BC%9Acacth-%E5%92%8C-then-null-%E2%80%A6-%E5%B9%B6%E4%B8%8D%E5%AE%8C%E5%85%A8%E7%9B%B8%E5%90%8C"><span class="nav-number">3.2.</span> <span class="nav-text">进阶错误 2：cacth() 和 then(null, …) 并不完全相同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6%E9%94%99%E8%AF%AF-3%EF%BC%9Apromise-vs-promise-factories"><span class="nav-number">3.3.</span> <span class="nav-text">进阶错误 3：promise vs promise factories</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6%E9%94%99%E8%AF%AF-4%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%88%91%E6%83%B3%E8%A6%81%E4%B8%A4%E4%B8%AA-promise-%E7%9A%84%E7%BB%93%E6%9E%9C%E5%BA%94%E5%BD%93%E5%A6%82%E4%BD%95%E5%81%9A%E5%91%A2"><span class="nav-number">3.4.</span> <span class="nav-text">进阶错误 4：如果我想要两个 promise 的结果应当如何做呢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6%E9%94%99%E8%AF%AF-5%EF%BC%9Apromise-%E7%A9%BF%E9%80%8F"><span class="nav-number">3.5.</span> <span class="nav-text">进阶错误 5：promise 穿透</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AD%94%E6%A1%88%E6%9D%A5%E4%BA%86"><span class="nav-number">3.6.</span> <span class="nav-text">答案来了</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E5%90%8E%E7%9A%84%E8%AF%9D"><span class="nav-number">3.7.</span> <span class="nav-text">最后的话</span></a></li></ol></li></ol></div>
        </section>
        <!--/noindex-->

        <section class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Korey" src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Korey</p>
  <div class="site-description" itemprop="description">热衷于记录、分享前端开发技术</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">97</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3poYW9reQ==" title="GitHub → https://github.com/zhaoky"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmtleXUuemhhb0Bmb3htYWlsLmNvbQ==" title="E-Mail → mailto:keyu.zhao@foxmail.com"><i class="far fa-envelope fa-fw"></i>E-Mail</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vdXNlci81N2M5MWIzYjE2NWFiZDAwNjhkYjg5YzI=" title="掘金 → https://juejin.im/user/57c91b3b165abd0068db89c2"><i class="fas fa-link fa-fw"></i>掘金</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cDovL3d3dy56aGlodS5jb20vcGVvcGxlL2ZlX2tvcmV5" title="知乎 → http://www.zhihu.com/people/fe_korey"><i class="fas fa-link fa-fw"></i>知乎</span>
      </span>
  </div>



        </section>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL3poYW9reQ==" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

  


<div class="post-block">
  
  

  <article itemscope="" itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.flqin.com/226.html">

    <span hidden="" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Korey">
      <meta itemprop="description" content="热衷于记录、分享前端开发技术">
    </span>

    <span hidden="" itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="前端轻语">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          （转载）谈谈使用 promise 时候的一些反模式
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-15 14:28:18" itemprop="dateCreated datePublished" datetime="2018-05-15T14:28:18+00:00">2018-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
          <a href="/categories/FE-Basics/" itemprop="url" rel="index"><span itemprop="name">FE Basics</span></a>
        </span>
    </span>

  
      </div>
      <div class="post-meta">
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>14k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 ≈</span>
      <span>13 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote>
<p>原文链接 <code>https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html</code></p>
</blockquote>
<p>各位 <code>JavaScript</code> 程序员，是时候承认了，我们在使用 <code>promise</code> 的时候，会写出许多有问题的 <code>promise</code> 代码。 当然并不是 <code>promise</code> 本身的问题，<code>A+ spec</code> 规范定义的 <code>promise</code> 非常棒。 在过去的几年中，笔者看到了很多程序员在调用 <code>PouchDB</code> 或者其他 <code>promise</code> 化的 <code>API</code> 时遇到了很多困难。这让笔者认识到，在 <code>JavaScript</code> 程序员之中，只有少数人是真正理解了 <code>promise</code> 规范的。如果这个事实让你难以接受，那么思考一下我在 <code>Twitter</code> 上出的题：</p>
<p>问：下面四个使用 promise 的语句之间的不同点在哪儿？</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> doSomethingElse();</span><br><span class="line">})；</span><br><span class="line"></span><br><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    doSomethingElse();</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">doSomething().then(doSomethingElse());</span><br><span class="line"></span><br><span class="line">doSomething().then(doSomethingElse);</span><br></pre></td></tr></tbody></table></figure>

<p>如果你知道这个问题的答案，那么恭喜你，你已经是一个 <code>promise</code> 大师并且可以直接关闭这个网页了。</p>
<p>但是对于不能回答这个问题的程序员中 99.9% 的人，别担心，你们不是少数派。没有人能够在笔者的 <code>tweet</code> 上完全正确的回答这个问题，而且对于 #3 最终答案也令我感到震惊，即便我是出题人。</p>
<p>答案在本文的底部，但是首先，笔者必须先探究一下 <code>promise</code> 为何如此复杂，为什么不管是新手还是专家都有被 <code>promise</code> 折磨的经历。同时，笔者也会给出自认为能够快速、准确理解 <code>promise</code> 的方法。而且笔者确信读过这篇文章之后，理解 <code>promise</code> 不会那么难了。</p>
<p>在此之前，我们先了解一下有关 <code>promise</code> 的一些常识。</p>
<h2 id="Promise-的起源"><a href="#Promise-的起源" class="headerlink" title="Promise 的起源"></a>Promise 的起源</h2><p>如果你读过有关 <code>promise</code> 的文章，你会发现文章中一定会提到 <code>Callback hell</code>，不说别的，在视觉上，回调金字塔会让你的代码最终超过屏幕的宽度。</p>
<p><code>promise</code> 是能够解决这个问题的，但是它解决的问题不仅仅是缩进。在讨论到如何 解决 <code>Callback hell</code> 问题 的时候，我们遇到真正的难题是回调函数剥夺了程序员使用 <code>return</code> 和 <code>throw</code> 的能力。而程序的执行流程的基础建立于一个函数在执行过程中调用另一个函数时产生的副作用。(译者注：个人对这里副作用的理解是，函数调用函数会产生函数调用栈，而回调函数是不运行在栈上的，因此不能使用 <code>return</code> 和 <code>throw</code>)。</p>
<p>事实上，回调函数还有更恼人的——剥夺我们在栈上执行代码的能力，而在其他语言当中，我们始终都能够在栈上执行代码。编写不在栈上运行的代码就像开没有刹车的车一样，在你真正需要它的时候，才明白它有多么的重要。</p>
<p><code>promise</code> 被设计为能够让我们重新使用那些编程语言的基本要素：<code>return，throw，栈。</code> 在想要使用 <code>promise</code> 之前，我们首先要学会正确使用它。</p>
<h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>一些人尝试使用 漫画 的方式解释 <code>promise</code>，或者是像是解释名词一样解释它：它表示同步代码中的值，并且能在代码中被传递。</p>
<p>笔者并没有觉得这些解释对理解 <code>promise</code> 有用。笔者自己的理解是：<code>promise</code> 是关于代码结构和代码运行流程的。因此，笔者认为展示一些常见错误，并告诉大家如何修正它才是王道。</p>
<p>扯远一点，对于 <code>promise</code>，不同的人有不同的理解，为了本文的最终目的，我在这里只讨论 <code>promise</code> 的官方 规范，在较新版本的浏览器会作为 <code>window</code> 对象的一个属性被暴露出来。然而并不是所有的浏览器都支持这一特性，但是到目前为止有许多 <code>polyfill</code>，比如这个名字很大胆并且实现非常简洁的 <code>promise</code> 库：<code>Lie</code>。</p>
<h3 id="新手错误-1：Callback-hell"><a href="#新手错误-1：Callback-hell" class="headerlink" title="新手错误 1：Callback hell"></a>新手错误 1：Callback hell</h3><p><code>PouchDB</code> 有许多 <code>promise</code> 风格的 <code>API</code>，程序员在写有关 <code>PouchDB</code> 的代码的时候，常常将 <code>promise</code> 用的一塌糊涂。下面给出一种很常见的糟糕写法。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">remote.allDocs({</span><br><span class="line">    include_docs: <span class="literal">true</span>,</span><br><span class="line">    attachment: <span class="literal">true</span></span><br><span class="line">}).then(functionb (result) {</span><br><span class="line">    <span class="keyword">var</span> docs = result.rows;</span><br><span class="line">    docs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>{</span><br><span class="line">        localdb.put(element.doc).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>{</span><br><span class="line">            alert(<span class="string">'pulled doc with id'</span> + element.doc._id + <span class="string">'and added to local db.'</span>);}).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{</span><br><span class="line">        <span class="keyword">if</span> (err.status == <span class="number">409</span>) {</span><br><span class="line">            localdb.get(element.doc._id).then(<span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>{</span><br><span class="line">             localdb.remove(resp._id, resp._rev).then(<span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>{</span><br><span class="line"><span class="comment">// et cetera...</span></span><br></pre></td></tr></tbody></table></figure>

<p>你确实可以将 <code>promise</code> 当做回调函数来使用，但这却是一种杀鸡用牛刀的行为。不过这么做也是可行的。 你可能会认为这种错误是那些刚入行的新手才会犯的。但是笔者在黑莓的 开发者博客 上曾经看到类似的代码。过去的书写回调函数的习惯是很难改变的。</p>
<p>下面给出一种代码风格更好的实现：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">remotedb.allDocs(...).then(functioin (resultofAllDocs) {</span><br><span class="line">    <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">}).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfPut</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> localdb.get(...);</span><br><span class="line">}).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfGet</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">}).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>这就是 <code>promise</code> 的链式调用，它体现 <code>promise</code> 的强大之处，每个函数在上一个 <code>promise</code> 的状态变为 <code>resolved</code> 的时候才会被调用，并且能够得到上一个 <code>promise</code> 的输出结果。稍后还有详细的解释。</p>
<h3 id="新手错误-2：怎样用-forEach-处理-promise"><a href="#新手错误-2：怎样用-forEach-处理-promise" class="headerlink" title="新手错误 2：怎样用 forEach() 处理 promise"></a>新手错误 2：怎样用 forEach() 处理 promise</h3><p>这个问题是大多数人掌握 <code>promise</code> 的绊脚石，当这些人想在代码中使用他们熟悉的 <code>forEach()</code> 方法或者是写一个 <code>for</code> 循环，抑或是 <code>while</code> 循环的时候，都会为如何使用 <code>promise</code> 而疑惑不已。他们会写下这样的代码：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// I want to remove() all docs</span></span><br><span class="line">db.allDocs({ <span class="attr">include_docs</span>: <span class="literal">true</span> })</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>{</span><br><span class="line">    result.rows.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">row</span>) </span>{</span><br><span class="line">      db.remove(row.doc);</span><br><span class="line">    });</span><br><span class="line">  })</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="comment">// I naively believe all docs have been removed() now!</span></span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure>

<p>这段代码的问题在于第一个回调函数实际上返回的是 <code>undefined</code>，也就意味着第二个函数并不是在所有的 <code>db.remove()</code> 执行结束之后才执行。事实上，第二个函数的执行不会有任何延时，它执行的时候被删除的 <code>doc</code> 数量可能为任意整数。</p>
<p>这段代码看起来是能够正常工作的，因此这个 <code>bug</code> 也具有一定的隐藏性。写这代码的人以为 <code>PouchDB</code> 已经删除了这些 <code>docs</code>，可以更新 <code>UI</code> 了。这个 <code>bug</code> 会在一定几率下出现，或者是特定的浏览器。而一旦出现，这种 <code>bug</code> 是很难调试的。</p>
<p>一言以蔽之，你需要的不是 <code>forEach()/for/while</code> 而是 <code>Promise.all()：</code></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.allDocs({ <span class="attr">include_docs</span>: <span class="literal">true</span> })</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">      result.rows.map(<span class="function"><span class="keyword">function</span> (<span class="params">row</span>) </span>{</span><br><span class="line">        <span class="keyword">return</span> db.remove(row.doc);</span><br><span class="line">      })</span><br><span class="line">    );</span><br><span class="line">  })</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">arrayObject</span>) </span>{</span><br><span class="line">    <span class="comment">// All docs have really been removed() now!</span></span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure>

<p>从根本上说，<code>Promise.all()</code> 以一个 <code>promise</code> 对象组成的数组为输入，返回另一个 <code>promise</code> 对象。这个对象的状态只会在数组中所有的 <code>promise</code> 对象的状态都变为 <code>resolved</code> 的时候才会变成 <code>resolved</code>。可以将其理解为异步的 <code>for</code> 循环。</p>
<p><code>Promise.all()</code> 还会将计算结果以数组的形式传递给下一个函数，这一点十分有用。举例来说，如果你想用 <code>get()</code> 方法从 <code>PouchDB</code> 得到多个值的时候，就可以利用这个特性。同时，作为输入的一系列 <code>promise</code> 对象中，如果有一个的状态变为 <code>rejected</code>，那么 <code>all()</code> 返回的 <code>promise</code> 对象的状态也会变为 <code>rejected</code>。</p>
<h3 id="新手错误-3：忘记添加-catch-方法"><a href="#新手错误-3：忘记添加-catch-方法" class="headerlink" title="新手错误 3：忘记添加 catch() 方法"></a>新手错误 3：忘记添加 catch() 方法</h3><p>这是一个很常见的错误。很多程序员对他们代码中的 <code>promise</code> 调用十分自信，觉得代码永远不会抛出一个 <code>error</code>，也可能他们只是简单的忘了加 <code>catch()</code> 方法。不幸的是，不加 <code>catch()</code> 方法会让回调函数中抛出的异常被吞噬，在你的控制台是看不到相应的错误的，这对调试来说是非常痛苦的。</p>
<p>为了避免这种糟糕的情况，我已经养成了在自己的 <code>promise</code> 调用链最后添加如下代码的习惯：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">somePromise()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> anotherPromise();</span><br><span class="line">  })</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> yetAnotherPromise();</span><br><span class="line">  })</span><br><span class="line">  .catch(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>)); <span class="comment">// &lt;-- this is badass</span></span><br></pre></td></tr></tbody></table></figure>

<p>即使你并不打算在代码中处理异常，在代码中添加 <code>catch()</code> 也是一个谨慎的编程风格的体现。在某种情况下你原先的假设出错的时候，这会让你的调试工作轻松一些。</p>
<h3 id="新手错误-4：使用-“deferred”"><a href="#新手错误-4：使用-“deferred”" class="headerlink" title="新手错误 4：使用 “deferred”"></a>新手错误 4：使用 “deferred”</h3><p>这类型 错误 笔者经常看到，在这里我也不想重复它了。简而言之，<code>promise</code> 经过了很长一段时间的发展，有一定的历史包袱。<code>JavaScript</code> 社区用了很长的时间才纠正了发展道路上的一些错误。<code>jQuery</code> 和 <code>Angular</code> 早期都在使用 <code>deferred</code> 类型的 <code>promise</code>。而在最新的 <code>ES6</code> 的 <code>Promise</code> 标准中，这种实现方式已经被替代了，同时，一些 <code>Promise</code> 的库，比如 <code>Q，bluebid，Lie</code> 也是参照 <code>ES6</code> 的标准来实现的。</p>
<p>如果你还在代码中使用 <code>deferred</code> 的话，那么你就是走在错误的道路上了，这里笔者给出一些修正的办法。</p>
<p>首先，绝大多数的库都给出了将第三方库的方法包装成 <code>promise</code> 对象的方法。举例来说，<code>Angular</code> 的 <code>$q</code> 模块可以使用 <code>$q.when()</code> 完成这一包装过程。因此，在 <code>Angular</code> 中，包装 <code>PouchDB</code> 的 <code>promise API</code> 的代码如下：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$q.when(db.put(doc)).then(...) <span class="comment">// &lt;-- this is all the code you need</span></span><br></pre></td></tr></tbody></table></figure>

<p>另一种方法就是使用暴露给程序员的 构造函数。<code>promise</code> 的构造函数能够包装那些非 <code>promise</code> 的 <code>API</code>。下面给出一个例子，在该例中将 <code>Node.js</code> 提供的 f<code>s.readFile()</code> 方法包装成 <code>promise</code>。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>{</span><br><span class="line">    fs.readFile(<span class="string">'myfile.txt'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>{</span><br><span class="line">        <span class="keyword">if</span> (err) {</span><br><span class="line">            <span class="keyword">return</span> reject(err);</span><br><span class="line">        }</span><br><span class="line">        resolve(file);</span><br><span class="line">    });</span><br><span class="line">}).then(...)</span><br></pre></td></tr></tbody></table></figure>

<p>齐活！</p>
<p>如果你想更多的了解为什么这样的写法是一个反模式，猛戳这里 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BldGthYW50b25vdi9ibHVlYmlyZC93aWtpL1Byb21pc2UtYW50aS1wYXR0ZXJucyN0aGUtZGVmZXJyZWQtYW50aS1wYXR0ZXJu">the Bluebird wiki page on promise anti-patterns<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="新手错误-5：不显式调用-return"><a href="#新手错误-5：不显式调用-return" class="headerlink" title="新手错误 5：不显式调用 return"></a>新手错误 5：不显式调用 return</h3><p>下面这段代码的问题在哪里？</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">somePromise()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    someOtherPromise();</span><br><span class="line">  })</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="comment">// Gee, I hope someOtherPromise() has resolved</span></span><br><span class="line">    <span class="comment">// Spoiler alert: it hasn't</span></span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure>

<p>现在该讨论所有需要了解的关于 <code>promise</code> 的知识点了。理解了这一个知识点，笔者提到的一些错误你都不会犯了。</p>
<p>正如笔者前面所说的，<code>promise</code> 的神奇之处在于让我们能够在回调函数里面使用 <code>return</code> 和 <code>throw</code>。但是实践的时候是什么样子呢？</p>
<p>每一个 <code>promise</code> 对象都会提供一个 <code>then</code> 方法或者是 <code>catch</code> 方法：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  <span class="comment">// I'm inside a then() function!</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>在 <code>then</code> 方法内部，我们可以做三件事：</p>
<ul>
<li><code>return</code> 一个 <code>promise</code> 对象</li>
<li><code>return</code> 一个同步的值或者是 <code>undefined</code></li>
<li>同步的 <code>throw</code> 一个错误</li>
</ul>
<p>理解这三种情况之后，你就会理解 <code>promise</code> 了。</p>
<h4 id="返回另一个-promise-对象"><a href="#返回另一个-promise-对象" class="headerlink" title="返回另一个 promise 对象"></a>返回另一个 promise 对象</h4><p>在有关 <code>promise</code> 的相关文章中，这种写法很常见，就像上文提到的构成 <code>promise</code> 链的一段代码：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">  })</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>{});</span><br></pre></td></tr></tbody></table></figure>

<p>这段代码里面的 <code>return</code> 非常关键，没有这个 <code>return</code> 的话，<code>getUserAccountById</code> 只是一个普通的被别的函数调用的函数。下一个回调函数会接收到 <code>undefined</code> 而不是 <code>userAccount</code>。</p>
<h4 id="返回一个同步的值或者是-undefined"><a href="#返回一个同步的值或者是-undefined" class="headerlink" title="返回一个同步的值或者是 undefined"></a>返回一个同步的值或者是 <code>undefined</code></h4><p>返回一个 <code>undefined</code> 大多数情况下是错误的，但是返回一个同步的值确实是一个将同步代码转化成 <code>promise</code> 风格代码的好方法。举个例子，现在在内存中有 <code>users</code>。我们可以：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>{</span><br><span class="line">    <span class="keyword">if</span> (inMemoryCache[user.id]) {</span><br><span class="line">      <span class="keyword">return</span> inMemoryCache[user.id]; <span class="comment">// returning a synchronous value!</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> inMemoryCache[user.id]; <span class="comment">// returning a promise</span></span><br><span class="line">  })</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>{</span><br><span class="line">    <span class="comment">// I got a user account</span></span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure>

<p>第二个回调函数并不关心 <code>userAccount</code> 是通过同步的方式得到的还是异步的方式得到的，而第一个回调函数即可以返回同步的值又可以返回异步的值。</p>
<p>不幸的是，如果不显式调用 <code>return</code> 语句的话，<code>JavaScript</code> 里的函数会返回 <code>undefined</code>。这也就意味着在你想返回一些值的时候，不显式调用 <code>return</code> 会产生一些副作用。</p>
<p>鉴于以上原因，笔者养成了一个在 <code>then</code> 方法内部永远显式的调用 <code>return</code> 或者 <code>throw</code> 的习惯。建议你也这样做。</p>
<h4 id="抛出一个同步的错误"><a href="#抛出一个同步的错误" class="headerlink" title="抛出一个同步的错误"></a>抛出一个同步的错误</h4><p>说到 <code>throw</code>，这又体现了 <code>promise</code> 的功能强大。在用户退出的情况下，我们的代码中会采用抛出异常的方式进行处理：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>{</span><br><span class="line">    <span class="keyword">if</span> (user.isLoggedOut()) {</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'user logged out!'</span>); <span class="comment">// throwing a synchronous error!</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (inMemoryCache[user.id]) {</span><br><span class="line">      <span class="keyword">return</span> inMemoryCache[user.id]; <span class="comment">// returning a synchronous value!</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id); <span class="comment">// returning a promise!</span></span><br><span class="line">  })</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>{</span><br><span class="line">    <span class="comment">// I got a user account!</span></span><br><span class="line">  })</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{</span><br><span class="line">    <span class="comment">// Boo, I got an error!</span></span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure>

<p>如果用户已经登出的话，<code>catch()</code> 会收到一个同步的错误，如果有 <code>promise</code> 对象的状态变为 <code>rejected</code> 的话，它还会收到一个异步的错误。<code>catch()</code> 的回调函数不用关心错误是异步的还是同步的。</p>
<p>在使用 <code>promise</code> 的时候抛出异常在开发阶段很有用，它能帮助我们定位代码中的错误。比方说，在 <code>then</code> 函数内部调用 <code>JSON.parse（）</code>，如果 <code>JSON</code> 对象不合法的话，可能会抛出异常，在回调函数中，这个异常会被吞噬，但是在使用 <code>promise</code> 之后，我们就可以捕获到这个异常了。</p>
<h2 id="进阶错误"><a href="#进阶错误" class="headerlink" title="进阶错误"></a>进阶错误</h2><p>接下来我们讨论一下使用 <code>promise</code> 的边界情况。</p>
<p>下面的错误笔者将他们归类为 “进阶错误”，因为这些错误发生在那些已经相对熟练使用 <code>promise</code> 的程序员身上。但是为了解决本文开头提出的问题，还是有必要对其进行讨论。</p>
<h3 id="进阶错误-1：不了解-Promise-resolve"><a href="#进阶错误-1：不了解-Promise-resolve" class="headerlink" title="进阶错误 1：不了解 Promise.resolve()"></a>进阶错误 1：不了解 Promise.resolve()</h3><p>就像之前所说的，<code>promise</code> 能够将同步代码包装成异步的形式。然而，如果你经常写出如下的代码：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>{</span><br><span class="line">  resolve(someSynchronousValue);</span><br><span class="line">}).then(...);</span><br></pre></td></tr></tbody></table></figure>

<p>你可以使用 <code>Promise.resolve()</code> 将上述代码精简。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(someSynchronousValue).then(...);</span><br></pre></td></tr></tbody></table></figure>

<p>在捕获同步异常的时候这个做法也是很有效的。我在编写 <code>API</code> 的时候已经养成了使用 <code>Promise.resolve()</code> 的习惯：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">somePromiseAPI</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    doSomethingThatMayThrow();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'foo'</span>;</span><br><span class="line">  }).then(...);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>记住，有可能抛出错误的代码都有可能因为错误被吞噬而对你的工作造成困扰。但是如果你用 <code>Promise.resolve()</code> 包装了代码的话，你永远都可以在代码后面加上 <code>catch()</code>。</p>
<p>相同的，使用 <code>Promise.reject()</code> 可以立即返回一个状态为 <code>rejected</code> 的 <code>promise</code> 对象。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'some awful error'</span>));</span><br></pre></td></tr></tbody></table></figure>

<h3 id="进阶错误-2：cacth-和-then-null-…-并不完全相同"><a href="#进阶错误-2：cacth-和-then-null-…-并不完全相同" class="headerlink" title="进阶错误 2：cacth() 和 then(null, …) 并不完全相同"></a>进阶错误 2：cacth() 和 then(null, …) 并不完全相同</h3><p>笔者提到过 <code>cacth()</code> 是 <code>then(null, ...)</code> 的语法糖，因此下面两个代码片段是等价的</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">somePromise().catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">somePromise().then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>但是，这并不意味着下面的两个代码片段是等价的</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">somePromise()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> someOtherPromise();</span><br><span class="line">  })</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">somePromise().then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> someOtherPromise();</span><br><span class="line">  },</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">  }</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<p>如果你不理解的话，那么请思考一下如果第一个回调函数抛出一个错误会发生什么？</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">somePromise()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh noes'</span>);</span><br><span class="line">  })</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{</span><br><span class="line">    <span class="comment">// I caught your error! :)</span></span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">somePromise().then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'oh noes'</span>);</span><br><span class="line">  },</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{</span><br><span class="line">    <span class="comment">// I didn't catch your error! :(</span></span><br><span class="line">  }</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<p>结论就是，当使用 <code>then(resolveHandler, rejectHandler)</code>，<code>rejectHandler</code> 不会捕获在 <code>resolveHandler</code> 中抛出的错误。</p>
<p>因为，笔者的个人习惯是从不使用 <code>then</code> 方法的第二个参数，转而使用 <code>catch()</code> 方法。但是也有例外，就是在笔者写异步的 <code>Mocha</code> 的测试用例的时候，如果想确认一个错误被抛出的话，代码是这样的：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'should throw an error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> doSomethingThatThrows().then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'I expected an error!'</span>);</span><br><span class="line">    },</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{</span><br><span class="line">      should.exist(err);</span><br><span class="line">    }</span><br><span class="line">  );</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>说到测试，将 <code>mocha</code> 和 <code>Chai</code> 联合使用是一种很好的测试 <code>promise API</code> 的方案。</p>
<h3 id="进阶错误-3：promise-vs-promise-factories"><a href="#进阶错误-3：promise-vs-promise-factories" class="headerlink" title="进阶错误 3：promise vs promise factories"></a>进阶错误 3：promise vs promise factories</h3><p>某些情况下你想一个接一个的执行一系列 <code>promise</code>，这时候你想要一个类似于 <code>Promise.all()</code> 的方法，但是 <code>Proimise.all()</code> 是并行执行的，不符合要求。你可能一时脑抽写下这样的代码：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeSequentially</span>(<span class="params">promises</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  promises.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">promise</span>) </span>{</span><br><span class="line">    result = result.then(promise);</span><br><span class="line">  });</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>不幸的是，这段代码不会按照你所想的那样执行，那些 <code>promise</code> 对象里的异步调用还是会并行的执行。原因是你根本不应当在 <code>promise</code> 对象组成的数组这个层级上操作。对于每个 <code>promise</code> 对象来说，一旦它被创建，相关的异步代码就开始执行了。因此，这里你真正想要的是一个 <code>promise</code> 工厂。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeSequentially</span>(<span class="params">promiseFactories</span>) </span>{</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  promiseFactories.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">promiseFactory</span>) </span>{</span><br><span class="line">    result = result.then(promiseFactory);</span><br><span class="line">  });</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>一个 <code>promise</code> 工厂非常简单，它就是一个返回 <code>promise</code> 对象的函数</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromiseFactory</span>(<span class="params"></span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> somethingThatCreatesAPromise();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>为什么采用 <code>promise</code> 对象就可以达到目的呢？因为 <code>promise</code> 工厂只有在调用的时候才会创建 <code>promise</code> 对象。它和 <code>then()</code> 方法的工作方式很像，事实上，它们就是一样的东西。</p>
<h3 id="进阶错误-4：如果我想要两个-promise-的结果应当如何做呢"><a href="#进阶错误-4：如果我想要两个-promise-的结果应当如何做呢" class="headerlink" title="进阶错误 4：如果我想要两个 promise 的结果应当如何做呢"></a>进阶错误 4：如果我想要两个 promise 的结果应当如何做呢</h3><p>很多时候，一个 <code>promise</code> 的执行是依赖另一个 <code>promise</code> 的。但是在某些情况下，我们想得到两个 <code>promise</code> 的执行结果，比方说：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">  })</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>{</span><br><span class="line">    <span class="comment">// dangit, I need the "user" object too!</span></span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure>

<p>为了避免金字塔问题，我们可能会在外层作用域存储 <code>user</code> 对象。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user;</span><br><span class="line">getUserByName(<span class="string">'nolan'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>{</span><br><span class="line">    user = result;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">  })</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>{</span><br><span class="line">    <span class="comment">// okay, I have both the "user" and the "userAccount"</span></span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码能够到达想要的效果，但是这种显得不够专业，我建议抛开成见，拥抱金字塔：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">'nolan'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>{</span><br><span class="line">    <span class="comment">// okay, I have both the "user" and the "userAccount"</span></span><br><span class="line">  });</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>至少，是暂时拥抱金字塔。如果缩进真的成为了你代码中的一个大问题，那么你可以像每一个 <code>JavaScript</code> 程序员从开始写代码起就被教导的一样，将其中的部分抽出来作为一个单独的函数。</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onGetUserAndUserAccount</span>(<span class="params">user, userAccount</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> doSomething(user, userAccount);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onGetUser</span>(<span class="params">user</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> onGetUserAndUserAccount(user, userAccount);</span><br><span class="line">  });</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">getUserByName(<span class="string">'nolan'</span>)</span><br><span class="line">  .then(onGetUser)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="comment">// at this point, doSomething() is done, and we are back to indentation 0</span></span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure>

<p>随着你的 <code>promise</code> 代码越来越复杂，你会将越来越多的代码作为函数抽离出来。笔者发现这会促进代码风格变得优美：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">putYourRightFootIn().then(putYourRightFootOut).then(putYourRightFootIn).then(shakeItAllAbout);</span><br></pre></td></tr></tbody></table></figure>

<p>这就是 <code>promise</code> 的最终目的。</p>
<h3 id="进阶错误-5：promise-穿透"><a href="#进阶错误-5：promise-穿透" class="headerlink" title="进阶错误 5：promise 穿透"></a>进阶错误 5：promise 穿透</h3><p>这个错误我在前文中提到的问题中间接的给出了。这是个非常令人费解的案例，或许你永远不会写出这样的代码，但是这种写法还是让笔者感到震惊。 你认为下面的代码会输出什么？</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line">  .then(<span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>))</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure>

<p>如果你认为输出的是 <code>bar</code>，那么你就错了。实际上它输出的是 <code>foo</code>！</p>
<p>产生这样的输出是因为你给 <code>then</code> 方法传递了一个非函数（比如 <code>promise</code> 对象）的值，代码会这样理解：<code>then(null)</code>，因此导致前一个 <code>promise</code> 的结果产生了坠落的效果。你可以自己测试一下：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line">  .then(<span class="literal">null</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure>

<p>随便添加任意多个 <code>then(null)</code>，结果都是不变的</p>
<p>让我们回到之前讲解 <code>promise vs promise factoriesde</code> 的地方。简而言之，如果你直接给 <code>then</code> 方法传递一个 <code>promise</code> 对象，代码的运行是和你所想的不一样的。<code>then</code> 方法应当接受一个函数作为参数。因此你应当这样书写代码：</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">'bar'</span>);</span><br><span class="line">  })</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure>

<p>这样就会如愿输出 <code>bar</code>。</p>
<h3 id="答案来了"><a href="#答案来了" class="headerlink" title="答案来了"></a>答案来了</h3><p>下面给出前文题目的解答</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#1</span><br><span class="line"></span><br><span class="line">    doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">      <span class="keyword">return</span> doSomethingElse();</span><br><span class="line">    }).then(finalHandler);</span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line">    doSomething</span><br><span class="line">    |-----------------|</span><br><span class="line">                      doSomethingElse(<span class="literal">undefined</span>)</span><br><span class="line">                      |------------------|</span><br><span class="line">                                         finalHandler(resultOfDoSomethingElse)</span><br><span class="line">                                         |------------------|</span><br><span class="line"></span><br><span class="line">#2</span><br><span class="line"></span><br><span class="line">    doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">      doSomethingElse();</span><br><span class="line">    }).then(finalHandler);</span><br><span class="line"><span class="string">``</span></span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line">    doSomething</span><br><span class="line">    |-----------------|</span><br><span class="line">                      doSomethingElse(<span class="literal">undefined</span>)</span><br><span class="line">                      |------------------|</span><br><span class="line">                      finalHandler(<span class="literal">undefined</span>)</span><br><span class="line">                      |------------------|</span><br><span class="line"></span><br><span class="line">#3</span><br><span class="line"></span><br><span class="line">    doSomething().then(doSomethingElse())</span><br><span class="line">      .then(finalHandler);</span><br><span class="line"></span><br><span class="line">答案</span><br><span class="line"></span><br><span class="line">    doSomething</span><br><span class="line">    |-----------------|</span><br><span class="line">    doSomethingElse(<span class="literal">undefined</span>)</span><br><span class="line">    |---------------------------------|</span><br><span class="line">                      finalHandler(resultOfDoSomething)</span><br><span class="line">                      |------------------|</span><br><span class="line"></span><br><span class="line">#4</span><br><span class="line"></span><br><span class="line">    doSomething().then(doSomethingElse)</span><br><span class="line">      .then(finalHandler);</span><br><span class="line"></span><br><span class="line">答案</span><br><span class="line"></span><br><span class="line">    doSomething</span><br><span class="line">    |-----------------|</span><br><span class="line">                      doSomethingElse(resultOfDoSomething)</span><br><span class="line">                      |------------------|</span><br><span class="line">                                         finalHandler(resultOfDoSomethingElse)</span><br><span class="line">                                         |------------------|</span><br></pre></td></tr></tbody></table></figure>

<p>需要说明的是，在上述的例子中，我都假设 <code>doSomething()</code> 和 <code>doSomethingElse()</code> 返回一个 <code>promise</code> 对象，这些 <code>promise</code> 对象都代表了一个异步操作，这样的操作会在当前 <code>event loop</code> 之外结束，比如说有关 <code>IndexedDB，network</code> 的操作，或者是使用 <code>setTimeout</code>。这里给出 <span class="exturl" data-url="aHR0cDovL2pzYmluLmNvbS90dXF1a2FrYXdvLzEvZWRpdD9qcyxjb25zb2xlLG91dHB1dA==">JSBin<i class="fa fa-external-link-alt"></i></span> 上的示例。</p>
<h3 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h3><p><code>promise</code> 是个好东西。如果你还在使用传统的回调函数的话，我建议你迁移到 <code>promise</code> 上。这样你的代码会更简洁，更优雅，可读性也更强。</p>
<p>有这样的观点：<code>promise</code> 是不完美的。<code>promise</code> 确实比使用回调函数好，但是，如果你有别的选择的话，这两种方式最好都不要用。</p>
<p>尽管相比回调函数有许多优点，promise 仍然是难于理解的，并且使用起来很容易出错。新手和卖家都会经常将 <code>promise</code> 用的乱七八糟。不过这并不是他们的错。问题在于 <code>promise</code> 和我们写的同步代码非常相似，但仅此而已，并不尽然。</p>
<p>在同步环境下，你无需学习这些晦涩难懂的规则和新的 <code>API</code>。你可以随意使用像 <code>return</code>、<code>catch</code> 和 <code>throw</code> 这样的关键字以及 <code>for</code> 循环。你不需要时刻在脑中保持两个相并列的编程思想。</p>

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/224.html" rel="prev" title="BFC等Formatting Contexts浅析">
                  <i class="fa fa-chevron-left"></i> BFC等Formatting Contexts浅析
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/230.html" rel="next" title="函数声明、函数表达式等浅析">
                  函数声明、函数表达式等浅析 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  © 2015 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Korey zhao</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">514k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:48</span>
  </span>
</div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1.16.0/dist/lozad.min.js"></script>


  
  




  















  








  

  

<script src="https://cdn.jsdelivr.net/npm/live2d-widget@^3.1.3/lib/L2Dwidget.min.js"></script>

<script src="/bundle.js"></script><script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  ;
L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"superSample":2,"width":125,"height":150,"position":"left","hOffset":30,"vOffset":-5},"mobile":{"show":false,"scale":0.05},"react":{"opacityDefault":1,"opacityOnHover":0.2},"log":false});</script></body></html>