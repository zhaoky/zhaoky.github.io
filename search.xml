<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于electron开发在线课堂</title>
      <link href="411.html"/>
      <url>411.html</url>
      
        <content type="html"><![CDATA[<p>此文不讲整体项目思路，只是对该项目开发的一些踩坑总结，备忘用。</p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><h3 id="音视频流"><a href="#音视频流" class="headerlink" title="音视频流"></a>音视频流</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnJ0Yy9zYW1wbGVz">webrtc samples github<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93ZWJydGMuZ2l0aHViLmlvL3NhbXBsZXMv">webrtc samples<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL0FuYWx5c2VyTm9kZS9nZXRGbG9hdEZyZXF1ZW5jeURhdGE=">如何绘制麦克风实时音量图谱<i class="fa fa-external-link-alt"></i></span></li></ul><h3 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a>腾讯云</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly9jb25zb2xlLmNsb3VkLnRlbmNlbnQuY29tL2xpdmUvbGl2ZXN0YXQ=">云直播 LIVE 控制台<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jb25zb2xlLmNsb3VkLnRlbmNlbnQuY29tL2lt">即时通信 IM 控制台<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jb25zb2xlLmNsb3VkLnRlbmNlbnQuY29tL3RydGM=">实时音视频 TRTC 控制台<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly90cnRjLTEyNTI0NjM3ODguZmlsZS5teXFjbG91ZC5jb20vd2ViL2RlbW8vb2ZmaWNpYWwtZGVtby9pbmRleC5odG1s">web 设备检测<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9pbXNkay0xMjUyNDYzNzg4LmZpbGUubXlxY2xvdWQuY29tL0lNX0RPQy9XZWIvVElNLmh0bWw=">IM Web SDK<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly90cnRjLTEyNTI0NjM3ODguZmlsZS5teXFjbG91ZC5jb20vd2ViL2RvY3MvaW5kZXguaHRtbA==">TRTC Web SDK<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly90cnRjLTEyNTI0NjM3ODguZmlsZS5teXFjbG91ZC5jb20vZWxlY3Ryb25fc2RrL2RvY3MvaW5kZXguaHRtbA==">TRTC ELECTRON SDK<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kb2N1bWVudC9wcm9kdWN0LzY4MA==">在线教育互动课堂 SAAS<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kb2N1bWVudC9wcm9kdWN0LzY0Ny80NTQ2Ng==">trtc-electron-education API<i class="fa fa-external-link-alt"></i></span></li></ul><p>注：</p><ol><li>在线课堂 <code>electron</code> 应用可以基于<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kb2N1bWVudC9wcm9kdWN0LzY0Ny80NTQ2NQ==">实时互动课堂(Electron)<i class="fa fa-external-link-alt"></i></span>开发，本质是<code>实时音视频trtc+即时通讯im</code>的组合。</li><li>虽然 <code>electron</code> 本质是打包 <code>web</code> 应用，但由于腾讯云 <code>SDK</code> 实现问题，<code>TRTC Web SDK</code> 并不能用在 <code>electron</code> 应用里，可能会有兼容问题。</li></ol><h3 id="electron"><a href="#electron" class="headerlink" title="electron"></a>electron</h3><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxlY3Ryb25qcy5vcmcv">electron<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1FETWFya01hbi9Db2RlQmxvZy90cmVlL21hc3Rlci9FbGVjdHJvbg==">electron 简单介绍<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxlY3Ryb25qcy5vcmcvZG9jcy9hcGkvYnJvd3Nlci13aW5kb3c=">electron BrowserWindow API<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VsZWN0cm9uLXJlYWN0LWJvaWxlcnBsYXRlL2VsZWN0cm9uLXJlYWN0LWJvaWxlcnBsYXRl">electron react 模板<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxlY3Ryb24uYnVpbGQv">打包器 electron-builder<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWxlY3Ryb24uYnVpbGQvYXV0by11cGRhdGU=">自动更新 electron-updater<i class="fa fa-external-link-alt"></i></span></li></ul><h2 id="记录点"><a href="#记录点" class="headerlink" title="记录点"></a>记录点</h2><h3 id="异步获取系统设备"><a href="#异步获取系统设备" class="headerlink" title="异步获取系统设备"></a>异步获取系统设备</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getDeviceList = <span class="keyword">async</span> (type: MediaType): <span class="built_in">Promise</span>&lt;[Device | <span class="literal">null</span>, Device[]]&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (!deviceInfo) &#123;</span><br><span class="line">    <span class="keyword">const</span> devices = <span class="keyword">await</span> navigator.mediaDevices.enumerateDevices();</span><br><span class="line">    <span class="keyword">const</span> deviceMap: DeviceMap = &#123;</span><br><span class="line">      audiooutput: <span class="string">&#x27;speaker&#x27;</span>,</span><br><span class="line">      audioinput: <span class="string">&#x27;microphone&#x27;</span>,</span><br><span class="line">      videoinput: <span class="string">&#x27;camera&#x27;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> curDeviceInfo: DeviceInfo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    devices.forEach(<span class="function">(<span class="params">&#123; deviceId, kind, label &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!curDeviceInfo[deviceMap[kind]]) &#123;</span><br><span class="line">        curDeviceInfo[deviceMap[kind]] = [];</span><br><span class="line">      &#125;</span><br><span class="line">      curDeviceInfo[deviceMap[kind]]!.push(&#123;</span><br><span class="line">        deviceId,</span><br><span class="line">        kind,</span><br><span class="line">        label,</span><br><span class="line">        isCurrent: deviceId === <span class="string">&#x27;default&#x27;</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">Object</span>.values(curDeviceInfo).forEach(<span class="function">(<span class="params">item: Device[]</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.length === <span class="number">1</span>) &#123;</span><br><span class="line">        item[<span class="number">0</span>].isCurrent = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    deviceInfo = curDeviceInfo;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> list = deviceInfo[type]!;</span><br><span class="line">  <span class="keyword">if</span> (!list || list.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="literal">null</span>, []];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> curDevice = list!.filter(<span class="function">(<span class="params">device</span>) =&gt;</span> device.isCurrent)[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> [curDevice, list];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="选择对应扬声器"><a href="#选择对应扬声器" class="headerlink" title="选择对应扬声器"></a>选择对应扬声器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectSpeackerDevice = (current: HTMLMediaElement): <span class="function">(<span class="params">(id: string) =&gt; <span class="keyword">void</span></span>) =&gt;</span> <span class="function">(<span class="params">id: string</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> currentId = counterId;</span><br><span class="line">  current</span><br><span class="line">    .setSinkId(id)</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      current.currentTime = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (currentId !== counterId) &#123;</span><br><span class="line">        current.pause();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      current.play();</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      message.error(<span class="string">`获取扬声器失败！`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(e);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="清除-media-流及动画"><a href="#清除-media-流及动画" class="headerlink" title="清除 media 流及动画"></a>清除 media 流及动画</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> clearMediaAndAnimate = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (mediaStream) &#123;</span><br><span class="line">    mediaStream.getTracks()[<span class="number">0</span>].stop();</span><br><span class="line">  &#125;</span><br><span class="line">  cancelAnimationFrame(animate);</span><br><span class="line">  counterId += <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="选择对应麦克风并绘制音量图谱"><a href="#选择对应麦克风并绘制音量图谱" class="headerlink" title="选择对应麦克风并绘制音量图谱"></a>选择对应麦克风并绘制音量图谱</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setCanvas = <span class="function">(<span class="params">current: HTMLCanvasElement</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; width, height &#125; = current;</span><br><span class="line">  <span class="keyword">const</span> canvasCtx = current.getContext(<span class="string">&#x27;2d&#x27;</span>)!;</span><br><span class="line">  canvasCtx.clearRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">  canvasCtx.fillStyle = <span class="string">&#x27;#fff&#x27;</span>;</span><br><span class="line">  canvasCtx.fillRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">info: number</span>) =&gt;</span> &#123;</span><br><span class="line">    canvasCtx.clearRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    canvasCtx.fillRect(<span class="number">0</span>, <span class="number">0</span>, info, height);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; info; i += <span class="number">1</span>) &#123;</span><br><span class="line">      canvasCtx.beginPath();</span><br><span class="line">      canvasCtx.lineWidth = <span class="number">2</span>;</span><br><span class="line">      canvasCtx.strokeStyle = i % <span class="number">2</span> ? <span class="string">`#437BFF`</span> : <span class="string">&#x27;#fff&#x27;</span>;</span><br><span class="line">      canvasCtx.moveTo(i, <span class="number">0</span>);</span><br><span class="line">      canvasCtx.lineTo(i, height);</span><br><span class="line">      canvasCtx.stroke();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> selectMicrophoneDevice = (current: HTMLCanvasElement): <span class="function">(<span class="params">(id: string) =&gt; <span class="keyword">void</span></span>) =&gt;</span> <span class="function">(<span class="params">id: string</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> currentId = counterId;</span><br><span class="line">  <span class="keyword">const</span> constraints = &#123;</span><br><span class="line">    audio: &#123; <span class="attr">deviceId</span>: &#123; <span class="attr">exact</span>: id &#125; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> drawCanvas = setCanvas(current);</span><br><span class="line">  <span class="keyword">const</span> audioCtx = <span class="keyword">new</span> AudioContext();</span><br><span class="line">  <span class="keyword">const</span> analyser = audioCtx.createAnalyser(); <span class="comment">// 频率及时间域分析器</span></span><br><span class="line">  analyser.fftSize = <span class="number">256</span>;</span><br><span class="line">  <span class="keyword">let</span> source;</span><br><span class="line"></span><br><span class="line">  navigator.mediaDevices</span><br><span class="line">    .getUserMedia(constraints)</span><br><span class="line">    .then(<span class="function">(<span class="params">stream</span>) =&gt;</span> &#123;</span><br><span class="line">      mediaStream = stream;</span><br><span class="line">      <span class="keyword">if</span> (currentId !== counterId) &#123;</span><br><span class="line">        clearMediaAndAnimate();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      source = audioCtx.createMediaStreamSource(stream); <span class="comment">// 创建源</span></span><br><span class="line">      source.connect(analyser);</span><br><span class="line">      <span class="keyword">const</span> dataArray = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(analyser.frequencyBinCount);</span><br><span class="line">      <span class="keyword">const</span> draw = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        animate = requestAnimationFrame(draw);</span><br><span class="line">        analyser.getByteFrequencyData(dataArray);</span><br><span class="line">        drawCanvas(dataArray[<span class="number">0</span>]);</span><br><span class="line">      &#125;;</span><br><span class="line">      draw();</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      message.error(<span class="string">`获取麦克风失败！`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(e);</span><br><span class="line">      clearMediaAndAnimate();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="选择对应摄像头"><a href="#选择对应摄像头" class="headerlink" title="选择对应摄像头"></a>选择对应摄像头</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> selectCameraDevice = (current: HTMLVideoElement): <span class="function">(<span class="params">(id: string) =&gt; <span class="keyword">void</span></span>) =&gt;</span> <span class="function">(<span class="params">id: string</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> currentId = counterId;</span><br><span class="line">  <span class="keyword">const</span> constraints = &#123;</span><br><span class="line">    video: &#123; <span class="attr">deviceId</span>: &#123; <span class="attr">exact</span>: id &#125; &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  navigator.mediaDevices</span><br><span class="line">    .getUserMedia(constraints)</span><br><span class="line">    .then(<span class="function">(<span class="params">stream</span>) =&gt;</span> &#123;</span><br><span class="line">      mediaStream = stream;</span><br><span class="line">      <span class="keyword">if</span> (currentId !== counterId) &#123;</span><br><span class="line">        clearMediaAndAnimate();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      current.srcObject = stream;</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      message.error(<span class="string">`获取视频流失败！`</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(e);</span><br><span class="line">      clearMediaAndAnimate();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中通过 <code>counterId</code> 保留当前最新流，异步丢弃之前旧流。</p><h3 id="electron-builder-json"><a href="#electron-builder-json" class="headerlink" title="electron-builder.json"></a>electron-builder.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;productName&quot;</span>: <span class="string">&quot;electron客户端&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;appId&quot;</span>: <span class="string">&quot;cn.electron.korey&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;copyright&quot;</span>: <span class="string">&quot;Copyright © 2021 korey&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;asar&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;compression&quot;</span>: <span class="string">&quot;maximum&quot;</span>, <span class="comment">//若用 store，则打包速度加快，但打包体积变大</span></span><br><span class="line">  <span class="attr">&quot;nsis&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;oneClick&quot;</span>: <span class="literal">false</span>, <span class="comment">//取消一键安装</span></span><br><span class="line">    <span class="attr">&quot;allowElevation&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;allowToChangeInstallationDirectory&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;installerIcon&quot;</span>: <span class="string">&quot;./resources/icons/icon.ico&quot;</span>, <span class="comment">// 256*256</span></span><br><span class="line">    <span class="attr">&quot;uninstallerIcon&quot;</span>: <span class="string">&quot;./resources/icons/icon.ico&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;installerHeaderIcon&quot;</span>: <span class="string">&quot;./resources/icons/icon.ico&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;createDesktopShortcut&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;createStartMenuShortcut&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;shortcutName&quot;</span>: <span class="string">&quot;electron客户端&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;files&quot;</span>: [<span class="string">&quot;dist/&quot;</span>, <span class="string">&quot;node_modules/&quot;</span>, <span class="string">&quot;app.html&quot;</span>, <span class="string">&quot;main.prod.js&quot;</span>, <span class="string">&quot;main.prod.js.map&quot;</span>, <span class="string">&quot;package.json&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;dmg&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;contents&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;x&quot;</span>: <span class="number">130</span>,</span><br><span class="line">        <span class="attr">&quot;y&quot;</span>: <span class="number">220</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;x&quot;</span>: <span class="number">410</span>,</span><br><span class="line">        <span class="attr">&quot;y&quot;</span>: <span class="number">220</span>,</span><br><span class="line">        <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;link&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/Applications&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;win&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;extraFiles&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;from&quot;</span>: <span class="string">&quot;node_modules/trtc-electron-sdk/build/Release&quot;</span>, <span class="comment">//将 .node 文件复制过去，没有这个程序将报错</span></span><br><span class="line">        <span class="attr">&quot;to&quot;</span>: <span class="string">&quot;.&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;nsis&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;arch&quot;</span>: <span class="string">&quot;x64&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;icon&quot;</span>: <span class="string">&quot;./resources/icons/icon.ico&quot;</span> <span class="comment">//256*256 ico格式，未配 icon 则 win 打包报错</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;mac&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;zhibojiaoyu.app&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;extraFiles&quot;</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;from&quot;</span>: <span class="string">&quot;node_modules/trtc-electron-sdk/build/Release&quot;</span>, <span class="comment">//同上</span></span><br><span class="line">        <span class="attr">&quot;to&quot;</span>: <span class="string">&quot;./Frameworks&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;linux&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: [<span class="string">&quot;deb&quot;</span>, <span class="string">&quot;rpm&quot;</span>, <span class="string">&quot;AppImage&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;category&quot;</span>: <span class="string">&quot;Development&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;directories&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;buildResources&quot;</span>: <span class="string">&quot;resources&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;output&quot;</span>: <span class="string">&quot;release&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;publish&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;provider&quot;</span>: <span class="string">&quot;generic&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;channel&quot;</span>: <span class="string">&quot;latest&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;http://cdn.flqin.com/electron客户端-1.0.0.dmg&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;private&quot;</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;electronDownload&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;mirror&quot;</span>: <span class="string">&quot;https://npm.taobao.org/mirrors/electron/&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="腾讯云相关"><a href="#腾讯云相关" class="headerlink" title="腾讯云相关"></a>腾讯云相关</h3><ul><li>直播群 <code>AVChatRoom</code>（需求大于 6000 人）不支持历史消息存储。<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kb2N1bWVudC9wcm9kdWN0LzI2OS8xNTAy">群组系统对比<i class="fa fa-external-link-alt"></i></span></li><li><code>startScreenCapture</code> 开启屏幕推流后，可通过 <code>setSubStreamMixVolume</code> 设置麦克风和屏幕里音源大小比例。<code>win</code> 上需异步调用 <code>startSystemAudioLoopback</code> 才能采集到屏幕里音源。其中默认摄像头为主流，屏幕为辅流。</li><li>若 <code>IM</code> 群组已存在，除直播群需要同时调 <code>joinGroup</code> 以外，其他类型再次 <code>createGroup</code> 会直接进入该群组。</li><li><code>trtc enterRoom roomId</code> 取值范围 <code>1～4294967295</code>。</li><li><code>trtc getScreenCaptureSources</code> 在 <code>mac os big sur</code> 版本返回的 <code>screenList.thumbBGRA</code> 里的 <code>width*height*4</code> 不等于 <code>buffer.length</code> 导致程序报错，等待腾讯云修复。</li><li>窗口置顶：<code>setAlwaysOnTop(true, &#39;pop-up-menu&#39;)</code>, 一定要有 <code>pop-up-menu</code> 参数，因为在 <code>win</code> 上无此参数时分享全屏屏幕时，拖动置顶窗口会意外置底。</li></ul><h4 id="sdk-node-支持"><a href="#sdk-node-支持" class="headerlink" title="sdk node 支持"></a>sdk node 支持</h4><p>在 <code>webpack</code> 需配置解析腾讯云 <code>sdk</code> <code>.node</code> 的 <code>rules</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;test&quot;</span>: /\.node$/,</span><br><span class="line">  <span class="attr">&quot;loader&quot;</span>: <span class="string">&quot;native-ext-loader&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;options&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;emit&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;rewritePath&quot;</span>: process.env.NODE_ENV === <span class="string">&quot;production&quot;</span> ? <span class="string">&quot;./&quot;</span> : <span class="string">&quot;node_modules/trtc-electron-sdk/build/Release/&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BrowserWindow</code> 配置里需加上 <code>webPreferences: &#123;nodeIntegration: true&#125;</code>。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>使用 <code>setBounds</code> 代替 <code>setSize</code>，因为 <code>setSize</code> 在 <code>win</code> 上多次调用会失效。</li><li>在 <code>CSS</code> 中指定 <code>-webkit-app-region: drag</code> 来告诉 <code>Electron</code> 哪些区域可拖拽。</li></ul>]]></content>
      
      
      <categories>
          
          <category> FE Summary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端性能优化大纲</title>
      <link href="410.html"/>
      <url>410.html</url>
      
        <content type="html"><![CDATA[<h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><p>FP (First Paint) 首次绘制<br>FCP (First Contentful Paint) 首次内容绘制<br>FMP（First Meaningful Paint）首次绘制页面主要内容<br>LCP (Largest Contentful Paint) 最大内容渲染<br>TTI (Time to Interactive) 可交互时间<br>DCL (DomContentloaded)<br>L（load)<br>performance.now()</p><h2 id="加载时优化"><a href="#加载时优化" class="headerlink" title="加载时优化"></a>加载时优化</h2><ul><li>网络：DNS 优化，减少 HTTP 请求，减少重定向，使用 HTTP2，CDN，Gzip，设置缓存(三级)，</li><li>加载：延迟（async），异步（defer），预加载（preload，prefetch），懒加载（IntersectionObserver），CSS 放头部，JS 放尾部，骨架屏，动态 Polyfill</li><li>图片：预加载，懒加载，iconfont，webp 嗅探</li><li>webpack：base64，压缩，Tree shaking，动态 Import，拆包 chunk，Dll<a href="https://blog.flqin.com/385.html">1</a></li><li>服务端渲染（SSR），客户端预渲染（Prerendering）</li><li>数据预取，包括接口数据，和加载详情页图片</li></ul><h2 id="运行时优化"><a href="#运行时优化" class="headerlink" title="运行时优化"></a>运行时优化</h2><ul><li>减少回流重绘<a href="https://blog.flqin.com/336.html">2</a></li><li>变量保存属性，使用事件委托，节流，防抖</li><li>减少组件层级，首页不加载不可视组件</li><li>Web Workers</li><li>合并接口请求</li><li>避免页面卡顿 (16ms 内完成操作并渲染）requestAnimationFrame，requestIdleCallback，IntersectionObserver，MutationObserver，ResizeObserver，PostMessage。</li></ul>]]></content>
      
      
      <categories>
          
          <category> FE Summary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 patch-package 给 node_modules 打补丁</title>
      <link href="409.html"/>
      <url>409.html</url>
      
        <content type="html"><![CDATA[<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>安装 <code>patch-package</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add patch-package -D</span><br></pre></td></tr></table></figure><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>修改 <code>npm</code> 包的代码后(如修改 <code>webpack</code>)，执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx patch-package webpack --use-yarn</span><br></pre></td></tr></table></figure><p><code>npm</code> 会在项目根目录下的 <code>patches</code> 目录中创建一个名为 <code>webpack+version.patch</code> 的文件，提交到 <code>git</code>。</p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p><code>package.json</code> 的 <code>scripts</code> 中加入 <code>&quot;postinstall&quot;: &quot;patch-package&quot;</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;postinstall&quot;: &quot;patch-package&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在后续运行 yarn 时，便会自动为依赖包打上我们编写的补丁了。</p>]]></content>
      
      
      <categories>
          
          <category> FE Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《Javascript 密码花园》 笔记</title>
      <link href="408.html"/>
      <url>408.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><span class="exturl" data-url="aHR0cHM6Ly9ib25zYWlkZW4uZ2l0aHViLmlvL0phdmFTY3JpcHQtR2FyZGVuL3poLw==">《Javascript 密码花园》<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>本笔记只记录本人易模糊的知识点，其他略过。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul><li><p><code>JavaScript</code> 中所有变量都可以当作对象使用，除了两个例外 <code>null</code> 和 <code>undefined</code>。</p></li><li><p>由于 <code>JavaScript</code> 解析器的一个错误，数字的字面值（literal）当作对象解析时报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>toString(); <span class="comment">// 出错：SyntaxError</span></span><br><span class="line"><span class="comment">// 变通写法</span></span><br><span class="line"><span class="number">2.</span>.toString(); <span class="comment">// 第二个点号可以正常解析</span></span><br><span class="line"><span class="number">2</span> .toString(); <span class="comment">// 注意点号前面的空格</span></span><br><span class="line">(<span class="number">2</span>).toString(); <span class="comment">// 2先被计算</span></span><br></pre></td></tr></table></figure></li><li><p>有两种方式来访问对象的属性，点操作符或者中括号操作符。中括号还适合动态属性等。</p></li><li><p>删除属性的唯一方法是使用 <code>delete</code> 操作符。</p></li><li><p>不要扩展内置类型的原型，除非是为了和新的 <code>JavaScript</code> 引擎兼容。</p></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><p>命名函数的赋值表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  bar(); <span class="comment">// 正常运行</span></span><br><span class="line">&#125;;</span><br><span class="line">bar(); <span class="comment">// 出错：ReferenceError</span></span><br></pre></td></tr></table></figure></li><li><p>不要使用 <code>arguments.callee</code> 和它的属性。</p></li><li><p>推荐使用匿名包装器（自执行的匿名函数）来创建命名空间。这样不仅可以防止命名冲突，而且有利于程序的模块化。</p></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li>为了更好的性能，推荐使用普通的 <code>for</code> 循环并缓存数组的 <code>length</code> 属性。</li></ul><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ul><li>强烈推荐使用严格等于操作符。如果类型需要转换，应该在比较之前显式的转换， 而不是使用语言本身复杂的强制转换规则。</li><li>为了检测一个对象的类型，强烈推荐使用 <code>Object.prototype.toString</code> 方法； 因为这是唯一一个可依赖的方式。</li><li><code>instanceof</code> 操作符应该仅仅用来比较来自同一个 <code>JavaScript</code> 上下文的自定义对象。</li></ul><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul><li>绝对不要使用 <code>eval</code>，任何使用它的代码都会在它的工作方式，性能和安全性方面受到质疑。 99.9% 使用 <code>eval</code> 的场景都有不使用 <code>eval</code> 的解决方案。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>绝对不要使用字符串作为 <code>setTimeout</code> 或者 <code>setInterval</code> 的第一个参数。</li><li>避免使用 <code>setInterval</code>，可以在回调函数内部使用 <code>setTimeout</code>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> FE Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端微信H5支付，支付宝内及第三方H5支付，各平台分享总结</title>
      <link href="407.html"/>
      <url>407.html</url>
      
        <content type="html"><![CDATA[<h2 id="微信支付"><a href="#微信支付" class="headerlink" title="微信支付"></a>微信支付</h2><h3 id="微信内-H5-支付（公众号支付）"><a href="#微信内-H5-支付（公众号支付）" class="headerlink" title="微信内 H5 支付（公众号支付）"></a>微信内 H5 支付（公众号支付）</h3><p>走统一引入 <code>JSSDK</code> 的新方式实现支付逻辑。</p><ul><li><code>JSSDK</code> 文档 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29mZmlhY2NvdW50L09BX1dlYl9BcHBzL0pTLVNESy5odG1s">地址<i class="fa fa-external-link-alt"></i></span></li><li>网页授权(获取 <code>access_token</code> 和 <code>openid</code>) 文档 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29mZmlhY2NvdW50L09BX1dlYl9BcHBzL1dlY2hhdF93ZWJwYWdlX2F1dGhvcml6YXRpb24uaHRtbA==">地址<i class="fa fa-external-link-alt"></i></span></li><li>统一下单 文档 <span class="exturl" data-url="aHR0cHM6Ly9wYXkud2VpeGluLnFxLmNvbS93aWtpL2RvYy9hcGkvanNhcGkucGhwP2NoYXB0ZXI9OV8x">地址<i class="fa fa-external-link-alt"></i></span></li><li>微信内 <code>H5</code> 调起支付 文档 <span class="exturl" data-url="aHR0cHM6Ly9wYXkud2VpeGluLnFxLmNvbS93aWtpL2RvYy9hcGkvanNhcGkucGhwP2NoYXB0ZXI9N183JmluZGV4PTY=">地址<i class="fa fa-external-link-alt"></i></span></li></ul><h4 id="明确两种-access-token"><a href="#明确两种-access-token" class="headerlink" title="明确两种 access_token"></a>明确两种 access_token</h4><ul><li>网页授权 <code>access_token</code>：基于 <code>Oauth 2.0</code>，需要 <code>code</code> 换取，用于维持登录状态。</li><li>普通 <code>access_token</code>：后台可直接生成，换取 <code>jsapi_ticket</code> 进而加密生成 <code>signature</code> 作为 <code>wx.config</code> 参数。</li></ul><h4 id="整个流程"><a href="#整个流程" class="headerlink" title="整个流程"></a>整个流程</h4><p>支付统一下单接口需要 <code>openid</code>，所以必须要授权获取。因为此处只需要 <code>openid</code>，所以 <code>snsapi_base</code> 为 <code>scope</code> 走静默授权。(为了方便起见，此处每次进入都获取 <code>code</code> 走静默授权。)</p><ol><li><p>进入页面判断链接上是否有 <code>code</code>，没有则请求接口得到 <code>url</code> 并重定向：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  url: <span class="string">&#x27;https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx1232123123&amp;redirect_uri=带参数(包括锚点)的编码后的重定向的回调地址&amp;response_type=code&amp;scope=snsapi_base&amp;connect_redirect=1&amp;state=xxxx#wechat_redirect&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// connect_redirect=1 表示只只触发一次请求</span></span><br></pre></td></tr></table></figure></li><li><p>微信内部多次重定向之后，最后带上 <code>code</code> 和 <code>state</code> 301 重定向回设置的回调地址：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">301: https://www.flqin.com/test.html?id=135price=1322&amp;code=ASDJIAJD13D823D&amp;state=13212313#/</span><br></pre></td></tr></table></figure></li><li><p>前端判断到链接有 <code>code</code>，将 <code>code</code> 及一些其他页面需要的参数一起传给后端，后端拿到 <code>code</code> 换取网页授权 <code>access_token</code> 和 <code>openid</code>，此处后端可将 <code>access_token/refresh_token</code> 存入 <code>cookie</code> 或者通过其他方式 <code>jwt</code> 维持登录状态，就无需重复获取 <code>code</code>。</p></li><li><p><code>openid</code> 为统一下单 <code>jsapi</code> 接口必传参数，用于得到 <code>prepay_id</code> 参数值，即为 <code>package</code> 参数。最后接口统一返回 <code>wx.confg</code> 和 <code>wx.chooseWXPay</code> 所需参数，前端调用 <code>JSSDK</code> 即可。</p></li><li><p><code>wx.chooseWXPay</code> 的成功、完成回调仅代表支付完成，</p></li></ol><p>代码演示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">queryWxCode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> (!code) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> api.wxToPay(&#123;<span class="attr">url</span>:<span class="string">&#x27;当前页面完整链接&#x27;</span>&#125;).catch(<span class="function">(<span class="params">e</span>) =&gt;</span> e); <span class="comment">//获取重定向链接（微信授权地址）</span></span><br><span class="line">    data &amp;&amp; (<span class="built_in">window</span>.location.href = data);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> api.wxPay(&#123;code,<span class="attr">url</span>:<span class="string">&#x27;当前页面包含参数的url&#x27;</span>&#125;);  <span class="comment">//获得wx.config、wx.choosepay全部参数</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">registerWx</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> <span class="built_in">this</span>.queryWxCode().catch(<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line">  <span class="built_in">this</span>.wxSdkInfo = data;</span><br><span class="line">  wx.config(&#123;</span><br><span class="line">    debug: <span class="literal">false</span>, <span class="comment">// 开启调试模式</span></span><br><span class="line">    appId: data.appId, <span class="comment">// 必填，公众号的唯一标识</span></span><br><span class="line">    timestamp: data.timeStamp, <span class="comment">// 必填，生成签名的时间戳</span></span><br><span class="line">    nonceStr: data.nonceStr, <span class="comment">// 必填，生成签名的随机串</span></span><br><span class="line">    signature: data.signature, <span class="comment">// 必填，签名 通过普通access_token生成，无需授权</span></span><br><span class="line">    jsApiList: [<span class="string">&#x27;chooseWXPay&#x27;</span>, <span class="string">&#x27;hideMenuItems&#x27;</span>] <span class="comment">// 必填，需要使用的JS接口列表</span></span><br><span class="line">  &#125;);</span><br><span class="line">  wx.ready(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.hideWxMenus();</span><br><span class="line">    <span class="built_in">this</span>.createWxpay();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">hideWxMenus</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 禁用支付分享, 防止订单未生成而进入该页面导致的报错</span></span><br><span class="line">  <span class="keyword">const</span> menuList = [<span class="string">&#x27;menuItem:share:appMessage&#x27;</span>, <span class="string">&#x27;menuItem:share:timeline&#x27;</span>, <span class="string">&#x27;menuItem:copyUrl&#x27;</span>];</span><br><span class="line">  wx.hideMenuItems(&#123;</span><br><span class="line">    menuList <span class="comment">// 要隐藏的菜单项，只能隐藏“传播类”和“保护类”按钮，所有menu项见附录3</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">createWxpay</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="built_in">this</span>.wxSdkInfo;</span><br><span class="line">  wx.chooseWXPay(&#123;</span><br><span class="line">    timestamp: data.timeStamp, <span class="comment">// 支付签名时间戳，注意微信jssdk中的所有使用timestamp字段均为小写。但最新版的支付后台生成签名使用的timeStamp字段名需大写其中的S字符</span></span><br><span class="line">    nonceStr: data.nonceStr, <span class="comment">// 支付签名随机串，不长于 32 位</span></span><br><span class="line">    package: <span class="string">`prepay_id=<span class="subst">$&#123;data.prepayId&#125;</span>`</span>, <span class="comment">// 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=\*\*\*） 该参数需要openid</span></span><br><span class="line">    signType: data.signType, <span class="comment">// 签名方式，默认为&#x27;SHA1&#x27;，使用新版支付需传入&#x27;MD5&#x27;</span></span><br><span class="line">    paySign: data.paySign, <span class="comment">// 支付签名 参与签名的参数为：appId、timeStamp、nonceStr、package、signType</span></span><br><span class="line">    success: <span class="built_in">this</span>.queryPayment, <span class="comment">//公共查询结果接口</span></span><br><span class="line">    fail: <span class="built_in">this</span>.showFail, <span class="comment">//失败处理</span></span><br><span class="line">    cancel: <span class="built_in">this</span>.showRefail, <span class="comment">//取消处理</span></span><br><span class="line">    <span class="function"><span class="title">complete</span>(<span class="params">&#123; errMsg &#125;</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> SUCCESS = <span class="regexp">/:ok/gi</span>.test(errMsg);</span><br><span class="line">      <span class="keyword">const</span> CANCEL = <span class="regexp">/:cancel/gi</span>.test(errMsg);</span><br><span class="line">      <span class="keyword">if</span> (SUCCESS) <span class="built_in">this</span>.queryPayment();</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (CANCEL) <span class="built_in">this</span>.showRefail();</span><br><span class="line">      <span class="keyword">else</span> <span class="built_in">this</span>.showFail();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="支付宝支付"><a href="#支付宝支付" class="headerlink" title="支付宝支付"></a>支付宝支付</h2><h3 id="支付宝内-H5-支付"><a href="#支付宝内-H5-支付" class="headerlink" title="支付宝内 H5 支付"></a>支付宝内 H5 支付</h3><p>必须接入支付宝 <code>JSAPI</code>。</p><ul><li><code>H5</code> 开发文档 <span class="exturl" data-url="aHR0cHM6Ly9teWpzYXBpLmFsaXBheS5jb20vanNhcGkvaW5kZXguaHRtbA==">地址<i class="fa fa-external-link-alt"></i></span></li><li><code>Alipay JSSDK</code> <span class="exturl" data-url="aHR0cHM6Ly9teWpzYXBpLmFsaXBheS5jb20vYWxpcGF5anNhcGkv">地址<i class="fa fa-external-link-alt"></i></span></li><li>支付文档 <span class="exturl" data-url="aHR0cHM6Ly9teWpzYXBpLmFsaXBheS5jb20vanNhcGkvbmF0aXZlL3RyYWRlLXBheS5odG1s">地址<i class="fa fa-external-link-alt"></i></span></li></ul><p>注意点：</p><ul><li>不涉及读取用户优惠券之类的都走普通无单号支付，即无需授权。</li><li>授权过程与微信大致一致。</li></ul><p>代码演示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">registerAlipay</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> alipayInit = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">this</span>.queryAliOrder().catch(<span class="function">(<span class="params">e</span>) =&gt;</span> e);</span><br><span class="line">    <span class="built_in">this</span>.createAlipay();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.AlipayJSBridge) alipayInit();</span><br><span class="line">  <span class="keyword">else</span> <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;AlipayJSBridgeReady&#x27;</span>, alipayInit, <span class="literal">false</span>);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">queryAliOrder</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 无单号支付</span></span><br><span class="line">  <span class="keyword">const</span> &#123;<span class="attr">data</span>: orderStr &#125; = <span class="keyword">await</span> api.aliPayH5(&#123;<span class="attr">orderId</span>:<span class="number">1</span>&#125;).catch(<span class="function">(<span class="params">e</span>) =&gt;</span> e);<span class="comment">//请求接口获取 orderStr</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">queryAliCode</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 有单号支付tradeNo(后台开通当面付)，同微信授权流程</span></span><br><span class="line">  <span class="keyword">const</span> &#123; href, search &#125; = <span class="built_in">window</span>.location;</span><br><span class="line">  <span class="keyword">const</span> query = search &amp;&amp; search.replace(<span class="regexp">/[?\/]/g</span>, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">auth_code</span>: code &#125; = qs.parse(query);</span><br><span class="line">  <span class="keyword">if</span> (!code) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> api.aliToPay(href).catch(<span class="function">(<span class="params">e</span>) =&gt;</span> e); <span class="comment">//请求接口获取支付宝授权地址</span></span><br><span class="line">    data &amp;&amp; (<span class="built_in">window</span>.location.href = data);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123;<span class="attr">data</span>: tradeNO &#125;  = <span class="keyword">await</span> api.aliPayH5(&#123;<span class="attr">orderId</span>:<span class="number">1</span>,code&#125;).catch(<span class="function">(<span class="params">e</span>) =&gt;</span> e); <span class="comment">//请求接口获取 tradeNO</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">createAlipay</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  AlipayJSBridge.call(<span class="string">&#x27;tradePay&#x27;</span>, &#123; <span class="string">&#x27;orderStr/tradeNO&#x27;</span> &#125;, <span class="function">(<span class="params">&#123; resultCode &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> SUCCESS_CODES = [<span class="string">&#x27;9000&#x27;</span>, <span class="string">&#x27;8000&#x27;</span>, <span class="string">&#x27;6004&#x27;</span>];</span><br><span class="line">    <span class="keyword">const</span> UNKNOW_CODES = [<span class="string">&#x27;7001&#x27;</span>, <span class="string">&#x27;6001&#x27;</span>, <span class="string">&#x27;6002&#x27;</span>];</span><br><span class="line">    <span class="keyword">if</span> (~SUCCESS_CODES.indexOf(resultCode)) _this.queryPayment(); <span class="comment">//支付查询</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (~UNKNOW_CODES.indexOf(resultCode)) _this.showRefail();</span><br><span class="line">    <span class="keyword">else</span> _this.showFail();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="第三方浏览器中-支付宝支付"><a href="#第三方浏览器中-支付宝支付" class="headerlink" title="第三方浏览器中 支付宝支付"></a>第三方浏览器中 支付宝支付</h3><ul><li>支付文档 <span class="exturl" data-url="aHR0cHM6Ly9vcGVuZG9jcy5hbGlwYXkuY29tL29wZW4vMjAzLzEwNTI4NQ==">地址<i class="fa fa-external-link-alt"></i></span></li><li>参数说明 <span class="exturl" data-url="aHR0cHM6Ly9vcGVuZG9jcy5hbGlwYXkuY29tL29wZW4vMjAzLzEwNzA5MA==">地址<i class="fa fa-external-link-alt"></i></span></li></ul><p>无需授权，直接将 <code>url</code> 和订单号传给后端，后端返回一个 <code>form</code> 表单添加到页面即可唤起支付宝 <code>APP</code>，支付完成后，根据后端配置支付宝会自动回跳到支付结果页并携带一堆参数。此时需要查询公共结果接口来确定支付是否成功。</p><p>注意点：</p><ul><li>通过链接上是否有参数 <code>alipay.trade.wap.pay.return</code> 来判断是否是支付回调回来的页面。</li></ul><p>代码演示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">registerH5</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; origin, pathname, search &#125; = <span class="built_in">window</span>.location;</span><br><span class="line">  <span class="keyword">const</span> &#123; method &#125; = qs.parse(search.replace(<span class="regexp">/[?\/]/g</span>, <span class="string">&#x27;&#x27;</span>));</span><br><span class="line">  <span class="keyword">if</span> (method === <span class="string">&#x27;alipay.trade.wap.pay.return&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.queryPayment(); <span class="comment">//执行公共查询结果接口</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">data</span>: form &#125; = <span class="keyword">await</span> api.aliPayH5(orderId,url).catch(<span class="function">(<span class="params">e</span>) =&gt;</span> e); <span class="comment">//请求接口返回form表单</span></span><br><span class="line">  <span class="keyword">if</span> (!form) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  div.innerHTML = form;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">  <span class="built_in">document</span>.forms[<span class="number">0</span>].submit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公共查询结果-queryPayment"><a href="#公共查询结果-queryPayment" class="headerlink" title="公共查询结果 queryPayment"></a>公共查询结果 queryPayment</h3><p>需要轮询支付结果。</p><p>代码演示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">queryPayment</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> TIMES_REACH = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> TIMES_MAX = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">const</span> SUCCESS_CODE = <span class="string">&#x27;1&#x27;</span>; <span class="comment">// 0待支付,需要继续查询 1支付成功  -1异常</span></span><br><span class="line">  <span class="keyword">const</span> WAITING_CODE = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.qTimes === TIMES_REACH) &#123; <span class="comment">//qTimes为最大查询次数</span></span><br><span class="line">    <span class="built_in">this</span>.qTimes = TIMES_MAX;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> api.payStatus(orderId).catch(<span class="function">(<span class="params">e</span>) =&gt;</span> e); <span class="comment">// 查询支付结果</span></span><br><span class="line">  <span class="keyword">if</span> (data == SUCCESS_CODE) &#123; <span class="comment">//成功状态</span></span><br><span class="line">    <span class="built_in">this</span>.showSuccess();</span><br><span class="line">    <span class="built_in">this</span>.qTimes = TIMES_MAX;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data == WAITING_CODE) &#123; <span class="comment">//等待状态</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;查询支付结果中...&#x27;</span>);</span><br><span class="line">    <span class="built_in">clearTimeout</span>(<span class="built_in">this</span>.timer);</span><br><span class="line">    <span class="built_in">this</span>.timer = <span class="built_in">setTimeout</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">await</span> <span class="built_in">this</span>.queryPayment(); <span class="comment">//递归轮询</span></span><br><span class="line">      <span class="built_in">this</span>.qTimes -= <span class="number">1</span>;</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.showFail();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="支付总结"><a href="#支付总结" class="headerlink" title="支付总结"></a>支付总结</h3><ul><li>微信支付宝均需要配置合法域名，可精确到文件夹路径。</li><li>开发可用微信开发工具，结合 alert 调试，直接把代码发到已配置好域名的测试环境测试最佳。</li><li>注意参数的大小写及传递的内容，支付主要复杂度都集中在后端，前端需要配合后端传参。</li></ul><h2 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h2><h3 id="微信-gt-微信（微信联系人，微信朋友圈，QQ-联系人，QQ-空间）"><a href="#微信-gt-微信（微信联系人，微信朋友圈，QQ-联系人，QQ-空间）" class="headerlink" title="微信- &gt; 微信（微信联系人，微信朋友圈，QQ 联系人，QQ 空间）"></a>微信- &gt; 微信（微信联系人，微信朋友圈，QQ 联系人，QQ 空间）</h3><p>必须引入 <code>JSSDK</code>，否则分享出来无法设置分享描述及分享图片。</p><ul><li><code>JSSDK</code> 文档：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29mZmlhY2NvdW50L09BX1dlYl9BcHBzL0pTLVNESy5odG1s">地址<i class="fa fa-external-link-alt"></i></span></li><li>获取普通 <code>access_token</code> 文档：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXJzLndlaXhpbi5xcS5jb20vZG9jL29mZmlhY2NvdW50L0Jhc2ljX0luZm9ybWF0aW9uL0dldF9hY2Nlc3NfdG9rZW4uaHRtbA==">地址<i class="fa fa-external-link-alt"></i></span></li></ul><p>需要给后端传入带有参数的当前页面 <code>url</code>（无需编码），让后端返回 <code>wx.config</code> 所需参数即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; data &#125; = <span class="keyword">await</span> api.getWxConfig(&#123; <span class="attr">url</span>: <span class="string">&#x27;当前页面包含参数的url&#x27;</span> &#125;); <span class="comment">//接口返回 appId，timeStamp，nonceStr，signature.</span></span><br><span class="line">wx.config(&#123;</span><br><span class="line">  debug: <span class="literal">true</span>,</span><br><span class="line">  appId: data.appId, <span class="comment">// 必填，公众号的唯一标识</span></span><br><span class="line">  timestamp: data.timeStamp, <span class="comment">// 必填，生成签名的时间戳</span></span><br><span class="line">  nonceStr: data.nonceStr, <span class="comment">// 必填，生成签名的随机串</span></span><br><span class="line">  signature: data.signature, <span class="comment">// 必填，签名</span></span><br><span class="line">  jsApiList: [<span class="string">&#x27;onMenuShareTimeline&#x27;</span>, <span class="string">&#x27;onMenuShareAppMessage&#x27;</span>, <span class="string">&#x27;onMenuShareQQ&#x27;</span>, <span class="string">&#x27;onMenuShareQZone&#x27;</span>], <span class="comment">// 必填，需要使用的JS接口列表</span></span><br><span class="line">&#125;);</span><br><span class="line">wx.ready(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> shareList = [<span class="string">&#x27;onMenuShareTimeline&#x27;</span>, <span class="string">&#x27;onMenuShareAppMessage&#x27;</span>, <span class="string">&#x27;onMenuShareQQ&#x27;</span>, <span class="string">&#x27;onMenuShareQZone&#x27;</span>];</span><br><span class="line">  shareList.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    wx[item](&#123;</span><br><span class="line">      title: <span class="built_in">this</span>.shareInfo.title, <span class="comment">// 分享标题</span></span><br><span class="line">      desc: <span class="built_in">this</span>.shareInfo.description, <span class="comment">// 分享描述</span></span><br><span class="line">      link: <span class="built_in">window</span>.location.href,</span><br><span class="line">      imgUrl: <span class="built_in">this</span>.shareInfo.image, <span class="comment">// 分享图标</span></span><br><span class="line">      success: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 设置成功</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>首先需要在微信后台设置接口安全域名：<code>www.xxxx.com</code>，无需到具体路径及参数。</li><li>前端仅需传给后台当前页面带参数的 <code>url</code> 即可，甚至接口可以自己取请求页面带参数的 <code>url</code>，前端无需传。</li><li>注意 <code>timeStamp</code> 的大小写。</li><li>注意 <code>jsApiList</code> 选择即将废弃的分享接口，新分享接口反而不好用。</li><li>分享无需授权，因：参数 <code>nonceStr &lt;- jsapi_ticket &lt;- access_token &lt;- appid,secret</code>。此 <code>access_token</code> 为普通 <code>access_token</code>，<code>appid</code> 和 <code>secret</code> 均在微信后台获取。区别于支付等网页授权 <code>access_token</code>。</li></ul><h3 id="QQ-TIM-gt-QQ（QQ-联系人，QQ-空间，微信联系人，微信朋友圈）"><a href="#QQ-TIM-gt-QQ（QQ-联系人，QQ-空间，微信联系人，微信朋友圈）" class="headerlink" title="QQ(TIM) -&gt; QQ（QQ 联系人，QQ 空间，微信联系人，微信朋友圈）"></a>QQ(TIM) -&gt; QQ（QQ 联系人，QQ 空间，微信联系人，微信朋友圈）</h3><p>需要引入 <code>api</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//open.mobile.qq.com/sdk/qqapi.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>js</code> 执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> share = &#123;</span><br><span class="line">  title: <span class="string">&#x27;分享标题，最大45字节&#x27;</span>,</span><br><span class="line">  desc: <span class="string">&#x27;分享内容，最大60字节&#x27;</span>,</span><br><span class="line">  image_url: <span class="string">&#x27;图片URL，最小需要200 * 200&#x27;</span>,</span><br><span class="line">  share_url: <span class="string">&#x27;分享链接与页面URL同&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">mqq.data.setShareInfo(share, callback);</span><br></pre></td></tr></table></figure><p>另 <code>mqq.ui.showShareMenu();</code> 可直接唤起 <code>QQ</code> 分享面板。</p><h3 id="支付宝-gt-支付宝（朋友动态，联系人）"><a href="#支付宝-gt-支付宝（朋友动态，联系人）" class="headerlink" title="支付宝 -&gt; 支付宝（朋友动态，联系人）"></a>支付宝 -&gt; 支付宝（朋友动态，联系人）</h3><p>直接按如下设置 <code>meta</code> 即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Alipay:title&quot;</span> <span class="attr">content</span>=<span class="string">&quot;分享标题&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Alipay:imgUrl&quot;</span> <span class="attr">content</span>=<span class="string">&quot;分享图片url&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Alipay:desc&quot;</span> <span class="attr">content</span>=<span class="string">&quot;分享描述&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Alipay:link&quot;</span> <span class="attr">content</span>=<span class="string">&quot;分享链接&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="微博，头条，知乎等其他平台浏览器-gt-微信，QQ"><a href="#微博，头条，知乎等其他平台浏览器-gt-微信，QQ" class="headerlink" title="微博，头条，知乎等其他平台浏览器 -&gt; 微信，QQ"></a>微博，头条，知乎等其他平台浏览器 -&gt; 微信，QQ</h3><blockquote><p>微博可注册轻应用使用 JS-SDK 完成分享设置。收益不大就没做了。<br>知乎实测 IOS 可以取写死的描述及动态标题，图片无法设置，安卓只能设置标题。</p></blockquote><p>对于其他平台分享，统一兜底处理方式：</p><p>分享标题及描述设置 <code>head</code> 元素：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>分享标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;分享描述&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>分享图及描述设置(一般默认取页面第一张大于 <code>300px</code> 图及第一段描述)：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>分享描述<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片地址url&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 <code>ogp</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta property=<span class="string">&quot;og:type&quot;</span> content=<span class="string">&quot;website&quot;</span>&gt;</span><br><span class="line">    &lt;meta property=<span class="string">&quot;og:title&quot;</span> content=<span class="string">&quot;分享标题&quot;</span>&gt;</span><br><span class="line">    &lt;meta property=<span class="string">&quot;og:description&quot;</span> content=<span class="string">&quot;分享描述&quot;</span>&gt;</span><br><span class="line">    &lt;meta property=<span class="string">&quot;og:img&quot;</span> content=<span class="string">&quot;完整的分享图片链接&quot;</span>&gt;</span><br><span class="line">    &lt;meta property=<span class="string">&quot;og:url&quot;</span> content=<span class="string">&quot;完整的分享页面地址&quot;</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FE Summary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）JavaScript设计模式</title>
      <link href="406.html"/>
      <url>406.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接：<code>https://juejin.im/post/5e021eb96fb9a01628014095</code></p></blockquote><h2 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h2><p>设计模式代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。<br>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。</p><h2 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h2><ul><li><p>S – Single Responsibility Principle 单一职责原则</p><ul><li>一个程序只做好一件事</li><li>如果功能过于复杂就拆分开，每个部分保持独立</li></ul></li><li><p>O – OpenClosed Principle 开放/封闭原则</p><ul><li>对扩展开放，对修改封闭</li><li>增加需求时，扩展新代码，而非修改已有代码</li></ul></li><li><p>L – Liskov Substitution Principle 里氏替换原则</p><ul><li>子类能覆盖父类</li><li>父类能出现的地方子类就能出现</li></ul></li><li><p>I – Interface Segregation Principle 接口隔离原则</p><ul><li>保持接口的单一独立</li><li>类似单一职责原则，这里更关注接口</li></ul></li><li><p>D – Dependency Inversion Principle 依赖倒转原则</p><ul><li>面向接口编程，依赖于抽象而不依赖于具体</li><li>使用方只关注接口而不关注具体类的实现</li></ul></li></ul><p><strong>SO</strong> 体现较多，举个栗子：（比如 Promise）</p><ul><li>单一职责原则：每个 then 中的逻辑只做好一件事</li><li>开放封闭原则（对扩展开放，对修改封闭）：如果新增需求，扩展 then</li></ul><p>再举个栗子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//checkType(&#x27;165226226326&#x27;,&#x27;mobile&#x27;)</span></span><br><span class="line"><span class="comment">//result：false</span></span><br><span class="line"><span class="keyword">let</span> checkType = <span class="function"><span class="keyword">function</span> (<span class="params">str, type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;email&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/</span>.test(str);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;mobile&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/^1[3|4|5|7|8][0-9]&#123;9&#125;$/</span>.test(str);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;tel&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;)(-\d&#123;1,4&#125;)?$/</span>.test(str);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有以下两个问题：</p><ul><li>如果想添加其他规则就得在函数里面增加 case 。添加一个规则就修改一次！这样违反了开放-封闭原则（对扩展开放，对修改关闭）。而且这样也会导致整个 API 变得臃肿，难维护。</li><li>比如 A 页面需要添加一个金额的校验，B 页面需要一个日期的校验，但是金额的校验只在 A 页面需要，日期的校验只在 B 页面需要。如果一直添加 case 。就是导致 A 页面把只在 B 页面需要的校验规则也添加进去，造成不必要的开销。B 页面也同理。</li></ul><p>建议的方式是给这个 API 增加一个扩展的接口:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> checkType = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rules = &#123;</span><br><span class="line">    <span class="function"><span class="title">email</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/</span>.test(str);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">mobile</span>(<span class="params">str</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="regexp">/^1[3|4|5|7|8][0-9]&#123;9&#125;$/</span>.test(str);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">//暴露接口</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">//校验</span></span><br><span class="line">    <span class="function"><span class="title">check</span>(<span class="params">str, type</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> rules[type] ? rules[type](str) : <span class="literal">false</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">//添加规则</span></span><br><span class="line">    <span class="function"><span class="title">addRule</span>(<span class="params">type, fn</span>)</span> &#123;</span><br><span class="line">      rules[type] = fn;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方式</span></span><br><span class="line"><span class="comment">//使用mobile校验规则</span></span><br><span class="line"><span class="built_in">console</span>.log(checkType.check(<span class="string">&#x27;188170239&#x27;</span>, <span class="string">&#x27;mobile&#x27;</span>));</span><br><span class="line"><span class="comment">//添加金额校验规则</span></span><br><span class="line">checkType.addRule(<span class="string">&#x27;money&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/^[0-9]+(.[0-9]&#123;2&#125;)?$/</span>.test(str);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//使用金额校验规则</span></span><br><span class="line"><span class="built_in">console</span>.log(checkType.check(<span class="string">&#x27;18.36&#x27;</span>, <span class="string">&#x27;money&#x27;</span>));</span><br></pre></td></tr></table></figure><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>一个类只有一个实例，并提供一个访问它的全局访问点，一般登录、购物车等都是一个单例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">login</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 访问方法</span></span><br><span class="line">SingleObject.getInstance = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> SingleObject();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">const</span> obj1 = SingleObject.getInstance();</span><br><span class="line"><span class="keyword">const</span> obj2 = SingleObject.getInstance();</span><br><span class="line"><span class="built_in">console</span>.log(obj1 === obj2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>优点<ul><li>划分命名空间，减少全局变量</li><li>增强模块性，把自己的代码组织在一个全局变量名下，放在单一位置，便于维护</li><li>且只会实例化一次。简化了代码的调试和维护</li></ul></li><li>缺点<ul><li>由于单例模式提供的是一种单点访问，所以它有可能导致模块间的强耦合，从而不利于单元测试。无法单独测试一个调用了来自单例的方法的类，而只能把它与那个单例作为一个单元一起测试。</li></ul></li><li>应用场景<ul><li>定义命名空间和实现分支型方法</li><li>登录框</li><li>vuex 和 redux 中的 store</li></ul></li></ul><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>原型模式（prototype）是指用原型实例指向创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello， My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> student = <span class="keyword">new</span> Student(<span class="string">&#x27;xiaoming&#x27;</span>);</span><br><span class="line">student.sayHello();</span><br></pre></td></tr></table></figure><p>原型模式，就是创建一个共享的原型，通过拷贝这个原型来创建新的类，用于创建重复的对象，带来性能上的提升。</p><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><p>工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;init&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">fun</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;fun&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">create</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Product(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// use</span></span><br><span class="line"><span class="keyword">let</span> factory = <span class="keyword">new</span> Factory();</span><br><span class="line"><span class="keyword">let</span> p = factory.create(<span class="string">&#x27;p1&#x27;</span>);</span><br><span class="line">p.init();</span><br><span class="line">p.fun();</span><br></pre></td></tr></table></figure><ul><li>优点<ul><li>创建对象的过程可能很复杂，但我们只需要关心创建结果。</li><li>构造函数和创建者分离, 符合“开闭原则”</li><li>一个调用者想创建一个对象，只要知道其名称就可以了。</li><li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li></ul></li><li>缺点<ul><li>添加新产品时，需要编写新的具体产品类,一定程度上增加了系统的复杂度</li><li>考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度</li></ul></li><li>适用场景<ul><li>如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择</li><li>将 new 操作简单封装，遇到 new 的时候就应该考虑是否用工厂模式；</li><li>需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性</li></ul></li><li>应用场景<ul><li>JQuery 中的 <code>$</code></li><li>Vue.component 异步组件</li><li>React.createElement</li></ul></li></ul><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>抽象工厂其实是实现子类继承父类的方法，只是一个方法。抽象工厂模式一般用在多人协作的超大型项目中，并且严格的要求项目以面向对象的思想进行完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂方法</span></span><br><span class="line"><span class="keyword">var</span> abstractFactory = <span class="function"><span class="keyword">function</span> (<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断抽象工厂中是否有该抽象类</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> abstractFactory[superType] === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 缓存类</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 继承父类属性和方法</span></span><br><span class="line">    F.prototype = <span class="keyword">new</span> abstractFactory[superType]();</span><br><span class="line">    <span class="comment">// 将子类constructor 指向子类</span></span><br><span class="line">    subType.constructor = subType;</span><br><span class="line">    <span class="comment">// 子类原型继承&#x27;父类&#x27;</span></span><br><span class="line">    subType.prototype = <span class="keyword">new</span> F();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不存在该抽象类抛出错误</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;未创建该抽象类&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小汽车抽象类</span></span><br><span class="line">abstractFactory.Car = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.type = <span class="string">&#x27;car&#x27;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">abstractFactory.Car.prototype = &#123;</span><br><span class="line">  getPrice1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;基类函数&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  getSpeed1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;基类函数&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建产品子类继承相应的产品簇抽象类</span></span><br><span class="line"><span class="comment">// 创建MyCar子类</span></span><br><span class="line"><span class="keyword">var</span> MyCar = <span class="function"><span class="keyword">function</span> (<span class="params">price, speed</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.price = price;</span><br><span class="line">  <span class="built_in">this</span>.speed = speed;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//抽象工厂实现对Car抽象类的继承</span></span><br><span class="line">abstractFactory(MyCar, <span class="string">&#x27;Car&#x27;</span>);</span><br><span class="line">MyCar.prototype.getPrice = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.price;</span><br><span class="line">&#125;;</span><br><span class="line">MyCar.prototype.getSpeed = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.speed;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bmw = <span class="keyword">new</span> MyCar(<span class="number">11000</span>, <span class="number">200</span>);</span><br><span class="line"><span class="keyword">var</span> speed = bmw.getSpeed();</span><br><span class="line"><span class="keyword">var</span> price = bmw.getPrice();</span><br><span class="line"><span class="keyword">var</span> speed1 = bmw.getSpeed1();</span><br><span class="line"><span class="keyword">var</span> price1 = bmw.getPrice1();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(speed);</span><br><span class="line"><span class="built_in">console</span>.log(price);</span><br><span class="line"><span class="built_in">console</span>.log(speed1);</span><br><span class="line"><span class="built_in">console</span>.log(price1);</span><br><span class="line"><span class="comment">//200</span></span><br><span class="line"><span class="comment">//11000</span></span><br><span class="line"><span class="comment">//基类函数</span></span><br><span class="line"><span class="comment">//基类函数</span></span><br></pre></td></tr></table></figure><h4 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h4><p>建造者模式(Builder pattern)，将一个复杂对象的构建层与其表示层相互分离，使得同样的构建过程（某一算法）可以采用不同的表示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Human = <span class="function"><span class="keyword">function</span> (<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.skill = param &amp;&amp; param.skill;</span><br><span class="line">  <span class="built_in">this</span>.hobby = param &amp;&amp; param.hobby;</span><br><span class="line">&#125;;</span><br><span class="line">Human.prototype = &#123;</span><br><span class="line">  getSkill: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.skill;</span><br><span class="line">  &#125;,</span><br><span class="line">  getHobby: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.hobby;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Named = <span class="function"><span class="keyword">function</span> (<span class="params">named</span>) </span>&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">named, that</span>) </span>&#123;</span><br><span class="line">    that.wholeName = named;</span><br><span class="line">    <span class="keyword">if</span> (named.includes(<span class="string">&#x27; &#x27;</span>)) &#123;</span><br><span class="line">      that.FirstName = named.slice(<span class="number">0</span>, named.indexOf(<span class="string">&#x27; &#x27;</span>));</span><br><span class="line">      that.SecondeName = named.slice(named.indexOf(<span class="string">&#x27; &#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(named, <span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Work = <span class="function"><span class="keyword">function</span> (<span class="params">work</span>) </span>&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">work, that</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (work) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;FE&#x27;</span>:</span><br><span class="line">        that.work = <span class="string">&#x27;工程师&#x27;</span>;</span><br><span class="line">        that.workDesc = <span class="string">&#x27;每天沉迷于编程&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;UI&#x27;</span>:</span><br><span class="line">        that.work = <span class="string">&#x27;设计师&#x27;</span>;</span><br><span class="line">        that.workDesc = <span class="string">&#x27;设计更像一种艺术&#x27;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        that.work = work;</span><br><span class="line">        that.workDesc = <span class="string">&#x27;对不起，我们不清楚您所选择职位的描述&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)(work, <span class="built_in">this</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Work.prototype.changeWork = <span class="function"><span class="keyword">function</span> (<span class="params">work</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.work = work;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">param, name, work</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 构造方法，不同模块使用不同创建过程</span></span><br><span class="line">  <span class="keyword">const</span> _person = <span class="keyword">new</span> Human(param);</span><br><span class="line">  _person.named = <span class="keyword">new</span> Named(name);</span><br><span class="line">  _person.work = <span class="keyword">new</span> Work(work);</span><br><span class="line">  <span class="keyword">return</span> _person;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xiaoming = <span class="keyword">new</span> Person(&#123; <span class="attr">skill</span>: <span class="string">&#x27;耍帅&#x27;</span>, <span class="attr">hobby</span>: <span class="string">&#x27;装逼&#x27;</span> &#125;, <span class="string">&#x27;xiao ming&#x27;</span>, <span class="string">&#x27;code&#x27;</span>);</span><br><span class="line">xiaoming.skill; <span class="comment">// 耍帅</span></span><br><span class="line">xiaoming.FirstName; <span class="comment">// xiao</span></span><br><span class="line">xiaoming.work; <span class="comment">// 工程师</span></span><br></pre></td></tr></table></figure><ul><li>优点<ul><li>分布创建一个复杂的对象。</li><li>解耦封装过程和具体创建的组件。</li><li>无需关心组件如何组装。</li></ul></li><li>注意点<ul><li>一定要一个稳定的算法进行支持。</li><li>加工工艺是暴露的。</li></ul></li></ul><h3 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h3><h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><ul><li>动态地给某个对象添加一些额外的职责，是一种实现继承的替代方案</li><li>在不改变原对象的基础上，通过对其进行包装扩展，使原有对象可以满足用户的更复杂需求，而不会影响从这个类中派生的其他对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cellphone</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">create</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;生成一个手机&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">cellphone</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cellphone = cellphone;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">create</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cellphone.create();</span><br><span class="line">    <span class="built_in">this</span>.createShell(cellphone);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">createShell</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;生成手机壳&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> cellphone = <span class="keyword">new</span> Cellphone();</span><br><span class="line">cellphone.create();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;------------&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> dec = <span class="keyword">new</span> Decorator(cellphone);</span><br><span class="line">dec.create();</span><br></pre></td></tr></table></figure><ul><li>优点<ul><li>装饰类和被装饰类都只关心自身的核心业务，实现了解耦。</li><li>方便动态的扩展功能，且提供了比继承更多的灵活性。</li></ul></li><li>缺点<ul><li>多层装饰比较复杂。</li><li>常常会引入许多小对象，看起来比较相似，实际功能大相径庭，从而使得我们的应用程序架构变得复杂起来</li></ul></li><li>场景例子<ul><li>比如现在有 4 种型号的自行车，我们为每种自行车都定义了一个单独的类。现在要给每种自行车都装上前灯、尾灯和铃铛这 3 种配件。如果使用继承的方式来给<br>每种自行车创建子类，则需要 4×3 = 12 个子类。但是如果把前灯、尾灯、铃铛这些对象动态组合到自行车上面，则只需要额外增加 3 个类</li><li>ES7 Decorator 阮一峰</li><li>core-decorators</li></ul></li></ul><h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>将一个类的接口转化为另外一个接口，以满足用户需求，使类之间接口不兼容问题通过适配器得以解决。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plug</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;iphone充电头&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.plug = <span class="keyword">new</span> Plug();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.plug.getName() + <span class="string">&#x27; 适配器Type-c充电头&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> target = <span class="keyword">new</span> Target();</span><br><span class="line">target.getName(); <span class="comment">// iphone充电头 适配器转Type-c充电头</span></span><br></pre></td></tr></table></figure><ul><li>优点<ul><li>可以让任何两个没有关联的类一起运行。</li><li>提高了类的复用。</li><li>适配对象，适配库，适配数据</li></ul></li><li>缺点<ul><li>额外对象的创建，非直接调用，存在一定的开销（且不像代理模式在某些功能点上可实现性能优化)</li><li>如果没必要使用适配器模式的话，可以考虑重构，如果使用的话，尽量把文档完善</li></ul></li><li>场景<ul><li>整合第三方 SDK</li><li>封装旧接口</li><li>vue 的 computed</li></ul></li><li>适配器与代理模式相似<ul><li>适配器模式： 提供一个不同的接口（如不同版本的插头）</li><li>代理模式： 提供一模一样的接口</li></ul></li></ul><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>为其他对象提供一种代理，便以控制对这个对象的访问，不能直接访问目标对象。JavaScript 开发中最常用的是虚拟代理和缓存代理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Flower</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 源对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jack</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.target = target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sendFlower</span>(<span class="params">target</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> flower = <span class="keyword">new</span> Flower();</span><br><span class="line">    <span class="built_in">this</span>.target.receiveFlower(flower);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rose</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">receiveFlower</span>(<span class="params">flower</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;收到花: &#x27;</span> + flower);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProxyObj</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.target = <span class="keyword">new</span> Rose();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">receiveFlower</span>(<span class="params">flower</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.sendFlower(flower);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sendFlower</span>(<span class="params">flower</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.target.receiveFlower(flower);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> proxyObj = <span class="keyword">new</span> ProxyObj();</span><br><span class="line"><span class="keyword">const</span> jack = <span class="keyword">new</span> Jack(proxyObj);</span><br><span class="line">jack.sendFlower(proxyObj); <span class="comment">// 收到花：[object Object]</span></span><br></pre></td></tr></table></figure><ul><li>优点<ul><li>代理模式能将代理对象与被调用对象分离，降低了系统的耦合度。代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用</li><li>代理对象可以扩展目标对象的功能；通过修改代理对象就可以了，符合开闭原则；</li></ul></li><li>缺点<ul><li>处理请求速度可能有差别，非直接访问存在开销</li></ul></li><li>不同点<ul><li>装饰者模式实现上和代理模式类似</li><li>装饰者模式： 扩展功能，原有功能不变且可直接使用</li><li>代理模式： 显示原有功能，但是经过限制之后的</li></ul></li><li>应用场景<ul><li>ES6 Proxy</li><li>Vuex 中对于 getters 访问</li><li>图片预加载</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图片预加载</span></span><br><span class="line"><span class="comment">// 创建一个本体对象</span></span><br><span class="line"><span class="keyword">var</span> myImage = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建标签</span></span><br><span class="line">  <span class="keyword">var</span> imgNode = <span class="built_in">document</span>.createElement(<span class="string">&#x27;img&#x27;</span>);</span><br><span class="line">  <span class="comment">// 添加到页面</span></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(imgNode);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 设置图片的src</span></span><br><span class="line">    setSrc: <span class="function"><span class="keyword">function</span> (<span class="params">src</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 更改src</span></span><br><span class="line">      imgNode.src = src;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建代理对象</span></span><br><span class="line"><span class="keyword">var</span> proxyImage = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个新的img标签</span></span><br><span class="line">  <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  <span class="comment">// img 加载完成事件</span></span><br><span class="line">  img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 myImage 替换src方法</span></span><br><span class="line">    myImage.setSrc(<span class="built_in">this</span>.src);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 代理设置地址</span></span><br><span class="line">    setSrc: <span class="function"><span class="keyword">function</span> (<span class="params">src</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 预加载 loading</span></span><br><span class="line">      myImage.setSrc(<span class="string">&#x27;file:// /C:/Users/svenzeng/Desktop/loading.gif&#x27;</span>);</span><br><span class="line">      <span class="comment">// 赋值正常图片地址</span></span><br><span class="line">      img.src = src;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">proxyImage.setSrc(<span class="string">&#x27;http:// image.qq.com/music/photo/k/000GGDys0yA0Nk.jpg&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果有一天我们不再需要预加载，那么就不再需要代理对象，可以选择直接请求本体。其中关键是代理对象和本体都对外提供了 setSrc 方法，在客户看来，代理对象和本体是一致的， 代理接手请求的过程对于用户来说是透明的，用户并不清楚代理和本体的区别这样做有两个好处：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用户可以放心地请求代理，他只关心是否能得到想要的结果。</span></span><br><span class="line"><span class="comment">//在任何使用本体的地方都可以替换成使用代理。</span></span><br></pre></td></tr></table></figure><h4 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h4><p>为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统接口的访问更容易，不符合单一职责原则和开放封闭原则。</p><ol><li><p>兼容浏览器事件绑定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addMyEvent = <span class="function"><span class="keyword">function</span> (<span class="params">el, ev, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (el.addEventListener) &#123;</span><br><span class="line">    el.addEventListener(ev, fn, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el.attachEvent) &#123;</span><br><span class="line">    el.attachEvent(<span class="string">&#x27;on&#x27;</span> + ev, fn);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    el[<span class="string">&#x27;on&#x27;</span> + ev] = fn;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>封装接口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myEvent = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  stop: <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    e.stopPropagation();</span><br><span class="line">    e.preventDefault();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><ul><li>优点<ul><li>减少系统相互依赖。</li><li>提高灵活性。</li><li>提高了安全性</li></ul></li><li>缺点<ul><li>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</li></ul></li><li>场景<ul><li>设计初期，应该要有意识地将不同的两个层分离，比如经典的三层结构，在数据访问层和业务逻辑层、业务逻辑层和表示层之间建立外观 Facade</li><li>在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观 Facade 可以提供一个简单的接口，减少他们之间的依赖。</li><li>在维护一个遗留的大型系统时，可能这个系统已经很难维护了，这时候使用外观 Facade 也是非常合适的，为系系统开发一个外观 Facade 类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和 Facade 对象交互，Facade 与遗留代码交互所有的复杂工作。</li></ul></li></ul><h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><p>桥接模式（Bridge）将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Speed</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 运动模块</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`运动起来 <span class="subst">$&#123;<span class="built_in">this</span>.x&#125;</span> + <span class="subst">$&#123;<span class="built_in">this</span>.y&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 着色模块</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">cl</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.color = cl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">draw</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`绘制颜色 <span class="subst">$&#123;<span class="built_in">this</span>.color&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Speak</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">wd</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.word = wd;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`说话 <span class="subst">$&#123;<span class="built_in">this</span>.word&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建球类，可以着色和运动</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y, cl</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.speed = <span class="keyword">new</span> Speed(x, y);</span><br><span class="line">    <span class="built_in">this</span>.color = <span class="keyword">new</span> Color(cl);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.speed.run();</span><br><span class="line">    <span class="built_in">this</span>.color.draw();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 人类，可以运动和说话</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y, wd</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.speed = <span class="keyword">new</span> Speed(x, y);</span><br><span class="line">    <span class="built_in">this</span>.speak = <span class="keyword">new</span> Speak(wd);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.speed.run();</span><br><span class="line">    <span class="built_in">this</span>.speak.say();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> man = <span class="keyword">new</span> Man(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&#x27;hehe?&#x27;</span>);</span><br><span class="line">man.init(); <span class="comment">// 运动起来 1 + 2      说话 hehe?</span></span><br></pre></td></tr></table></figure><ul><li>优点<ul><li>分离接口和实现部分，一个实现未必不变地绑定在一个接口上，抽象类（函数）的实现可以在运行时刻进行配置，一个对象甚至可以在运行时刻改变它的实现，同将抽象和实现也进行了充分的解耦，也有利于分层，从而产生更好的结构化系统。</li><li>提高可扩充性</li><li>对客户隐藏实现细节。</li></ul></li><li>缺点<ul><li>大量的类将导致开发成本的增加，同时在性能方面可能也会有所减少。</li></ul></li></ul><h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><ul><li>将对象组合成树形结构，以表示“整体-部分”的层次结构。</li><li>通过对象的多态表现，使得用户对单个对象和组合对象的使用具有一致性。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrainOrder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">create</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;创建火车票订单&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HotelOrder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">create</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;创建酒店订单&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TotalOrder</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.orderList = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addOrder</span>(<span class="params">order</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.orderList.push(order);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">create</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.orderList.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      item.create();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以在购票网站买车票同时也订房间</span></span><br><span class="line"><span class="keyword">let</span> train = <span class="keyword">new</span> TrainOrder();</span><br><span class="line"><span class="keyword">let</span> hotel = <span class="keyword">new</span> HotelOrder();</span><br><span class="line"><span class="keyword">let</span> total = <span class="keyword">new</span> TotalOrder();</span><br><span class="line">total.addOrder(train).addOrder(hotel).create();</span><br></pre></td></tr></table></figure><ul><li>缺点<ul><li>如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起</li></ul></li><li>场景<ul><li>表示对象-整体层次结构</li><li>希望用户忽略组合对象和单个对象的不同，用户将统一地使用组合结构中的所有对象（方法）</li><li>虚拟 dom</li></ul></li></ul><h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p>运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式。</p><p>一个程序中使用了大量的相似对象，造成等很大的内存开销，且对象的大部分属性都可以变成外部状态。主要是区分外部状态和内部状态，剥离外部状态，保存在其他地方，在合适的时候再把外部状态组装进共享对象</p><p>重点：区分内部状态或外部状态</p><ul><li>内部状态存储于对象的内部</li><li>内部状态可以被一些对象共享</li><li>内部状态独立于具体的场景，通常不会改变</li><li>外部状态取决于具体的场景，并根据场景而变化，外部状态不能被共享</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建享元对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Modal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">id, gender</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.gender = gender;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">`张<span class="subst">$&#123;gender&#125;</span><span class="subst">$&#123;id&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构建享元工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModalFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">//单例模式</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">create</span>(<span class="params">id, gender</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>[gender]) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>[gender];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span>[gender] = <span class="keyword">new</span> Modal(id, gender));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//管理外部状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TakeClothesManager</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 添加衣服款式</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">addClothes</span>(<span class="params">id, gender, clothes</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> modal = ModalFactory.create(id, gender);</span><br><span class="line">    <span class="built_in">this</span>[id] = &#123;</span><br><span class="line">      clothes,</span><br><span class="line">      modal,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 拍照</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">takePhoto</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> obj = <span class="built_in">this</span>[id];</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;obj.modal.gender&#125;</span>模特<span class="subst">$&#123;obj.modal.name&#125;</span>穿<span class="subst">$&#123;obj.clothes&#125;</span>拍了张照`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">  TakeClothesManager.addClothes(i, <span class="string">&#x27;男&#x27;</span>, <span class="string">`服装<span class="subst">$&#123;i&#125;</span>`</span>);</span><br><span class="line">  TakeClothesManager.takePhoto(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">50</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; addClothes, takePhoto &#125; = TakeClothesManager;</span><br><span class="line">  TakeClothesManager.addClothes(i, <span class="string">&#x27;女&#x27;</span>, <span class="string">`服装<span class="subst">$&#123;i&#125;</span>`</span>);</span><br><span class="line">  TakeClothesManager.takePhoto(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点<ul><li>大大减少对象的创建，降低系统的内存，使效率提高。</li></ul></li><li>缺点<ul><li>提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，<br>不应该随着内部状态的变化而变化，否则会造成系统的混乱</li></ul></li><li>场景例子<ul><li>文件上传需要创建多个文件实例的时候</li><li>如果一个应用程序使用了大量的对象，而这些大量的对象造成了很大的存储开销时就应该考虑使用享元模式</li></ul></li></ul><h3 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h3><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使它们能够自动更新自己，当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主题 保存状态，状态变化之后触发所有观察者对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.observers = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getState</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.state;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setState</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = state;</span><br><span class="line">    <span class="built_in">this</span>.notifyAllObservers();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">notifyAllObservers</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.observers.forEach(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">      observer.update();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">attach</span>(<span class="params">observer</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.observers.push(observer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, subject</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.subject = subject;</span><br><span class="line">    <span class="built_in">this</span>.subject.attach(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> update, state: <span class="subst">$&#123;<span class="built_in">this</span>.subject.getState()&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Subject();</span><br><span class="line"><span class="keyword">let</span> o1 = <span class="keyword">new</span> Observer(<span class="string">&#x27;o1&#x27;</span>, s);</span><br><span class="line"><span class="keyword">let</span> o2 = <span class="keyword">new</span> Observer(<span class="string">&#x27;02&#x27;</span>, s);</span><br><span class="line"></span><br><span class="line">s.setState(<span class="number">12</span>);</span><br></pre></td></tr></table></figure><ul><li>优点<ul><li>支持简单的广播通信，自动通知所有已经订阅过的对象</li><li>目标对象与观察者之间的抽象耦合关系能单独扩展以及重用</li><li>增加了灵活性</li><li>观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。</li></ul></li><li>缺点<ul><li>过度使用会导致对象与对象之间的联系弱化，会导致程序难以跟踪维护和理解</li></ul></li><li>应用场景<ul><li>DOM 事件</li><li>vue 响应式</li><li>vue emit</li></ul></li></ul><h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><p>提供一种方法顺序一个聚合对象中各个元素，而又不暴露该对象的内部表示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">conatiner</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.list = conatiner.list;</span><br><span class="line">    <span class="built_in">this</span>.index = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.hasNext()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.list[<span class="built_in">this</span>.index++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">hasNext</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.index &gt;= <span class="built_in">this</span>.list.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">list</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.list = list;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getIterator</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Iterator(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">let</span> container = <span class="keyword">new</span> Container([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="keyword">let</span> iterator = container.getIterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>特点<ul><li>访问一个聚合对象的内容而无需暴露它的内部表示。</li><li>为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作.</li><li>对于集合内部结果常常变化各异，不想暴露其内部结构的话，但又想让客户代码透明的访问其中的元素，可以使用迭代器模式</li></ul></li><li>场景例子<ul><li>Array.prototype.forEach</li><li>jQuery 中的$.each()</li><li>ES6 Iterator</li></ul></li></ul><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>实现一种功能有多种选择方案，将算法的使用和实现分离开来。定义一系列的算法，把他们封装起来，并且使他们可以相互替换。可用于替换 if else。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供策略</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Strategy1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">calculate</span>(<span class="params">salary</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Strategy2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">calculate</span>(<span class="params">salary</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> salary * <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义使用类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bonus</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.salary = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.strategy = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setSalary</span>(<span class="params">salary</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.salary = salary;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">setStrategy</span>(<span class="params">strategy</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.strategy = strategy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getBonus</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.strategy.calculate(<span class="built_in">this</span>.salary);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个bonus对象</span></span><br><span class="line"><span class="keyword">const</span> bonus = <span class="keyword">new</span> Bonus();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置基本值</span></span><br><span class="line">bonus.setSalary(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置使用的策略1</span></span><br><span class="line">bonus.setStrategy(<span class="keyword">new</span> Strategy1());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取最终的bonus</span></span><br><span class="line"><span class="built_in">console</span>.log(bonus.getBonus());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置使用的策略2</span></span><br><span class="line">bonus.setStrategy(<span class="keyword">new</span> Strategy2());</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bonus.getBonus());</span><br></pre></td></tr></table></figure><ul><li>优点<ul><li>利用组合、委托、多态等技术和思想，可以有效的避免多重条件选择语句</li><li>提供了对开放-封闭原则的完美支持，将算法封装在独立的 strategy 中，使得它们易于切换，理解，易于扩展</li><li>利用组合和委托来让 Context 拥有执行算法的能力，这也是继承的一种更轻便的代替方案</li></ul></li><li>缺点<ul><li>会在程序中增加许多策略类或者策略对象</li><li>要使用策略模式，必须了解所有的 strategy，必须了解各个 strategy 之间的不同点，这样才能选择一个合适的 strategy</li></ul></li><li>场景例子<ul><li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的’行为’，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li><li>一个系统需要动态地在几种算法中选择一种。</li><li>表单验证</li></ul></li></ul><h4 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h4><p>模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法和封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">&#123; brewDrink, addCondiment &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.brewDrink = brewDrink;</span><br><span class="line">    <span class="built_in">this</span>.addCondiment = addCondiment;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 烧开水，共用方法 */</span></span><br><span class="line">  <span class="function"><span class="title">boilWater</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;水已经煮沸=== 共用&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 倒杯子里，共用方法 */</span></span><br><span class="line">  <span class="function"><span class="title">pourCup</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;倒进杯子里===共用&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* 模板方法 */</span></span><br><span class="line">  <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.boilWater();</span><br><span class="line">    <span class="built_in">this</span>.brewDrink();</span><br><span class="line">    <span class="built_in">this</span>.pourCup();</span><br><span class="line">    <span class="built_in">this</span>.addCondiment();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 咖啡 */</span></span><br><span class="line"><span class="keyword">const</span> coffee = <span class="keyword">new</span> Beverage(&#123;</span><br><span class="line">  <span class="comment">/* 冲泡咖啡，覆盖抽象方法 */</span></span><br><span class="line">  brewDrink: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;冲泡咖啡&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 加调味品，覆盖抽象方法 */</span></span><br><span class="line">  addCondiment: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;加点奶和糖&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">coffee.init();</span><br></pre></td></tr></table></figure><ul><li>优点<ul><li>提取了公共代码部分，易于维护</li></ul></li><li>缺点<ul><li>增加了系统复杂度，主要是增加了的抽象类和类间联系</li></ul></li><li>场景例子<ul><li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现</li><li>子类中公共的行为应被提取出来并集中到一个公共父类中的避免代码重复</li></ul></li></ul><h4 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h4><p>使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 请假审批，需要组长审批、经理审批、总监审批</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.nextAction = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setNextAction</span>(<span class="params">action</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.nextAction = action;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handle</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> 审批`</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.nextAction != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.nextAction.handle();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a1 = <span class="keyword">new</span> Action(<span class="string">&#x27;组长&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> a2 = <span class="keyword">new</span> Action(<span class="string">&#x27;经理&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> a3 = <span class="keyword">new</span> Action(<span class="string">&#x27;总监&#x27;</span>);</span><br><span class="line">a1.setNextAction(a2);</span><br><span class="line">a2.setNextAction(a3);</span><br><span class="line">a1.handle();</span><br></pre></td></tr></table></figure><ul><li>优点<ul><li>降低耦合度。它将请求的发送者和接收者解耦。</li><li>简化了对象。使得对象不需要知道链的结构。</li><li>增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。</li><li>增加新的请求处理类很方便。</li></ul></li><li>缺点<ul><li>不能保证某个请求一定会被链中的节点处理，这种情况可以在链尾增加一个保底的接受者节点来处理这种即将离开链尾的请求。</li><li>使程序中多了很多节点对象，可能再一次请求的过程中，大部分的节点并没有起到实质性的作用。他们的作用仅仅是让请求传递下去，从性能当面考虑，要避免过长的职责链到来的性能损耗。</li></ul></li><li>场景例子<ul><li>JS 中的事件冒泡</li><li>作用域链</li><li>原型链</li></ul></li></ul><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><p>将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收者类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">execute</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;接收者执行请求&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">receiver</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">execute</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;命令&#x27;</span>);</span><br><span class="line">    <span class="built_in">this</span>.receiver.execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 触发者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">command</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.command = command;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">invoke</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开始&#x27;</span>);</span><br><span class="line">    <span class="built_in">this</span>.command.execute();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仓库</span></span><br><span class="line"><span class="keyword">const</span> warehouse = <span class="keyword">new</span> Receiver();</span><br><span class="line"><span class="comment">// 订单</span></span><br><span class="line"><span class="keyword">const</span> order = <span class="keyword">new</span> Command(warehouse);</span><br><span class="line"><span class="comment">// 客户</span></span><br><span class="line"><span class="keyword">const</span> client = <span class="keyword">new</span> Invoker(order);</span><br><span class="line">client.invoke();</span><br></pre></td></tr></table></figure><ul><li>优点<ul><li>对命令进行封装，使命令易于扩展和修改。</li><li>命令发出者和接受者解耦，使发出者不需要知道命令的具体执行过程即可执行。</li></ul></li><li>缺点<ul><li>使用命令模式可能会导致某些系统有过多的具体命令类。</li></ul></li></ul><h4 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h4><p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//备忘类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">content</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.content = content;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getContent</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.content;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 备忘列表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CareTaker</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.list = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">memento</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.list.push(memento);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">index</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.list[index];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编辑器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.content = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setContent</span>(<span class="params">content</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.content = content;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getContent</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.content;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">saveContentToMemento</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Memento(<span class="built_in">this</span>.content);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getContentFromMemento</span>(<span class="params">memento</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.content = memento.getContent();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> editor = <span class="keyword">new</span> Editor();</span><br><span class="line"><span class="keyword">let</span> careTaker = <span class="keyword">new</span> CareTaker();</span><br><span class="line"></span><br><span class="line">editor.setContent(<span class="string">&#x27;111&#x27;</span>);</span><br><span class="line">editor.setContent(<span class="string">&#x27;222&#x27;</span>);</span><br><span class="line">careTaker.add(editor.saveContentToMemento());</span><br><span class="line">editor.setContent(<span class="string">&#x27;333&#x27;</span>);</span><br><span class="line">careTaker.add(editor.saveContentToMemento());</span><br><span class="line">editor.setContent(<span class="string">&#x27;444&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(editor.getContent()); <span class="comment">//444</span></span><br><span class="line">editor.getContentFromMemento(careTaker.get(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(editor.getContent()); <span class="comment">//333</span></span><br><span class="line"></span><br><span class="line">editor.getContentFromMemento(careTaker.get(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(editor.getContent()); <span class="comment">//222</span></span><br></pre></td></tr></table></figure><ul><li>优点<ul><li>给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。</li></ul></li><li>缺点<ul><li>消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</li></ul></li><li>场景例子<ul><li>分页控件</li><li>撤销组件</li></ul></li></ul><h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><p>允许一个对象在其内部状态改变的时候改变它的行为，对象看起来似乎修改了它的类</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态 （弱光、强光、关灯）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = state;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">handle</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`this is <span class="subst">$&#123;<span class="built_in">this</span>.state&#125;</span> light`</span>);</span><br><span class="line">    context.setState(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getState</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.state;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setState</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> context = <span class="keyword">new</span> Context();</span><br><span class="line"><span class="keyword">let</span> weak = <span class="keyword">new</span> State(<span class="string">&#x27;weak&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> strong = <span class="keyword">new</span> State(<span class="string">&#x27;strong&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> off = <span class="keyword">new</span> State(<span class="string">&#x27;off&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弱光</span></span><br><span class="line">weak.handle(context);</span><br><span class="line"><span class="built_in">console</span>.log(context.getState());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 强光</span></span><br><span class="line">strong.handle(context);</span><br><span class="line"><span class="built_in">console</span>.log(context.getState());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭</span></span><br><span class="line">strong.handle(context);</span><br><span class="line"><span class="built_in">console</span>.log(context.getState());</span><br></pre></td></tr></table></figure><ul><li>优点<ul><li>定义了状态与行为之间的关系，封装在一个类里，更直观清晰，增改方便</li><li>状态与状态间，行为与行为间彼此独立互不干扰</li><li>用对象代替字符串来记录当前状态，使得状态的切换更加一目了然</li></ul></li><li>缺点<ul><li>会在系统中定义许多状态类</li><li>逻辑分散</li></ul></li><li>场景<ul><li>一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为</li><li>一个操作中含有大量的分支语句，而且这些分支语句依赖于该对象的状态</li></ul></li></ul><h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><p>表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 访问者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">visitConcreteElement</span>(<span class="params">ConcreteElement</span>)</span> &#123;</span><br><span class="line">    ConcreteElement.operation();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 元素类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteElement</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;&#125;</span><br><span class="line">  <span class="function"><span class="title">operation</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;ConcreteElement.operation invoked&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">accept</span>(<span class="params">visitor</span>)</span> &#123;</span><br><span class="line">    visitor.visitConcreteElement(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// client</span></span><br><span class="line"><span class="keyword">let</span> visitor = <span class="keyword">new</span> Visitor();</span><br><span class="line"><span class="keyword">let</span> element = <span class="keyword">new</span> ConcreteElement();</span><br><span class="line">elementA.accept(visitor);</span><br></pre></td></tr></table></figure><ul><li>优点<ul><li>符合单一职责原则</li><li>优秀的扩展性</li><li>灵活性</li></ul></li><li>缺点<ul><li>具体元素对访问者公布细节，违反了迪米特原则</li><li>违反了依赖倒置原则，依赖了具体类，没有依赖抽象。</li><li>具体元素变更比较困难</li></ul></li><li>场景例子<ul><li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作</li><li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作”污染”这些对象的类，也不希望在增加新操作时修改这些类。</li></ul></li></ul><h4 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h4><p>解除对象与对象之间的紧耦合关系。增加一个中介者对象后，所有的相关对象都通过中介者对象来通信，而不是互相引用，所以当一个对象发生改变时，只需要通知中介者对象即可。中介者使各对象之间耦合松散，而且可以独立地改变它们之间的交互。中介者模式使网状的多对多关系变成了相对简单的一对多关系（类似于观察者模式，但是单向的，由中介者统一管理。）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.number = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setNumber</span>(<span class="params">num, m</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.number = num;</span><br><span class="line">    <span class="keyword">if</span> (m) &#123;</span><br><span class="line">      m.setB();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.number = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setNumber</span>(<span class="params">num, m</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.number = num;</span><br><span class="line">    <span class="keyword">if</span> (m) &#123;</span><br><span class="line">      m.setA();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">    <span class="built_in">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setA</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="built_in">this</span>.b.number;</span><br><span class="line">    <span class="built_in">this</span>.a.setNumber(number * <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">setB</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="built_in">this</span>.a.number;</span><br><span class="line">    <span class="built_in">this</span>.b.setNumber(number / <span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A();</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> Mediator(a, b);</span><br><span class="line">a.setNumber(<span class="number">10</span>, m);</span><br><span class="line"><span class="built_in">console</span>.log(a.number, b.number);</span><br><span class="line">b.setNumber(<span class="number">10</span>, m);</span><br><span class="line"><span class="built_in">console</span>.log(a.number, b.number);</span><br></pre></td></tr></table></figure><ul><li>优点<ul><li>使各对象之间耦合松散，而且可以独立地改变它们之间的交互。</li><li>中介者和对象一对多的关系取代了对象之间的网状多对多的关系。</li><li>如果对象之间的复杂耦合度导致维护很困难，而且耦合度随项目变化增速很快，就需要中介者重构代码。</li></ul></li><li>缺点<ul><li>系统中会新增一个中介者对象，因 为对象之间交互的复杂性，转移成了中介者对象的复杂性，使得中介者对象经常是巨大的。中介 者对象自身往往就是一个难以维护的对象。</li></ul></li><li>场景例子<ul><li>系统中对象之间存在比较复杂的引用关系，导致它们之间的依赖关系结构混乱而且难以复用该对象想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li></ul></li></ul><h4 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h4><p>给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._list = []; <span class="comment">// 存放 终结符表达式</span></span><br><span class="line">    <span class="built_in">this</span>._sum = <span class="number">0</span>; <span class="comment">// 存放 非终结符表达式(运算结果)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title">sum</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._sum;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">sum</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>._sum = newValue;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">expression</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>._list.push(expression);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">list</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> [...this._list];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlusExpression</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">interpret</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(context <span class="keyword">instanceof</span> Context)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;TypeError&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    context.sum = ++context.sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinusExpression</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">interpret</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(context <span class="keyword">instanceof</span> Context)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;TypeError&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    context.sum = --context.sum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 以下是测试代码 **/</span></span><br><span class="line"><span class="keyword">const</span> context = <span class="keyword">new</span> Context();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次添加: 加法 | 加法 | 减法 表达式</span></span><br><span class="line">context.add(<span class="keyword">new</span> PlusExpression());</span><br><span class="line">context.add(<span class="keyword">new</span> PlusExpression());</span><br><span class="line">context.add(<span class="keyword">new</span> MinusExpression());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次执行: 加法 | 加法 | 减法 表达式</span></span><br><span class="line">context.list.forEach(<span class="function">(<span class="params">expression</span>) =&gt;</span> expression.interpret(context));</span><br><span class="line"><span class="built_in">console</span>.log(context.sum);</span><br></pre></td></tr></table></figure><ul><li>优点<ul><li>易于改变和扩展文法。</li><li>由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法</li></ul></li><li>缺点<ul><li>执行效率较低，在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度慢。</li><li>对于复杂的文法比较难维护。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> FE Code </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序算法小结</title>
      <link href="405.html"/>
      <url>405.html</url>
      
        <content type="html"><![CDATA[<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><h3 id="函数坐标图"><a href="#函数坐标图" class="headerlink" title="函数坐标图"></a>函数坐标图</h3><p><img data-src="http://cdn.flqin.com/p405-1.jpeg" alt="函数坐标图"></p><h3 id="排序算法对比图"><a href="#排序算法对比图" class="headerlink" title="排序算法对比图"></a>排序算法对比图</h3><table><thead><tr><th>类别</th><th>时间复杂度（平均）</th><th>时间复杂度（最好）</th><th>时间复杂度（最坏）</th><th>空间复杂度（辅助存储）</th><th>排序方式</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序（交换）</td><td>O(n<sup>2</sup>)</td><td>O(n)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>In-place</td><td>稳定</td></tr><tr><td>快速排序（交换）</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n<sup>2</sup>)</td><td>看情况</td><td>In-place</td><td>不稳定</td></tr><tr><td>插入排序（插入）</td><td>O(n<sup>2</sup>)</td><td>O(n)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>In-place</td><td>稳定</td></tr><tr><td>希尔排序（插入）</td><td>根据步长序列</td><td>O(n)</td><td>根据步长序列</td><td>O(1)</td><td>In-place</td><td>不稳定</td></tr><tr><td>选择排序（选择）</td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>In-place</td><td>不稳定</td></tr><tr><td>堆排序（选择）</td><td>O(nlogn))</td><td>O(nlogn))</td><td>O(nlogn))</td><td>O(1)</td><td>In-place</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlogn))</td><td>O(nlogn))</td><td>O(nlogn))</td><td>O(n)</td><td>Out-place</td><td>稳定</td></tr><tr><td>计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>Out-place</td><td>稳定</td></tr><tr><td>桶排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n<sup>2</sup>)</td><td>O(n*k)</td><td>Out-place</td><td>稳定</td></tr><tr><td>基数排序</td><td>O(n*k)</td><td>O(n*k)</td><td>O(n*k)</td><td>O(n+k)</td><td>Out-place</td><td>稳定</td></tr></tbody></table><ul><li>n: 数据量</li><li>k: 桶的个数</li><li>In-place: 占用常数内存</li><li>Out-place: 占用额外内存</li><li>稳定性：排序后 2 个相等键值的顺序和排序之前它们的顺序相同</li></ul><h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p><img data-src="http://cdn.flqin.com/p405-2.gif" alt="冒泡排序"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> temp = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>冒泡排序是一种交换排序，核心是冒泡，把数组中最小的那个往上冒，冒的过程就是和他相邻的元素交换。</li><li>冒泡排序毕竟是一种效率低下的排序方法，在数据规模很小时，可以采用。</li></ul><h2 id="快速排序（Quick-Sort）"><a href="#快速排序（Quick-Sort）" class="headerlink" title="快速排序（Quick Sort）"></a>快速排序（Quick Sort）</h2><p><img data-src="http://cdn.flqin.com/p405-3.jpeg" alt="快速排序"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length,</span><br><span class="line">    partitionIndex,</span><br><span class="line">    left = <span class="keyword">typeof</span> left != <span class="string">&#x27;number&#x27;</span> ? <span class="number">0</span> : left,</span><br><span class="line">    right = <span class="keyword">typeof</span> right != <span class="string">&#x27;number&#x27;</span> ? len - <span class="number">1</span> : right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    partitionIndex = partition(arr, left, right);</span><br><span class="line">    quickSort(arr, left, partitionIndex - <span class="number">1</span>);</span><br><span class="line">    quickSort(arr, partitionIndex + <span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span>(<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//分区操作</span></span><br><span class="line">  <span class="keyword">let</span> pivot = left, <span class="comment">//设定基准值（pivot）</span></span><br><span class="line">    index = pivot + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt;= right; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">      swap(arr, i, index);</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span>(<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = arr[i];</span><br><span class="line">  arr[i] = arr[j];</span><br><span class="line">  arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>递归分治法，随机选择一个元素作为中心点，其他值与中心点比较，左小右大进行分区，然后递归对两个区重复分区。</li><li>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(n log n) ，且 O(n log n)记号中隐含的常数因子很小，比复杂度稳定等于 O(n log n)的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</li></ul><h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><p><img data-src="http://cdn.flqin.com/p405-4.gif" alt="插入排序"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">let</span> preIndex, current;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    preIndex = i - <span class="number">1</span>;</span><br><span class="line">    current = arr[i];</span><br><span class="line">    <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">      arr[preIndex + <span class="number">1</span>] = arr[preIndex];</span><br><span class="line">      preIndex--;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>插入排序是排序序列中从后向前扫描，找到相应位置并插入对应的未排序数据，类似斗地主理牌的情景。</li><li>插入排序不适合对于数据量比较大的排序应用。</li></ul><h2 id="希尔排序（Shell-Sort）"><a href="#希尔排序（Shell-Sort）" class="headerlink" title="希尔排序（Shell Sort）"></a>希尔排序（Shell Sort）</h2><p><img data-src="http://cdn.flqin.com/p405-5.gif" alt="希尔排序"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length,</span><br><span class="line">    temp,</span><br><span class="line">    gap = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>) &#123;</span><br><span class="line">    gap = gap * <span class="number">3</span> + <span class="number">1</span>; <span class="comment">//动态定义间隔序列</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap / <span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">      temp = arr[i];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;</span><br><span class="line">        arr[j + gap] = arr[j];</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j + gap] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>希尔排序实质就是分组插入排序，插入排序的一种更高效率的实现，核心在于步长序列的设定。</li><li>最好步长序列至今还是数学难题，平均时间复杂度根据增量序列不同而不同。</li></ul><h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><p><img data-src="http://cdn.flqin.com/p405-6.gif" alt="选择排序"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">let</span> minIndex, temp;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">        minIndex = j;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = arr[i];</span><br><span class="line">    arr[i] = arr[minIndex];</span><br><span class="line">    arr[minIndex] = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>与冒泡不同，冒泡排序是通过相邻的比较和交换，而选择排序是通过整体的选择，找到最大（小）值交换无序区起始位置。</li><li>算法稳定在 <code>O(n²)</code> 的时间复杂度。</li></ul><h2 id="堆排序（Heap-Sort）"><a href="#堆排序（Heap-Sort）" class="headerlink" title="堆排序（Heap Sort）"></a>堆排序（Heap Sort）</h2><p><img data-src="http://cdn.flqin.com/p405-7.gif" alt="堆排序"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//1.构建大顶堆</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">    adjustHeap(arr, i, arr.length);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = arr.length - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[a]; <span class="comment">//将堆顶元素与末尾元素进行交换</span></span><br><span class="line">    arr[a] = arr[b];</span><br><span class="line">    arr[b] = temp;</span><br><span class="line">    adjustHeap(arr, <span class="number">0</span>, j); <span class="comment">//重新对堆进行调整</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构建堆</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">adjustHeap</span>(<span class="params">arr, i, length</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = arr[i]; <span class="comment">//先取出当前元素i</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> k = i * <span class="number">2</span> + <span class="number">1</span>; k &lt; length; k = k * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">    <span class="keyword">if</span> (k + <span class="number">1</span> &lt; length &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) &#123;</span><br><span class="line">      <span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">      k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[k] &gt; temp) &#123;</span><br><span class="line">      <span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">      arr[i] = arr[k];</span><br><span class="line">      i = k;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  arr[i] = temp; <span class="comment">//将temp值放到最终的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>堆是具一个完全二叉树。</li><li>每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。</li><li>堆排序思想：将待排序序列构造成一个大顶堆，此时整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反复执行，便能得到一个有序序列。</li><li>堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。</li></ul><h2 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h2><p><img data-src="http://cdn.flqin.com/p405-8.gif" alt="归并排序"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//采用自上而下的递归方法</span></span><br><span class="line">  <span class="keyword">let</span> len = arr.length;</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>),</span><br><span class="line">    left = arr.slice(<span class="number">0</span>, middle),</span><br><span class="line">    right = arr.slice(middle);</span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.push(left.shift());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(right.shift());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left.length) result.push(left.shift());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (right.length) result.push(right.shift());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>分而治之。</li><li>两种方式实现：分为自顶向下（递归）和自底向上（迭代）。</li></ul><h2 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h2><p><img data-src="http://cdn.flqin.com/p405-9.gif" alt="计数排序"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countingSort</span>(<span class="params">arr, maxValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> bucket = <span class="keyword">new</span> <span class="built_in">Array</span>(maxValue + <span class="number">1</span>),</span><br><span class="line">    sortedIndex = <span class="number">0</span>;</span><br><span class="line">  (arrLen = arr.length), (bucketLen = maxValue + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arrLen; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!bucket[arr[i]]) &#123;</span><br><span class="line">      bucket[arr[i]] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bucket[arr[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; bucketLen; j++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      arr[sortedIndex++] = j;</span><br><span class="line">      bucket[j]--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>计数排序要求输入的数据必须是有确定范围的整数</li><li>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中</li></ul><h2 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h2><p><img data-src="http://cdn.flqin.com/p405-10.gif" alt="桶排序"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span>(<span class="params">arr, bucketSize</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> i;</span><br><span class="line">  <span class="keyword">let</span> minValue = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> maxValue = arr[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; minValue) &#123;</span><br><span class="line">      minValue = arr[i]; <span class="comment">//输入数据的最小值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; maxValue) &#123;</span><br><span class="line">      maxValue = arr[i]; <span class="comment">//输入数据的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//桶的初始化</span></span><br><span class="line">  <span class="keyword">let</span> DEFAULT_BUCKET_SIZE = <span class="number">5</span>; <span class="comment">//设置桶的默认数量为5</span></span><br><span class="line">  bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;</span><br><span class="line">  <span class="keyword">let</span> bucketCount = <span class="built_in">Math</span>.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> buckets = <span class="keyword">new</span> <span class="built_in">Array</span>(bucketCount);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">    buckets[i] = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//利用映射函数将数据分配到各个桶中</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    buckets[<span class="built_in">Math</span>.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  arr.length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buckets.length; i++) &#123;</span><br><span class="line">    insertionSort(buckets[i]); <span class="comment">//对每个桶进行排序，这里使用了插入排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">      arr.push(buckets[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>分治思想</li><li>桶排序基于计数排序，将数组的元素分布到多个桶中</li><li>对每个桶被单独地排序，应用其他排序方法</li></ul><h2 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h2><p><img data-src="http://cdn.flqin.com/p405-11.gif" alt="基数排序"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> counter = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span>(<span class="params">arr, maxDigit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> mod = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> dev = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> bucket = <span class="built_in">parseInt</span>((arr[j] % mod) / dev);</span><br><span class="line">      <span class="keyword">if</span> (counter[bucket] == <span class="literal">null</span>) &#123;</span><br><span class="line">        counter[bucket] = [];</span><br><span class="line">      &#125;</span><br><span class="line">      counter[bucket].push(arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; counter.length; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> value = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (counter[j] != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((value = counter[j].shift()) != <span class="literal">null</span>) &#123;</span><br><span class="line">          arr[pos++] = value;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>基数排序是一种非比较的整数排序算法。</li><li>原理是将整数按位数切割成不同的数字，然后对每个位数上的数字进行分别比较(低位到高位)。</li><li>基数排序与计数排序、桶排序这三种排序算法都利用了桶的概念，并且都是<strong>线性时间非比较类排序</strong>（其他排序是<strong>非线性时间比较类排序</strong>）但对桶的使用方法上有明显差异：<ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值；</li></ul></li></ul><blockquote><p>非线性时间比较类排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 O(nlogn)，因此称为非线性时间比较类排序。</p><p>线性时间非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="简单的排序"><a href="#简单的排序" class="headerlink" title="简单的排序"></a>简单的排序</h3><ul><li>冒泡排序：循环遍历左右比较，较小的元素前移，较大的元素后移。</li><li>选择排序：在未排序序列中找到最小的元素一次性放到已排序序列的末端。</li><li>插入排序：从未排序序列中取出每一个元素，依次在已排序序列里从后向前扫描，插入到合适的位置。</li></ul><h3 id="高效的排序"><a href="#高效的排序" class="headerlink" title="高效的排序"></a>高效的排序</h3><ul><li>快速排序：找到基准，进行分区操作（基准左边的小，右边大），递归对分区的分区继续进行分区操作，直至分区元素有序或则剩余一个元素。</li><li>堆排序：建堆，首尾交换，断尾，再建堆，直至最后一个元素。</li><li>希尔排序：本质上就是分组插入排序的一种更高效的改善型，希尔排序并非是每次一个元素挨着另一个元素的进行比较，它采用了较大的增量（也就是间隔几个元素而非 1 个元素）；先将待排序序列分割成几个子序列，每个子序列间隔相同的特定的增量（几个元素），以跳跃式的方式进行插入排序；然后依次缩小增量再进行插入排序直至最后的增量为 1，对所有元素进行最后一次插入排序。</li></ul><h3 id="基于分治递归的排序"><a href="#基于分治递归的排序" class="headerlink" title="基于分治递归的排序"></a>基于分治递归的排序</h3><ul><li>归并排序：两两分组进行排序，排序后两组合并再排序。</li><li>计数排序：用待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序序列。</li><li>桶排序：把每个数字按照一定的映射函数放到相应的桶中，然后对桶内的数字排序。</li><li>基数排序：所有待比较数值（正整数）先统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</li></ul>]]></content>
      
      
      <categories>
          
          <category> FE Code </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）鉴权方案实现小结</title>
      <link href="404.html"/>
      <url>404.html</url>
      
        <content type="html"><![CDATA[<p>目前我们常用的鉴权有四种：</p><ul><li>HTTP Basic Authentication</li><li>session-cookie</li><li>Token 验证</li><li>OAuth(开放授权)</li></ul><h2 id="HTTP-Basic-Authentication"><a href="#HTTP-Basic-Authentication" class="headerlink" title="HTTP Basic Authentication"></a>HTTP Basic Authentication</h2><h3 id="HTTP-Basic-Authentication-概念"><a href="#HTTP-Basic-Authentication-概念" class="headerlink" title="HTTP Basic Authentication 概念"></a>HTTP Basic Authentication 概念</h3><p>HTTP Basic Authentication 授权方式是浏览器遵守 http 协议实现的基本授权方式，HTTP 协议进行通信的过程中，HTTP 协议定义了允许 HTTP 服务器对客户端进行用户身份验证的方法。</p><h3 id="HTTP-Basic-Authenticatio-认证过程"><a href="#HTTP-Basic-Authenticatio-认证过程" class="headerlink" title="HTTP Basic Authenticatio 认证过程"></a>HTTP Basic Authenticatio 认证过程</h3><ol><li>客户端向服务器请求数据，请求的内容可能是一个网页或者是一个 ajax 异步请求，此时，假设客户端尚未被验证；</li><li>服务器向客户端发送验证请求代码 401，然后弹出用户登录界面；</li><li>用户输入用户信息和密码，浏览器会自动以 base64 形式进行加密；</li><li>服务器收到请求之后，将信息解密，将其与数据库中的用户信息进行对比，一直的话返回用户需要的请求内容。</li></ol><p>登录失效的方案：在注销操作的时候，专门在服务器设置一个专门的注销账号，当接收到的 Authentication 信息为注销用户名密码的时候便注销成功了，而客户端在注销操作的时候，手动的去修改请求头的 Authentication，将它设置为服务器默认的注销账号和密码。</p><p>注：该方式很古老，基本没用，安全性较低。</p><h2 id="session-cookie"><a href="#session-cookie" class="headerlink" title="session-cookie"></a>session-cookie</h2><h3 id="session-cookie-概念"><a href="#session-cookie-概念" class="headerlink" title="session-cookie 概念"></a>session-cookie 概念</h3><p>利用服务器端的 session（会话）和浏览器端的 cookie 来实现前后端的认证，由于 http 请求时是无状态的，需要在服务器端创建一个会话(seesion),将同一个客户端的请求都维护在各自得会会话中，每当请求到达服务器端的时候，先去查一下该客户端有没有在服务器端创建 seesion，如果有则已经认证成功了，否则就没有认证。</p><h3 id="session-cookie-认证过程"><a href="#session-cookie-认证过程" class="headerlink" title="session-cookie 认证过程"></a>session-cookie 认证过程</h3><ol><li>服务器在接受客户端首次访问时在服务器端创建 seesion，然后保存 seesion 到内存当中，然后给这个 session 生成一个唯一的标识字符串,然后在响应头中种下这个唯一标识字符串。</li><li>浏览器中收到请求响应的时候会解析响应头，然后将 session_id 保存在本地 cookie 中，浏览器在下次 http 请求时请求头中会带上该域名下的 cookie 信息</li><li>服务器在接受客户端请求时会去解析请求头 cookie 中的 session_id，然后根据这个 session_id 去找服务器端保存的该客户端的 session，然后判断该请求是否合法.</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>只适用于 web 系统(其他终端没有 cookie 一说)</li><li>session 的内存占用：每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以便用户下次请求的鉴别，通常而言 session 都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大</li><li>分布式 session 的问题：分布式环境下，如何保证 session 在多台机器间共享(解决思路：1.共享存储(redis)；2.只使用 cookie(类似于 token 验证)；3.Nginx 负载均衡策略按 ip hash(保证同一用户的请求打到同一台机器))</li><li>CSRF 风险：由于依赖 cookie 进行用户识别，cookie 如果被截获，用户就会很容易受到跨站请求伪造的攻击</li></ul><h2 id="Token-验证"><a href="#Token-验证" class="headerlink" title="Token 验证"></a>Token 验证</h2><h3 id="Token-认证过程"><a href="#Token-认证过程" class="headerlink" title="Token 认证过程"></a>Token 认证过程</h3><ol><li>客户端使用用户名跟密码请求登录；</li><li>服务端收到请求，去验证用户名与密码；</li><li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端；</li><li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里；</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token（url 参数，post 参数，HTTP header 等地方都行）；</li><li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据。</li></ol><h3 id="token-验证方案-JWT"><a href="#token-验证方案-JWT" class="headerlink" title="token 验证方案 JWT"></a>token 验证方案 JWT</h3><h4 id="JWT-概念"><a href="#JWT-概念" class="headerlink" title="JWT 概念"></a>JWT 概念</h4><p>JWT 是 Auth0 提出的通过对 JSON 进行加密签名来实现授权验证的方案，就是登陆成功后将相关信息组成 json 对象，然后对这个对象进行某种方式的加密，返回给客户端，客户端在下次请求时带上这个 token，服务端再收到请求时校验 token 合法性，其实也就是在校验请求的合法性。</p><p>API 可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在 多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如： Firebase,Google, Microsoft）。</p><p>JWT 是 OAuth2 协议中授权码模式的一种具体实现.</p><h4 id="JWT-组成"><a href="#JWT-组成" class="headerlink" title="JWT 组成"></a>JWT 组成</h4><ul><li>Headers： 包括类别（typ）、加密算法（alg）；</li><li>Payload ：包括需要传递的用户信息；</li><li>Signature： 根据 alg 算法与私有秘钥进行加密得到的签名字串，这一段是最重要的敏感信息，只能在服务端解密；</li></ul><h4 id="基于-JWT-的实践"><a href="#基于-JWT-的实践" class="headerlink" title="基于 JWT 的实践"></a>基于 JWT 的实践</h4><p>在 JWT 的实践中，引入 Refresh Token，将会话管理流程改进如下：</p><ol><li>客户端使用用户名密码进行认证</li><li>服务端生成有效时间较短的 Access Token（例如 10 分钟），和有效时间较长的 Refresh Token（例如 7 天）</li><li>客户端访问需要认证的接口时，携带 Access Token</li><li>如果 Access Token 没有过期，服务端鉴权后返回给客户端需要的数据</li><li>如果携带 Access Token 访问需要认证的接口时鉴权失败（例如返回 401 错误），则客户端使用 Refresh Token 向刷新接口申请新的 Access Token</li><li>如果 Refresh Token 没有过期，服务端向客户端下发新的 Access Token</li><li>客户端使用新的 Access Token 访问需要认证的接口</li></ol><h4 id="JWT-优点"><a href="#JWT-优点" class="headerlink" title="JWT 优点"></a>JWT 优点</h4><ol><li>支持跨域访问，并防止 csrf 攻击，更适用于移动应用: Cookie 是不允许垮域访问的，且 APP 不支持 cookies， csrf 会被携带 cookie</li><li>可扩展性好: 应用程序分布式部署的情况下，session 需要做多机数据共享，通常可以存在数据库或者 redis 里面。而 jwt 不需要。</li><li>无状态: jwt 不在服务端存储任何状态，session 有状态的</li><li>去耦: 不需要绑定到一个特定的身份验证方案。Token 可以在任何地方生成，只要在 你的 API 被调用的时候， 你可以进行 Token 生成调用即可.</li></ol><h3 id="JWT-缺点"><a href="#JWT-缺点" class="headerlink" title="JWT 缺点"></a>JWT 缺点</h3><ol><li>占带宽</li><li>无法在服务端注销</li><li>性能问题（加密签名，而且太长）</li><li>一次性 （登录状态信息无法废弃、续签问题）</li></ol><h2 id="OAuth-开放授权"><a href="#OAuth-开放授权" class="headerlink" title="OAuth(开放授权)"></a>OAuth(开放授权)</h2><h3 id="OAuth-概念"><a href="#OAuth-概念" class="headerlink" title="OAuth 概念"></a>OAuth 概念</h3><p>OAuth（开放授权）是一个开放标准，允许用户授权第三方网站访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方网站或分享他们数据的所有内容，为了保护用户数据的安全和隐私，第三方网站访问用户数据前都需要显式的向用户征求授权。我们常见的提供 OAuth 认证服务的厂商有支付宝，QQ,微信。</p><h3 id="OAuth2-的四种模式"><a href="#OAuth2-的四种模式" class="headerlink" title="OAuth2 的四种模式"></a>OAuth2 的四种模式</h3><h4 id="授权码模式"><a href="#授权码模式" class="headerlink" title="授权码模式"></a>授权码模式</h4><ol><li>向用户请求授权，而当我们点击等第三方入口时，第三方授权服务会引导我们进入第三方登陆授权页面，此时路由附上重定向的地址 redirect_uri；</li><li>当用户点击授权并登陆后，授权服务器将生成一个用户凭证（code）。这个用户凭证 Authorization Code 会附加在重定向的地址 redirect_uri 的后面；</li><li>用户再去请求时携带用户凭证（code）(该部分操作在后台进行，由后台服务器带上 Authorization Code 和 client_id 去请求验证服务器)，验证服务器返回一个 access_token 和 refresh_token；</li><li>后台再去拿着令牌 Access Token 请求资源时，就会得到受保护的资源信息。</li></ol><h5 id="先获取-code-的原因"><a href="#先获取-code-的原因" class="headerlink" title="先获取 code 的原因"></a>先获取 code 的原因</h5><ol><li>code 需要设置过期时间，一般设置的过期时间非常短，如 10 分钟等，用户需要在短时间内通过 code 换取 access_token，避免 code 被第三方拦截。当然，即便这种情况会发生，但因为 code 的过期时间非常短，也在一定程度上进行了保护，但这肯定不是完全安全的</li><li>授权成功后，code 是会直接显示在浏览器上的，如果不通过 code 换取 access_token，而是直接返回 access_token，那 access_token 会被暴露出来，而 code 换取 access_token 是直接通过 oauth 服务器进行换取的，不依赖浏览器，access_token 不会暴露出去。</li></ol><h5 id="access-token-amp-refresh-token"><a href="#access-token-amp-refresh-token" class="headerlink" title="access token &amp; refresh token"></a>access token &amp; refresh token</h5><p>为什么要刷新 access token 呢？一是因为 access token 是有过期时间的，到了过期时间这个 access token 就失效，需要刷新；二是因为一个 access token 会关联一定的用户权限，如果用户授权更改了，这个 access token 需要被刷新以关联新的权限。</p><p>为什么要专门用一个 token 去更新 access token 呢？如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，多麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。</p><h4 id="简化模式"><a href="#简化模式" class="headerlink" title="简化模式"></a>简化模式</h4><ol><li>用户在客户端上点击要哪个系统的 OAuth2 来认证，此时客户端附上回调地址</li><li>用户在 OAuth2 服务器上选择是否授权</li><li>用户给于授权，OAuth2 服务器重定向到第一步给定的回调地址，并且附上 access_token 和 refresh_token</li></ol><h4 id="密码模式"><a href="#密码模式" class="headerlink" title="密码模式"></a>密码模式</h4><p>用户直接输入用户名和密码，这种情况针对自家的 APP 或者 100%信任的 APP 可以这么干</p><h4 id="客户端凭证模式"><a href="#客户端凭证模式" class="headerlink" title="客户端凭证模式"></a>客户端凭证模式</h4><p>客户端自带认证，用户向客户端认证就可以.</p>]]></content>
      
      
      <categories>
          
          <category> FE Summary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）10分钟彻底搞懂前端页面性能监控</title>
      <link href="403.html"/>
      <url>403.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接 <code>https://juejin.im/post/5d8cc378f265da5ba0776f36</code></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前端页面性能是一个非常核心的用户体验指标。本文介绍阿里 UC 岳鹰全景监控平台 如何设计一个通用、低侵入性、自动上报的页面性能监控方案。主要采用的是 <code>Navigation Timing API</code> 以及 <code>sendBeacon</code> 等方法。</p><p><img data-src="http://cdn.flqin.com/p403-01.png" alt="导读"></p><h2 id="为什么要监控页面性能"><a href="#为什么要监控页面性能" class="headerlink" title="为什么要监控页面性能"></a>为什么要监控页面性能</h2><p>一个页面性能差的话会大大影响用户体验。用户打开页面等待的太久，可能会直接关掉页面，甚至就不再使用了，这种情况在移动端更加明显，移动端用户对页面响应延迟容忍度很低。</p><p>虽然页面性能很重要，但是在实际使用中，页面性能差的情况并不少见。首先，在产品的迭代演进过程中，页面性能可能会被忽略，性能随着版本迭代而有所衰减；其次，性能优化是一项复杂而挑战的事情，需要明确的优化方向和具体的优化手段才能快速落地取效。</p><p>所以我们需要一个性能监控系统，持续监控和预警页面性能的状况，并且在发现瓶颈的时候指导优化工作。</p><h2 id="理解-Navigation-Timing-API-的性能指标"><a href="#理解-Navigation-Timing-API-的性能指标" class="headerlink" title="理解 Navigation Timing API 的性能指标"></a>理解 Navigation Timing API 的性能指标</h2><p>为了帮助开发者更好地衡量和改进前端页面性能，W3C 性能小组引入了 <code>Navigation Timing API</code>，实现了自动、精准的页面性能打点；开发者可以通过 <code>window.performance</code> 属性获取。</p><ul><li><p><code>performance.timing</code> 接口（定义了从 <code>navigationStart</code> 至 <code>loadEventEnd</code> 的 21 个只读属性）</p></li><li><p><code>performance.navigation</code>（定义了当前文档的导航信息，比如是重载还是向前向后等）</p></li></ul><p>下图是 W3C 第一版的 Navigation Timing 的处理模型。从当前浏览器窗口卸载旧页面开始，到新页面加载完成，整个过程一共被切分为 9 个小块：<code>提示卸载旧文档、重定向/卸载、应用缓存、DNS 解析、TCP 握手、HTTP 请求处理、HTTP 响应处理、DOM 处理、文档装载完成</code>。每个小块的首尾、中间做事件分界，取 Unix 时间戳，两两事件之间计算时间差，从而获取中间过程的耗时（精确到毫秒级别）。</p><p><img data-src="http://cdn.flqin.com/p403-02.png" alt="Level 1"></p><p>上图是 Level 1 的规范，2012 年底进入候选建议阶段，至今仍在日常使用中；但是在 W3C 的议程上，它已经功成身退，让位给了精度更高，功能更强大，层次更分明的 Level 2（处理模型如下图）。比如独立划分出来的 Resource Timing，使得我们可以获取具体资源的详细耗时信息。</p><p><img data-src="http://cdn.flqin.com/p403-03.png" alt="Level 2"></p><h3 id="指标解读"><a href="#指标解读" class="headerlink" title="指标解读"></a>指标解读</h3><p><img data-src="http://cdn.flqin.com/p403-04.png" alt="指标解读"></p><h2 id="采集页面性能的关键指标"><a href="#采集页面性能的关键指标" class="headerlink" title="采集页面性能的关键指标"></a>采集页面性能的关键指标</h2><p>使用上面的指标，我们可以计算许多重要的指标，如首字节的时间，页面加载时间，dns 查找以及连接是否安全。我们把 Navigation Timing API 提供的指标做下归类，按照从上到下的时间流，右边的时刻标记了每个指标从哪里开始计算到哪里截止，比如，跳转时间 <code>redirect</code> 由 <code>redirectEnd - redirectStart</code> 计算得到，其他的类推。</p><p><img data-src="http://cdn.flqin.com/p403-05.png" alt="关键指标"></p><h3 id="确定统计起始点-（navigationStart-vs-fetchStart-）"><a href="#确定统计起始点-（navigationStart-vs-fetchStart-）" class="headerlink" title="确定统计起始点 （navigationStart vs fetchStart ）"></a>确定统计起始点 （navigationStart vs fetchStart ）</h3><p>页面性能统计的起始点时间，应该是用户输入网址回车后开始等待的时间。一个是通过 <code>navigationStart</code> 获取，相当于在 URL 输入栏回车或者页面按 F5 刷新的时间点；另外一个是通过 <code>fetchStart</code>，相当于浏览器准备好使用 HTTP 请求获取文档的时间。</p><p>从开发者实际分析使用的场景，浏览器重定向、卸载页面的耗时对页面加载分析并无太大作用；通常建议使用 <code>fetchStart</code> 作为统计起始点。</p><h3 id="首字节"><a href="#首字节" class="headerlink" title="首字节"></a>首字节</h3><p>主文档返回第一个字节的时间，是页面加载性能比较重要的指标。对用户来说一般无感知，对于开发者来说，则代表访问网络后端的整体响应耗时。</p><h3 id="白屏时间"><a href="#白屏时间" class="headerlink" title="白屏时间"></a>白屏时间</h3><p>用户看到页面展示出现一个元素的时间。很多人认为白屏时间是页面返回的首字节时间，但这样其实并不精确，因为头部资源还没加载完毕，页面也是白屏。</p><p>相对来说具备「白屏时间」统计意义的指标，可以取 <code>domLoading - fetchStart</code>，此时页面开始解析 DOM 树，页面渲染的第一个元素也会很快出现。</p><p>从 W3C Navigation Timing Level 2 的方案设计，可以直接采用 <code>domInteractive - fetchStart</code>，此时页面资源加载完成，即将进入渲染环节。</p><h3 id="首屏时间"><a href="#首屏时间" class="headerlink" title="首屏时间"></a>首屏时间</h3><p>首屏时间是指页面第一屏所有资源完整展示的时间。这是一个对用户来说非常直接的体验指标，但是对于前端却是一个非常难以统计衡量的指标。</p><p>具备一定意义上的指标可以使用，<code>domContentLoadedEventEnd - fetchStart</code>，甚至使用 <code>loadEventStart - fetchStart</code>，此时页面 DOM 树已经解析完成并且显示内容。<br>以下给出统计页面性能指标的方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> times = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> t = <span class="built_in">window</span>.performance.timing;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先使用 navigation v2 https://www.w3.org/TR/navigation-timing-2/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> win.PerformanceNavigationTiming === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> nt2Timing = performance.getEntriesByType(<span class="string">&#x27;navigation&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (nt2Timing) &#123;</span><br><span class="line">      t = nt2Timing;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重定向时间</span></span><br><span class="line">times.redirectTime = t.redirectEnd - t.redirectStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dns 查询耗时</span></span><br><span class="line">times.dnsTime = t.domainLookupEnd - t.domainLookupStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TTFB 读取页面第一个字节的时间</span></span><br><span class="line">times.ttfbTime = t.responseStart - t.navigationStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DNS 缓存时间</span></span><br><span class="line">times.appcacheTime = t.domainLookupStart - t.fetchStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载页面的时间</span></span><br><span class="line">times.unloadTime = t.unloadEventEnd - t.unloadEventStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">//tcp 连接耗时</span></span><br><span class="line">times.tcpTime = t.connectEnd - t.connectStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">//request 请求耗时</span></span><br><span class="line">times.reqTime = t.responseEnd - t.responseStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解析 dom 树耗时</span></span><br><span class="line">times.analysisTime = t.domComplete - t.domInteractive;</span><br><span class="line"></span><br><span class="line"><span class="comment">//白屏时间</span></span><br><span class="line">times.blankTime = (t.domInteractive || t.domLoading) - t.fetchStart;</span><br><span class="line"></span><br><span class="line"><span class="comment">//domReadyTime</span></span><br><span class="line">times.domReadyTime = t.domContentLoadedEventEnd - t.fetchStart;</span><br></pre></td></tr></table></figure><h3 id="SPA-盛行之际"><a href="#SPA-盛行之际" class="headerlink" title="SPA 盛行之际"></a>SPA 盛行之际</h3><p><code>Navigation Timing API</code> 可以监控大部分前端页面的性能。但随着 SPA 模式的盛行，类似 vue，reactjs 等框架的普及，页面内容渲染的时机被改变了，W3C 标准无法完全满足原来的监控意义。</p><p>幸运的是，目前 W3C 关于首屏统计已经进入了提议阶段，以 Chrome 为首的浏览器正在打造更能代表用户使用体验的 FP、FCP、FMP 指标，并且逐步开放 API。</p><p><img data-src="http://cdn.flqin.com/p403-06.png" alt="新的指标"></p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>通过 <code>window.performance.timing</code> 所获的的页面渲染所相关的数据，在 SPA 应用中改变了 url 但不刷新页面的情况下是不会更新的。因此仅仅通过该 api 是无法获得每一个子路由所对应的页面渲染的时间。如果需要上报切换路由情况下每一个子页面重新 render 的时间，需要自定义上报。</p><h2 id="数据上报方式"><a href="#数据上报方式" class="headerlink" title="数据上报方式"></a>数据上报方式</h2><p>测量好时间后，就需要将数据发送给服务端。页面性能统计数据对丢失率要求比较低，且性能统计应该在尽量不影响主流程的逻辑和页面性能的前提下进行。</p><h3 id="使用的-img-标签-get-请求"><a href="#使用的-img-标签-get-请求" class="headerlink" title="使用的 img 标签 get 请求"></a>使用的 img 标签 get 请求</h3><ul><li>不存在 AJAX 跨域问题，可做跨源的请求</li><li>很古老的标签，没有浏览器兼容性问题</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="keyword">new</span> Image();</span><br><span class="line">i.onload = i.onerror = i.onabort = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  i = i.onload = i.onerror = i.onabort = <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line">i.src = url;</span><br></pre></td></tr></table></figure><h3 id="navigator-sendBeacon"><a href="#navigator-sendBeacon" class="headerlink" title="navigator.sendBeacon"></a>navigator.sendBeacon</h3><p>大部分现代浏览器都支持 <code>navigator.sendBeacon</code> 方法。这个方法可以用来发送一些统计和诊断的小量数据，特别适合上报统计的场景。</p><ul><li>数据可靠，浏览器关闭请求也照样能发</li><li>异步执行，不会影响下一页面的加载</li><li>API 使用简单</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;unload&#x27;</span>, logData, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  navigator.sendBeacon(<span class="string">&#x27;/log&#x27;</span>, analyticsData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终方案<br>当浏览器支持 <code>sendBeacon</code> 方法，优先使用该方法，使用 <code>img</code> 方式降级上报。</p>]]></content>
      
      
      <categories>
          
          <category> FE Summary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）全面分析总结JS内存模型</title>
      <link href="402.html"/>
      <url>402.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接：<code>https://juejin.im/post/5e6a1f406fb9a07cae13781e</code></p></blockquote><h2 id="数据类型与内存"><a href="#数据类型与内存" class="headerlink" title="数据类型与内存"></a>数据类型与内存</h2><h3 id="数据类型分类"><a href="#数据类型分类" class="headerlink" title="数据类型分类"></a>数据类型分类</h3><p>主要分为两大类：<strong>基本数据类型、复杂数据类型</strong>，详细分类如下。</p><ul><li>基本数据类型: <code>String、Number、Boolean、Null、Undefined、Symbol</code></li><li>复杂数据类型: <code>Object 以及所有继承自 Object 的类型</code></li></ul><p>对于不同的数据类型有不同的内存区域存储数据，基本数据类型直接存储在栈内存，复杂数据类型存储在堆内存。</p><h3 id="内存分类"><a href="#内存分类" class="headerlink" title="内存分类"></a>内存分类</h3><blockquote><p>JS 中的内存分类与 JS 引擎有关，在浏览中一般是 V8 引擎；要进行内存区分主要是为了进行垃圾回收，比如在 V8 的垃圾回收机制中会根据新生代、老生代内存采用不同回收算法来保证垃圾回收效率。</p></blockquote><p>JS 内存空间分为<strong>栈（stack）内存</strong>和<strong>堆（heap）内存</strong>，栈内存是<strong>栈结构存储基本数据类型和指向堆内存的指针</strong>，堆内存<strong>存储复杂数据类型</strong>。</p><h2 id="变量声明与赋值"><a href="#变量声明与赋值" class="headerlink" title="变量声明与赋值"></a>变量声明与赋值</h2><h3 id="核心点总结"><a href="#核心点总结" class="headerlink" title="核心点总结"></a>核心点总结</h3><ul><li>变量声明的本质是变量名与栈内存地址进行绑定，不直接与堆内存进行绑定。</li><li>声明的基本数据类型会将值存储在栈内存中，声明的复杂数据类型会将值存储在堆内存中并将其在堆中的内存地址作为值存到栈内存中。</li><li>const 声明常量本质是指的是声明的变量名所指向的栈内存地址不可改变，但是栈中对应的值可以改变。</li><li>基本数据类型赋值是在栈内存中申请新的内存区域保存值并将其指向的内存地址绑定到原有变量上。</li><li>复杂数据类型赋值是在堆内存中申请新的内存区域保存值并将其指向的内存地址作为值在栈内存中申请新的内存区域保存将其在栈中的内存地址绑定到变量上。</li></ul><h3 id="详解变量声明与赋值"><a href="#详解变量声明与赋值" class="headerlink" title="详解变量声明与赋值"></a>详解变量声明与赋值</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> index = <span class="number">23</span>;</span><br></pre></td></tr></table></figure><p>基础数据类型直接将值存储在栈内存中，变量绑定到值在栈中对应的地址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _index = index;</span><br></pre></td></tr></table></figure><p>声明另一个变量 <code>_index</code> 并赋值为 index，其实是将 <code>_index</code> 和 <code>index</code> 变量绑定到 <code>index</code> 指向的内存地址。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">45</span>;</span><br></pre></td></tr></table></figure><p>修改变量 <code>index</code> 的值为基本数据类型，其实是在栈内存中分配内存存储值然后将得到的内存地址绑定到变量 <code>index</code>。</p><h4 id="复杂数据类型"><a href="#复杂数据类型" class="headerlink" title="复杂数据类型"></a>复杂数据类型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> students = [];</span><br></pre></td></tr></table></figure><p>复杂数据类型在声明时是在堆内存上分配内存空间存储其值，将分配的堆内存空间地址作为值存储在栈内存上，变量直接绑定的是栈上内存地址。</p><p>通过引用来修改复杂数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _students = students;</span><br><span class="line">_students.push(&#123; <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><p><code>_status = students</code> 赋值语句只是将两个变量指向同一个栈内存地址，<code>push()</code> 语句将在堆内存中分配新空间存储新的数组并将其在堆内存的地址存储到栈中。</p><h4 id="更复杂的例子"><a href="#更复杂的例子" class="headerlink" title="更复杂的例子"></a>更复杂的例子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">arr = [obj];</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p><code>[obj]</code>属于复杂类型中引用复杂类型是通过指针引用处理，虽然通过 <code>obj=null</code> 来清除了 <code>obj</code> 对于对象 <code>&#123;index:&#39;小明&#39;&#125;</code> 的绑定，但是 <code>arr</code> 对该对象任然存在引用。</p><h3 id="详解常量声明与赋值"><a href="#详解常量声明与赋值" class="headerlink" title="详解常量声明与赋值"></a>详解常量声明与赋值</h3><p>声明基本数据类型为常量过程与基本数据类型的声明过程相同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> index = <span class="number">1</span>;</span><br><span class="line">index = <span class="number">100</span>; <span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p>对声明为基本数据类型的常量进行赋值会发生结果</p><p>在将 <code>index</code> 变量绑定到新产生的内存地址时报错：不允许修改常量绑定的内存地址。</p><p>声明复杂数据类型为常量过程与基本数据类型的声明过程相同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> students = [];</span><br><span class="line">students = [&#123; <span class="attr">name</span>: <span class="string">&#x27;小红&#x27;</span> &#125;];</span><br></pre></td></tr></table></figure><p>对声明为复杂数据类型的常量进行赋值会产生如下结果</p><p>在将 <code>students</code> 变量绑定到新产生的内存地址时报错：不允许修改常量绑定的内存地址。</p><h3 id="深复制与浅复制"><a href="#深复制与浅复制" class="headerlink" title="深复制与浅复制"></a>深复制与浅复制</h3><blockquote><p>上面说的复杂数据类型通过指针指向了同一块堆内存空间，深、浅复制主要区别就在于复制值的时候是否新分配堆内存空间来保存原值的拷贝。</p></blockquote><p>对于对象或数组类型，当我们将 a 赋值给 b，然后更改 b 中的属性，a 也会随着变化。 也就是说 a 和 b 指向了同一块内存，所以修改其中任意的值，另一个值都会随之变化，这就是 <strong>浅复制（拷贝）</strong>。</p><p><strong>深复制（拷贝）</strong> 则是在上述 a 赋值给 b 过程分配了新堆内存空间来存储拷贝的值，同时在存在复杂数据类型的嵌套属性（<strong>递归遍历</strong>）也要用同样方式处理，最后复制出来的新数据对象下的任意层级的复杂对象都有新的堆内存存储相应的值。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>有内存就必然有 <strong>垃圾回收（GC）</strong>，JS 中栈内存多数是在函数执行时使用（根据函数调用顺序也叫做<strong>调用栈</strong>），函数执行完后即开始栈内存的垃圾回收。堆内存由于存在多个栈内存中的指针指向它以及堆内存较大等原因，需要采用特定的垃圾回收算法处理。</p><blockquote><p>垃圾回收的关键在于如何判断内存已经不再使用然后将其释放掉</p></blockquote><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>主要是 IE 等旧浏览器在采用，通过计数器分析变量的引用次数，清除没有引用到的变量。对于<strong>存在循环引用的情况则无法处理</strong>，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cycle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> o2 = &#123;&#125;;</span><br><span class="line">  o1.a = o2;</span><br><span class="line">  o2.a = o1;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;Cycle reference!&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cycle();</span><br></pre></td></tr></table></figure><p>其中 o1 引用了 o2，o2 引用了 o1，在 cycle 函数执行完 o1，o2 都没有再次引用到，但是引用计数算法判断两者都存在引用。</p><h3 id="Scavenge-算法"><a href="#Scavenge-算法" class="headerlink" title="Scavenge 算法"></a>Scavenge 算法</h3><p>用于 V8 中新生代内存，将新生代内存一分为二：From 和 To，在 From 与 To 之间转换的过程中完成垃圾回收。</p><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>早期 V8 中堆内存采用的一种清除算法，全局扫描堆内存找出未使用到的对象进行标记并清除，由于未进行内存整理会存在内存碎片。</p><h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>全局扫描堆内存找出未使用到的对象边整理边清除，解决了标记清除算法导致的内存碎片问题。</p><h3 id="增量式清除、整理"><a href="#增量式清除、整理" class="headerlink" title="增量式清除、整理"></a>增量式清除、整理</h3><p>堆内存大小一般较大，在采用前几种算法进行垃圾回收时需要扫描全堆，导致 JS 执行逻辑长时间暂停。增量式清除、整理是将标记清除或标记整理拆分为一个步进，轮流执行 JS 逻辑和一个步进，最大程度较少 JS 执行逻辑暂停时间。</p><h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p>以在浏览器控制台运行下面这段代码为例（暂时不考虑 ES6 语法兼容性）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> _arr = arr;</span><br><span class="line">  <span class="keyword">return</span> _arr.join();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> array = newArray(<span class="number">20</span>).fill(<span class="number">1</span>);</span><br><span class="line">fn(array);</span><br></pre></td></tr></table></figure><h4 id="变量声明（依次执行）"><a href="#变量声明（依次执行）" class="headerlink" title="变量声明（依次执行）"></a>变量声明（依次执行）</h4><p>依次执行：堆内存储函数 fn、栈内存存储常量整数 index、堆内存存储数组 array</p><h4 id="调用函数（函数调用栈）"><a href="#调用函数（函数调用栈）" class="headerlink" title="调用函数（函数调用栈）"></a>调用函数（函数调用栈）</h4><p>依次执行：变量 <code>arr、_arr</code> 指向数组 array、存储 join 方法返回的字符串到栈内存</p><h4 id="清除函数调用栈"><a href="#清除函数调用栈" class="headerlink" title="清除函数调用栈"></a>清除函数调用栈</h4><p>函数调用栈中的变量 <code>arr、_arr</code> 属于函数作用域，此时已经不可访问将被清除。</p><h4 id="清除堆栈内存"><a href="#清除堆栈内存" class="headerlink" title="清除堆栈内存"></a>清除堆栈内存</h4><p>整个 JS 逻辑执行完成，函数 fn、常量 index、数组 array、函数 fn 返回的字符串都将会清除。</p><blockquote><p>若在浏览器控制台中，执行完上述 JS 逻辑并未退出控制台，上述清除堆栈内存将在关闭控制台后执行。</p></blockquote><h2 id="常见问题分析"><a href="#常见问题分析" class="headerlink" title="常见问题分析"></a>常见问题分析</h2><h3 id="闭包导致内存泄露"><a href="#闭包导致内存泄露" class="headerlink" title="闭包导致内存泄露"></a>闭包导致内存泄露</h3><p>闭包就是通过返回一个函数间接地使外部有机会访问到函数内部的变量，扩展了 JS 中函数作用域的范围。</p><p>创建闭包方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> generateFn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> obj = &#123; <span class="attr">index</span>: <span class="number">1</span> &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = generateFn()(); <span class="comment">// 此时 obj2 就指向了上面定义的 obj</span></span><br></pre></td></tr></table></figure><p>下面用法会导致内存泄露：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.fn = generateFn(); <span class="comment">// 返回的函数绑定至了全局，没有主动清除</span></span><br></pre></td></tr></table></figure><p>generateFn 生成了一个引用 obj 的函数，同时将其绑定至了全局对象 window，导致 fn 不会被回收，而 fn 引用了 obj 使 obj 也不会被回收，于是产生了内存泄露。</p><h3 id="WeakSet、WeakMap-的弱引用"><a href="#WeakSet、WeakMap-的弱引用" class="headerlink" title="WeakSet、WeakMap 的弱引用"></a>WeakSet、WeakMap 的弱引用</h3><p>WeakSet 和 WeakMap 是 ES6 中两种新的数据结构，它们对于值的引用都<strong>不计入垃圾回收机制</strong>。WeakSet 只能存储不重复的对象，WeakMap 只能以对象为 key 来存储 key-value 对。对应对象在外部变为不可访问时，其对应的存储记录也将自行丢失。</p><h4 id="WeakMap-分析"><a href="#WeakMap-分析" class="headerlink" title="WeakMap 分析"></a>WeakMap 分析</h4><p>通过分析下面这段代码来说明其弱引用的特性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">index</span>: <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> vs = newWeakSet();</span><br><span class="line">vs.add(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">// 清除 obj 使在进行 GC 时清除&#123; index: 0 &#125;对象</span></span><br></pre></td></tr></table></figure><p>将 obj 对象添加进 WeakSet 实例中，此时可以通过 obj 和 vs 变量来访问到 obj 对象，通过 obj=null 清除对象，此时 vs 中的 obj 对象的引用也会<strong>自动清除</strong>。</p><p>在 GC 完成之后（这里直接 console.log 打印还是可以看到 obj 对象的，因为 GC 没有完成），可以看到 vs 的 items 是空的。</p><p>另外，在研读 React 源码的过程中发现其中 DOMEventListenerMap.js 中有对 WeakMap 实际应用，下篇文章将会深入研究一下 WeakMap、WeakSet 等实际的应用。</p>]]></content>
      
      
      <categories>
          
          <category> FE Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2.x（含组件）主流程源码笔记（十）：destroyed 阶段</title>
      <link href="401.html"/>
      <url>401.html</url>
      
        <content type="html"><![CDATA[<p>上两章分析了 <code>Vue</code> 的 <code>update</code> 阶段，本章我们以点击 <code>点击让第二个App组件卸载</code> 触发 <code>hide</code> 执行 <code>this.isShow = false</code> 为例，分析 <code>Vue</code> 的 <code>destroyed</code> 阶段。</p><p>前面逻辑同 <code>update</code> 阶段一致，触发该属性的订阅即 <code>渲染 watcher</code> 执行 <code>run</code> 方法，在 <code>updateComponent</code> 里先执行 <code>vm._render</code> 得到最新 <code>vnode</code>，然后执行 <code>vm._update</code> 更新 <code>dom</code>。</p><p>在 <code>updateChildren</code> 循环里遍历比较子 <code>vnode</code>，可以看出只有最后一个 <code>vnode</code> 不同：旧 <code>vnode</code> 为 <code>App</code> 组件 <code>vnode</code>，新 <code>vnode</code> 为注释 <code>vnode</code>。 则先调用 <code>createElm</code> 根据注释 <code>vnode</code> 创建真实 <code>dom</code> 并插入到对应位置；然后在 <code>while</code> 下次循环时，对旧的 <code>App</code> 组件 <code>vnode</code> 执行 <code>removeVnodes</code> 移除。</p><h2 id="removeVnodes"><a href="#removeVnodes" class="headerlink" title="removeVnodes"></a>removeVnodes</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeVnodes</span>(<span class="params">vnodes, startIdx, endIdx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; startIdx &lt;= endIdx; ++startIdx) &#123;</span><br><span class="line">    <span class="keyword">var</span> ch = vnodes[startIdx];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(ch.tag)) &#123;</span><br><span class="line">        removeAndInvokeRemoveHook(ch);</span><br><span class="line">        invokeDestroyHook(ch);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Text node</span></span><br><span class="line">        removeNode(ch.elm);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>removeVnodes</code> 方法里根据 <code>vnodes</code> 的类型执行不同的方法：如果是标签节点，需要处理属性及钩子；如果是文本节点，则直接移除 <code>dom</code> 即可。</p><h2 id="removeAndInvokeRemoveHook"><a href="#removeAndInvokeRemoveHook" class="headerlink" title="removeAndInvokeRemoveHook"></a>removeAndInvokeRemoveHook</h2><p><code>removeAndInvokeRemoveHook</code> 方法主要递归处理了子节点的属性并删除 <code>dom</code> 节点。</p><h2 id="invokeDestroyHook"><a href="#invokeDestroyHook" class="headerlink" title="invokeDestroyHook"></a>invokeDestroyHook</h2><p><code>invokeDestroyHook</code> 里先触发该组件 <code>vnode</code> 的 <code>destroy</code> 钩子，下文分析。然后执行 <code>cbs.destroy</code> 里的方法，包括 <code>destroy</code> 和 <code>unbindDirectives</code>，然后如果有 <code>vnode.children</code> 即子节点，则对每项递归执行 <code>invokeDestroyHook</code>，到此，<code>Vue</code> 的 <code>destroyed</code> 阶段结束。</p><h2 id="componentVNodeHooks-destroy"><a href="#componentVNodeHooks-destroy" class="headerlink" title="componentVNodeHooks.destroy"></a>componentVNodeHooks.destroy</h2><p>钩子里对组件 <code>vnode</code> 的组件实例进行判断，如果是被 <code>keppAlive</code> 组件包裹，则执行 <code>deactivateChildComponent</code> 修改状态并触发 <code>deactivated</code> 钩子；如果没有则执行组件实例的 <code>$destroy</code> 方法。</p><h2 id="Vue-prototype-destroy"><a href="#Vue-prototype-destroy" class="headerlink" title="Vue.prototype.$destroy"></a><code>Vue.prototype.$destroy</code></h2><h3 id="Vue-prototype-destroy-源码"><a href="#Vue-prototype-destroy-源码" class="headerlink" title="Vue.prototype.$destroy 源码"></a><code>Vue.prototype.$destroy</code> 源码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">  Vue.prototype.$destroy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vm = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm._isBeingDestroyed) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    callHook(vm, <span class="string">&#x27;beforeDestroy&#x27;</span>);</span><br><span class="line">    vm._isBeingDestroyed = <span class="literal">true</span>; <span class="comment">// remove self from parent</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> parent = vm.$parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parent &amp;&amp; !parent._isBeingDestroyed &amp;&amp; !vm.$options.abstract) &#123;</span><br><span class="line">      remove(parent.$children, vm);</span><br><span class="line">    &#125; <span class="comment">// teardown watchers</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm._watcher) &#123;</span><br><span class="line">      vm._watcher.teardown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i = vm._watchers.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      vm._watchers[i].teardown();</span><br><span class="line">    &#125; <span class="comment">// remove reference from data ob</span></span><br><span class="line">    <span class="comment">// frozen object may not have observer.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm._data.__ob__) &#123;</span><br><span class="line">      vm._data.__ob__.vmCount--;</span><br><span class="line">    &#125; <span class="comment">// call the last hook...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vm._isDestroyed = <span class="literal">true</span>; <span class="comment">// invoke destroy hooks on current rendered tree</span></span><br><span class="line"></span><br><span class="line">    vm.__patch__(vm._vnode, <span class="literal">null</span>); <span class="comment">// fire destroyed hook</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    callHook(vm, <span class="string">&#x27;destroyed&#x27;</span>); <span class="comment">// turn off all instance listeners.</span></span><br><span class="line"></span><br><span class="line">    vm.$off(); <span class="comment">// remove __vue__ reference</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">      vm.$el.__vue__ = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="comment">// release circular reference (#6759)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (vm.$vnode) &#123;</span><br><span class="line">      vm.$vnode.parent = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Vue-prototype-destroy-逻辑"><a href="#Vue-prototype-destroy-逻辑" class="headerlink" title="Vue.prototype.$destroy 逻辑"></a><code>Vue.prototype.$destroy</code> 逻辑</h3><ol><li>触发 <code>beforeDestroy</code> 钩子</li><li>移除 <code>Vue</code> 组件链里的本组件实例引用</li><li>通知各订阅中心移除各订阅列表里该 <code>watcher</code> 的订阅</li><li>移除 <code>data</code> 对象的 <code>__ob__</code></li><li>执行 <code>vm.__patch__(vm._vnode, null)</code> 即开始销毁组件实例，即对组件实例执行 <code>invokeDestroyHook</code></li><li>触发 <code>destroyed</code> 钩子</li><li>移除组件实例上的事件</li><li>移除组件实例里的 <code>$el</code> 的实例引用</li><li>移除组件节点的 <code>parent</code> 引用</li></ol><h2 id="整体生命周期"><a href="#整体生命周期" class="headerlink" title="整体生命周期"></a>整体生命周期</h2><p><code>vue beforeUpdate -&gt; App two beforeDestroy -&gt; Child beforeDestroy -&gt; Child destroyed -&gt; App two destroyed -&gt; vue updated</code></p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>本章主要介绍当组件卸载时的 <code>destroyed</code> 阶段。</li><li>在更新 <code>vnode</code> 时，通过 <code>removeVnodes</code> 移除该组件，内部执行 <code>removeAndInvokeRemoveHook</code>（移除 <code>dom</code>），<code>invokeDestroyHook</code>（<code>$destroy</code>） 两个方法。</li><li>介绍了 <code>Vue.prototype.$destroy</code> 的内部实现及如何递归处理内部组件的卸载。</li></ol>]]></content>
      
      
      <categories>
          
          <category> FE Frame </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2.x（含组件）主流程源码笔记（九）：update 阶段（下）</title>
      <link href="400.html"/>
      <url>400.html</url>
      
        <content type="html"><![CDATA[<p>接上文，得到 <code>vnode</code> 后执行 <code>vm._update</code>。因为 <code>vm._vnode</code> 存在即已经渲染过，则走更新方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// updates</span></span><br><span class="line">vm.$el = vm.__patch__(prevVnode, vnode);</span><br></pre></td></tr></table></figure><p><code>vm.__patch__</code> 即 <code>patch</code> 方法，进入 <code>patch</code> 流程。</p><h2 id="sameVnode"><a href="#sameVnode" class="headerlink" title="sameVnode"></a>sameVnode</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sameVnode</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    a.key === b.key &amp;&amp;</span><br><span class="line">    ((a.tag === b.tag &amp;&amp; a.isComment === b.isComment &amp;&amp; isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b)) ||</span><br><span class="line">      (isTrue(a.isAsyncPlaceholder) &amp;&amp; a.asyncFactory === b.asyncFactory &amp;&amp; isUndef(b.asyncFactory.error)))</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是否相同，则判断 <code>key、 tag、是否有 data 的存在（不关心内部具体的值）、是否是注释节点、是否是相同的 input type</code>，异步则判断是否有 <code>相同的占位符，asyncFactory 等</code>。若相同则视为同一节点进行 <code>patch</code>。</p><h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p><code>patch</code> 的主要功能是将新旧 <code>vnode</code> 进行同级比较，然后更新真实 <code>dom</code> 节点和组件实例。</p><h3 id="patch-源码"><a href="#patch-源码" class="headerlink" title="patch 源码"></a>patch 源码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isUndef(vnode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(oldVnode)) &#123;</span><br><span class="line">      invokeDestroyHook(oldVnode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> isInitialPatch = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> insertedVnodeQueue = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isUndef(oldVnode)) &#123;</span><br><span class="line">    <span class="comment">// empty mount (likely as component), create new root element</span></span><br><span class="line">    isInitialPatch = <span class="literal">true</span>;</span><br><span class="line">    createElm(vnode, insertedVnodeQueue);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> isRealElement = isDef(oldVnode.nodeType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;</span><br><span class="line">      <span class="comment">// patch existing root node</span></span><br><span class="line">      patchVnode(oldVnode, vnode, insertedVnodeQueue, <span class="literal">null</span>, <span class="literal">null</span>, removeOnly);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">        <span class="comment">// 服务端渲染相关处理</span></span><br><span class="line">        <span class="keyword">if</span> (oldVnode.nodeType === <span class="number">1</span> &amp;&amp; oldVnode.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">          oldVnode.removeAttribute(SSR_ATTR);</span><br><span class="line">          hydrating = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 服务端渲染相关处理</span></span><br><span class="line">        <span class="keyword">if</span> (isTrue(hydrating)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">            invokeInsertHook(vnode, insertedVnodeQueue, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> oldVnode;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">&#x27;The client-side rendered virtual DOM tree is not matching &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;server-rendered content. This is likely caused by incorrect &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;HTML markup, for example nesting block-level elements inside &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hydration and performing &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;full client-side render.&#x27;</span></span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        oldVnode = emptyNodeAt(oldVnode);</span><br><span class="line">      &#125; <span class="comment">// replacing existing element</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> oldElm = oldVnode.elm;</span><br><span class="line">      <span class="keyword">var</span> parentElm = nodeOps.parentNode(oldElm); <span class="comment">// create new node</span></span><br><span class="line"></span><br><span class="line">      createElm(vnode, insertedVnodeQueue, oldElm._leaveCb ? <span class="literal">null</span> : parentElm, nodeOps.nextSibling(oldElm));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isDef(vnode.parent)) &#123;</span><br><span class="line">        <span class="keyword">var</span> ancestor = vnode.parent;</span><br><span class="line">        <span class="keyword">var</span> patchable = isPatchable(vnode);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ancestor) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; cbs.destroy.length; ++i) &#123;</span><br><span class="line">            cbs.destroy[i](ancestor);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          ancestor.elm = vnode.elm;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (patchable) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i$<span class="number">1</span> = <span class="number">0</span>; i$<span class="number">1</span> &lt; cbs.create.length; ++i$<span class="number">1</span>) &#123;</span><br><span class="line">              cbs.create[i$<span class="number">1</span>](emptyNode, ancestor);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> insert = ancestor.data.hook.insert;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (insert.merged) &#123;</span><br><span class="line">              <span class="comment">// start at index 1 to avoid re-invoking component mounted hook</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">var</span> i$<span class="number">2</span> = <span class="number">1</span>; i$<span class="number">2</span> &lt; insert.fns.length; i$<span class="number">2</span>++) &#123;</span><br><span class="line">                insert.fns[i$<span class="number">2</span>]();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            registerRef(ancestor);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          ancestor = ancestor.parent;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isDef(parentElm)) &#123;</span><br><span class="line">        removeVnodes([oldVnode], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.tag)) &#123;</span><br><span class="line">        invokeDestroyHook(oldVnode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);</span><br><span class="line">  <span class="keyword">return</span> vnode.elm;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="patch-逻辑"><a href="#patch-逻辑" class="headerlink" title="patch 逻辑"></a>patch 逻辑</h3><ul><li><code>vnode</code> 不存在<ul><li><code>oldVnode</code> 存在，则触发 <code>invodeDestoryHook</code> 进行销毁旧的节点（组件销毁用到）</li></ul></li><li><code>vnode</code> 存在<ul><li><code>oldVnode</code> 不存在，则调用 <code>createElm</code> 创建新的节点</li><li><code>oldVnode</code> 存在<ul><li><code>oldVnode</code> 不是真实节点且和 <code>vnode</code> 是相同节点（调用 <code>sameVnode</code> 比较），则调用 <code>patchVnode</code> 进行该 <code>vnode</code> 的补丁操作</li><li><code>oldVnode</code> 是真实节点，略过 <code>SSR</code> 相关，则先把真实节点转为空的 <code>vnode</code>。再调用 <code>createElm</code> 创建新的 <code>DOM</code> 节点并插入到真实的父节点中。如果 <code>vnode</code> 是组件实例，则递归更新各级父占位符节点（组件节点）的属性<ul><li><code>oldVnode</code> 的真实父 <code>dom</code> 节点存在，则调用 <code>removeVnodes</code> 将旧的节点从父节点中移除</li><li><code>oldVnode</code> 的真实父 <code>dom</code> 节点不存在，则触发 <code>invodeDestoryHook</code> 进行销毁旧的节点</li></ul></li></ul></li><li>触发 <code>invokeInsertHook</code> 并 返回 <code>vnode.elm</code> 真实 <code>dom</code> 节点</li></ul></li></ul><h2 id="patchVnode"><a href="#patchVnode" class="headerlink" title="patchVnode"></a>patchVnode</h2><p>比较新旧 <code>vnode</code> 节点，根据不同的状态对 <code>dom</code> 做更新操作（添加，移动，删除）（属性更新，文本更新，子节点更新）并依次调用 <code>prepatch, update, postpatch</code> 等钩子。在 <code>patch</code> 和 <code>updateChildren</code> 里调用。</p><p>在编译阶段生成的一些静态子树，在这个过程 <code>oldVnode</code> 中由于不会改变而直接跳过比对，动态子树在比较过程中比较核心的部分就是当新旧 <code>vnode</code> 同时存在 <code>children</code>，通过 <code>updateChildren</code> 方法对子节点做更新。</p><p><strong>patchVnode 为更新操作核心。</strong></p><h3 id="patchVnode-源码"><a href="#patchVnode-源码" class="headerlink" title="patchVnode 源码"></a>patchVnode 源码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchVnode</span>(<span class="params">oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (oldVnode === vnode) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123;</span><br><span class="line">    <span class="comment">// clone reused vnode</span></span><br><span class="line">    vnode = ownerArray[index] = cloneVNode(vnode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> elm = (vnode.elm = oldVnode.elm);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isTrue(oldVnode.isAsyncPlaceholder)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(vnode.asyncFactory.resolved)) &#123;</span><br><span class="line">      hydrate(oldVnode.elm, vnode, insertedVnodeQueue);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode.isAsyncPlaceholder = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isTrue(vnode.isStatic) &amp;&amp; isTrue(oldVnode.isStatic) &amp;&amp; vnode.key === oldVnode.key &amp;&amp; (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) &#123;</span><br><span class="line">    vnode.componentInstance = oldVnode.componentInstance;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> i;</span><br><span class="line">  <span class="keyword">var</span> data = vnode.data;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef((i = data.hook)) &amp;&amp; isDef((i = i.prepatch))) &#123;</span><br><span class="line">    i(oldVnode, vnode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> oldCh = oldVnode.children;</span><br><span class="line">  <span class="keyword">var</span> ch = vnode.children;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cbs.update.length; ++i) &#123;</span><br><span class="line">      cbs.update[i](oldVnode, vnode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isDef((i = data.hook)) &amp;&amp; isDef((i = i.update))) &#123;</span><br><span class="line">      i(oldVnode, vnode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isUndef(vnode.text)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldCh !== ch) &#123;</span><br><span class="line">        updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(ch)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        checkDuplicateKeys(ch);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">        nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      addVnodes(elm, <span class="literal">null</span>, ch, <span class="number">0</span>, ch.length - <span class="number">1</span>, insertedVnodeQueue);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldCh)) &#123;</span><br><span class="line">      removeVnodes(oldCh, <span class="number">0</span>, oldCh.length - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(oldVnode.text)) &#123;</span><br><span class="line">      nodeOps.setTextContent(elm, <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">    nodeOps.setTextContent(elm, vnode.text);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef((i = data.hook)) &amp;&amp; isDef((i = i.postpatch))) &#123;</span><br><span class="line">      i(oldVnode, vnode);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="patchVnode-逻辑"><a href="#patchVnode-逻辑" class="headerlink" title="patchVnode 逻辑"></a>patchVnode 逻辑</h3><ul><li><code>vnode</code> 和 <code>oldVnode</code> 完全一致，直接返回</li><li>异步占位则执行 <code>hydrate</code> 方法或者定义 <code>isAsyncPlaceholder</code> 为 <code>true</code>，直接返回</li><li><code>oldVnode</code> 和 <code>vnode</code> 都是静态节点且相同，则 <code>oldVnode.componentInstance</code> 赋给 <code>vnode.componentInstance</code>，直接返回</li><li><code>vnode</code> 有 <code>data</code> 属性，有 <code>prepatch</code> 则执行其 <strong><code>data.hook.prepatch</code> 钩子更新子组件</strong>，并执行更新其属性（<code>cbs.update</code>）；有 <code>update</code> 则执行其 <code>data.hook.update</code> 钩子</li><li><code>vnode</code> 不是文本节点<ul><li><code>vnode</code> 和 <code>oldVnode</code> 的 <code>children</code> 都存在且不完全相等，则调用 <code>updateChildren</code> 更新子节点</li><li>只有 <code>vnode</code> 存在子节点，检查子节点 <code>key</code> 值后，如果 <code>oldVnode</code> 文本节点存在，则置为空。然后调用 <code>addVnodes</code> 添加这些子节点</li><li>只有 <code>oldVnode</code> 存在子节点，则调用 <code>removeVnodes</code> 移除这些子节点</li><li><code>oldVnode</code> 和 <code>vnode</code> 都不存在子节点，但是 <code>oldVnode</code> 为文本节点或注释节点，则把 <code>elm</code> 的文本内容置为空</li></ul></li><li><code>vnode</code> 是文本节点或注释节点且 <code>vnode.text</code> 和 <code>oldVnode.text</code> 不相等，则更新 <code>elm</code> 的文本内容为 <code>vnode.text</code></li><li><code>vnode</code> 为组件节点, 则执行其 <code>data.hook.postpatch</code> 钩子</li></ul><h2 id="updateChildren"><a href="#updateChildren" class="headerlink" title="updateChildren"></a>updateChildren</h2><p><code>diff</code> 算法核心，仅在同级的 <code>vnode</code> 间做 <code>diff</code>，递归地进行同级 <code>vnode</code> 的 <code>diff</code>，最终实现整个 <code>DOM</code> 树的更新。</p><h3 id="updateChildren-源码"><a href="#updateChildren-源码" class="headerlink" title="updateChildren 源码"></a>updateChildren 源码</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateChildren</span>(<span class="params">parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oldStartIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> newStartIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> oldEndIdx = oldCh.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> oldStartVnode = oldCh[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> oldEndVnode = oldCh[oldEndIdx];</span><br><span class="line">  <span class="keyword">var</span> newEndIdx = newCh.length - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> newStartVnode = newCh[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> newEndVnode = newCh[newEndIdx];</span><br><span class="line">  <span class="keyword">var</span> oldKeyToIdx, idxInOld, vnodeToMove, refElm;</span><br><span class="line">  <span class="keyword">var</span> canMove = !removeOnly;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    checkDuplicateKeys(newCh);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isUndef(oldStartVnode)) &#123;</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx]; <span class="comment">// Vnode has been moved left</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUndef(oldEndVnode)) &#123;</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">      newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">      newEndVnode = newCh[--newEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldStartVnode, newEndVnode)) &#123;</span><br><span class="line">      <span class="comment">// Vnode moved right</span></span><br><span class="line">      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);</span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));</span><br><span class="line">      oldStartVnode = oldCh[++oldStartIdx];</span><br><span class="line">      newEndVnode = newCh[--newEndIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sameVnode(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">      <span class="comment">// Vnode moved left</span></span><br><span class="line">      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);</span><br><span class="line">      oldEndVnode = oldCh[--oldEndIdx];</span><br><span class="line">      newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isUndef(oldKeyToIdx)) &#123;</span><br><span class="line">        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isUndef(idxInOld)) &#123;</span><br><span class="line">        <span class="comment">// New element</span></span><br><span class="line">        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vnodeToMove = oldCh[idxInOld];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);</span><br><span class="line">          oldCh[idxInOld] = <span class="literal">undefined</span>;</span><br><span class="line">          canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// same key but different element. treat as new element</span></span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, <span class="literal">false</span>, newCh, newStartIdx);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      newStartVnode = newCh[++newStartIdx];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">    refElm = isUndef(newCh[newEndIdx + <span class="number">1</span>]) ? <span class="literal">null</span> : newCh[newEndIdx + <span class="number">1</span>].elm;</span><br><span class="line">    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">    removeVnodes(oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="updateChildren-逻辑"><a href="#updateChildren-逻辑" class="headerlink" title="updateChildren 逻辑"></a>updateChildren 逻辑</h3><p>执行 <code>while</code> 循环：</p><ol><li>如果 <code>oldStartVnode</code> 不存在，则将 <code>oldStartVnode</code> 设置为下一个节点</li><li>如果 <code>oldEndVnode</code> 不存在，则将 <code>oldEndVnode</code> 设置为上一个节点</li><li>如果 <code>oldStartVnode</code> 和 <code>newStartVnode</code> 是同一节点，则调用 <code>patchVnode</code> 并将 <code>oldStartVnode</code> 和 <code>newStartVnode</code> 设置为下一个节点</li><li>如果 <code>oldEndVnode</code> 和 <code>newEndVnode</code> 是同一节点，则调用 <code>patchVnode</code> 并将 <code>oldEndVnode</code> 和 <code>newEndVnode</code> 设置为上一个节点</li><li>如果 <code>oldStartVnode</code> 和 <code>newEndVnode</code> 是同一节点，则调用 <code>patchVnode</code>，然后调用 <code>insertBefore</code> 将 <code>oldStartVnode.elm</code> 移动到 <code>oldEndVnode.elm</code> 之后，并将 <code>oldStartVnode</code> 设置为下一个节点，<code>newEndVnode</code> 设置为上一个节点</li><li>如果 <code>oldEndVnode</code> 和 <code>newStartVnode</code> 是同一节点，则调用 <code>patchVnode</code>，然后调用 <code>insertBefore</code> 将 <code>oldEndVnode.elm</code> 移动到 <code>oldStartVnode.elm</code> 之前，并将 <code>oldEndVnode</code> 设置为上一个节点，<code>newStartVnode</code> 设置为下一个节点</li><li>以上都未命中<ol><li>如果 <code>newStartVnode</code> 有 <code>key</code> 值，则尝试在 <code>oldChildren</code> 中查找与 <code>newStartVnode</code> 具有相同 <code>key</code> 的节点的索引位置</li><li>如果 <code>newStartVnode</code> 没有 <code>key</code> 值，则尝试在 <code>oldChildren</code> 中查找与 <code>newStartVnode</code> 相同节点的索引位置</li><li>如果不存在索引，则调用 <code>createElm</code> 创建一个新节点插入到 <code>oldStartVnode.elm</code> 之前</li><li>如果存在索引<ol><li>如果索引对应的节点与 <code>newStartVnode</code> 是相同节点，则调用 <code>patchVnode</code> 并将找到的节点置为 <code>undefined</code>， 然后调用 <code>insertBefore</code> 将该节点的 <code>elm</code> 移动到 <code>oldStartVnode.elm</code> 之前</li><li>如果不是，则调用 <code>createElm</code> 创建一个新的节点插入到 <code>oldStartVnode.elm</code> 之前</li></ol></li><li>将 <code>newStartVnode</code> 设置为下一个节点</li></ol></li></ol><p>当 <code>oldChildren</code> 和 <code>newChildren</code> 节点在 <code>while</code> 过程中如果任意一个的开始索引和结束索引重合，则表明遍历结束。</p><p>遍历结束后：</p><ol><li>如果 <code>oldStartIdx</code> 大于 <code>oldEndIdx</code>，说明 <code>newChildren</code> 长度大于 <code>oldChildren</code>，则需要调用 <code>addVnodes</code> 添加 <code>newStartIdx</code> 到 <code>newEndIdx</code> 之间的节点</li><li>如果 <code>newStartIdx</code> 大于 <code>newEndIdx</code>，说明 <code>oldChildren</code> 长度大于 <code>newChildren</code>，则需要调用 <code>removeVnodes</code> 移除 <code>oldStartIdx</code> 到 <code>oldEndIdx</code> 之间的节点</li></ol><h3 id="updateChildren-例子"><a href="#updateChildren-例子" class="headerlink" title="updateChildren 例子"></a>updateChildren 例子</h3><p>以旧 <code>Vnode</code> 节点为 <code>A,B,C,D,F</code>，新 <code>Vnode</code> 节点为 <code>E,D,A,C,B</code>，以<code>()</code>代表 <code>startVnode</code>，<code>&#123;&#125;</code>代表 <code>endVnode</code>，则 <code>updateChildren</code> 过程为：</p><table><thead><tr><th></th><th>第一次循环</th><th>第二次循环</th><th>第三次循环</th><th>第四次循环</th><th>第五次循环</th><th>跳出循环</th></tr></thead><tbody><tr><td>旧 Vnode</td><td>(A),B,C,D,{F}</td><td>(A),B,C,D,{F}</td><td>(A),B,C,undef,{F}</td><td>A,(B),C,undef,{F}</td><td>A,B,(C),undef,{F}</td><td>A,B,C,(undef),{F}</td></tr><tr><td>新 Vnode</td><td>(E),D,A,C,{B}</td><td>E,(D),A,C,{B}</td><td>E,D,(A),C,{B}</td><td>E,D,A,(C),{B}</td><td>E,D,A,{(C)},B</td><td>E,D,A,{C},(B)</td></tr><tr><td>得到的真实 Dom</td><td>E,A,B,C,D,F</td><td>E,D,A,B,C,F</td><td>E,D,A,B,C,F</td><td>E,D,A,C,F,B</td><td>E,D,A,C,F,B</td><td>E,D,A,C,B</td></tr></tbody></table><h3 id="updateChildren-注意点"><a href="#updateChildren-注意点" class="headerlink" title="updateChildren 注意点"></a>updateChildren 注意点</h3><ul><li>设置 4 指针并向中间靠拢的目的，是因为在前端需求场景中，大概率操作是在列表开头/结尾增加/删除了一个元素，减少循环，提高效率</li><li>设置 <code>key</code> 可以直接查找匹配的节点是否相同，提高效率</li><li>首尾互相比较和 <code>key</code> 比较都未查到相同则暴力循环查相同节点</li><li>整个操作都是在通过比较 <code>vnode</code> 来操作真实 <code>dom</code>，<code>vnode</code> 在大多数情况下都不变</li></ul><h3 id="为什么不用-index-作为-key"><a href="#为什么不用-index-作为-key" class="headerlink" title="为什么不用 index 作为 key"></a>为什么不用 index 作为 key</h3><p>由源码可知，当用 <code>index</code> 作为 <code>key</code> 时，则新旧 <code>vnode</code> 的 <code>key</code> 都一样，则直接命中 <code>updateChildren 逻辑</code> 的第 3 条进行繁琐的 <code>patchVnode</code>，而不会命中后面真正相同节点进行复用操作的逻辑；</p><p>除了性能损耗外，如果该 <code>vnode</code> 里有子节点且其 <code>props</code> 未变化（依赖子组件状态或临时 <code>DOM</code> 状态），则将不会更新子组件，则节点不更新从而引起错误。</p><h2 id="子组件更新"><a href="#子组件更新" class="headerlink" title="子组件更新"></a>子组件更新</h2><p>对于本例，在 <code>updateChildren</code> 里，根据新旧 <code>vnode</code> 的差异，递归找到差异节点进行 <code>patch</code>，不再详述。</p><p>除此之外，对于第一个组件节点 <code>App</code>，在 <code>patchVnode</code> 里先执行 <code>prepatch</code> 钩子时，执行 <code>updateChildComponent</code> 更新子组件实例。<code>updateChildComponent</code> 里会对组件实例进行一系列的更新，包括 <code>vm.$vnode</code> 的更新、<code>slot</code> 的更新、<code>listeners</code> 的更新、<code>props</code> 的更新等等。如果有 <code>props</code> 且值有更新（本 <code>demo</code> 为 <code>num</code> 由 28 更新到 29）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props[key] = validateProp(key, propOptions, propsData, vm);</span><br></pre></td></tr></table></figure><p>则会重新给 <code>num</code> 赋值并触发对应的订阅列表，将 <code>app</code> 组件的 <code>渲染 watcher</code> 推入 <code>queue</code> 队列，在当前 <code>watcher</code> 执行完成后在执行该 <code>watcher</code> 的更新。</p><p>当前 <code>Vue</code> 即根组件 <code>watcher</code> 执行完成即视图更新后，回到 <code>flushSchedulerQueue</code> 里执行刚推入 <code>queue</code> 的第三个 <code>watcher</code>（<code>App</code> 组件的 <code>渲染 watcher</code>）开始进行子组件的更新。</p><p>子组件视图更新结束后，回到 <code>flushSchedulerQueue</code> 执行 <code>callUpdatedHooks</code> 钩子，以倒序方式执行 <code>queue</code> 队列里各 <code>渲染 watcher</code> 对应的组件的 <code>updated</code> 钩子，本例中为 <code>App one updated-&gt;vue updated</code>。</p><p>到此，<code>vue</code> 更新结束，整体生命周期为：<code>vue beforeUpdate -&gt; App one beforeUpdate -&gt; App one updated -&gt; vue updated</code>。</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>本章主要介绍了在得到新 <code>vnode</code> 后，如何与旧 <code>vnode</code> 进行最小化差异更新真实 <code>dom</code>。</li><li>更新 <code>dom</code> 涉及到 3 个方法：<code>patch，patchVnode，updateChildren</code>。其中 <code>updateChildren</code> 为 <code>diff</code> 算法核心。</li><li>对于子组件更新执行 <code>updateChildComponent</code> 方法，若 <code>props</code> 有变化则会重新渲染子组件。根据 <code>slot</code> 情况可能涉及到强制更新组件。</li></ol>]]></content>
      
      
      <categories>
          
          <category> FE Frame </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2.x（含组件）主流程源码笔记（八）：update 阶段（上）</title>
      <link href="399.html"/>
      <url>399.html</url>
      
        <content type="html"><![CDATA[<p>前面七章分析了 <code>vue demo</code> 的整个初始化过程，本文开始分析当数据（<code>model</code>）发生变化时，<code>Vue</code> 的处理过程。</p><p>我们以点击 <code>dom</code> 触发 <code>plus</code> 执行 <code>this.info.age++</code> 为例，分析 <code>Vue</code> 的 <code>update</code> 阶段。</p><h2 id="proxyGetter-amp-amp-proxySetter"><a href="#proxyGetter-amp-amp-proxySetter" class="headerlink" title="proxyGetter &amp;&amp; proxySetter"></a>proxyGetter &amp;&amp; proxySetter</h2><p>此时读取 <code>this.info</code>，则触发在 <code>ininState-&gt;initData-&gt;proxy(vm, &quot;_data&quot;, key)</code> 监听的 <code>proxyGetter</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxy</span>(<span class="params">target, sourceKey, key</span>) </span>&#123;</span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[sourceKey][key];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>[sourceKey][key] = val;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>this</code> 为 <code>Vue</code> 实例，<code>sourceKey</code> 为 <code>_data</code>，即返回 <code>_data</code> 对象里的 <code>key</code>。在读取 <code>key</code> 时，又触发了在 <code>ininState-&gt;initData-&gt;observe-&gt;walk-&gt;defineReactive$$1</code> 里的 <code>reactiveGetter</code>：</p><h2 id="reactiveGetter-amp-amp-reactiveSetter"><a href="#reactiveGetter-amp-amp-reactiveSetter" class="headerlink" title="reactiveGetter &amp;&amp; reactiveSetter"></a>reactiveGetter &amp;&amp; reactiveSetter</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      dep.depend();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">        childOb.dep.depend();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">          dependArray(value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = getter ? getter.call(obj) : val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">      customSetter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getter &amp;&amp; !setter) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">      setter.call(obj, newVal);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      val = newVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">    dep.notify();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>因为此时并非在执行 <code>watcher</code> 的 <code>update</code> 操作， 所以 <code>Dep.target</code> 即 <code>watcher</code> 不存在，直接返回 <code>value</code>。</p><p>然后读取 <code>this.info.age</code>，直接触发 <code>reactiveGetter</code> 返回 <code>value</code>。</p><p>读取阶段结束后，触发 <code>reactiveSetter</code> 来设置 <code>this.info.age</code> 的新值，设置后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">childOb = !shallow &amp;&amp; observe(newVal);</span><br><span class="line">dep.notify();</span><br></pre></td></tr></table></figure><p>对新值进行了监听后，然后通知该变量对应的订阅中心 <code>Dep</code>。</p><h2 id="Dep-prototype-notify"><a href="#Dep-prototype-notify" class="headerlink" title="Dep.prototype.notify"></a>Dep.prototype.notify</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Dep.prototype.notify = <span class="function"><span class="keyword">function</span> <span class="title">notify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> subs = <span class="built_in">this</span>.subs.slice();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">    subs.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> a.id - b.id;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">    subs[i].update();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中，<code>subs</code> 为变量的订阅列表。在本例中，变量 <code>this.info.age</code> 有 3 个订阅者 <code>watcher</code>，分别来自 <code>watch watcher</code>，<code>渲染 watcher</code>，<code>计算 watcher</code>。</p><p>在 <code>notify</code> 里，如果配置了同步，则对订阅列表 <code>subs</code> 按 <code>id</code> 大小进行排序。然后依次触发每项（<code>watcher</code>）的 <code>update</code> 方法。</p><h2 id="Watcher-prototype-update"><a href="#Watcher-prototype-update" class="headerlink" title="Watcher.prototype.update"></a>Watcher.prototype.update</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.update = <span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.lazy) &#123;</span><br><span class="line">    <span class="built_in">this</span>.dirty = <span class="literal">true</span>; <span class="comment">//设置 计算 watcher 的标识位</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sync) &#123;</span><br><span class="line">    <span class="built_in">this</span>.run(); <span class="comment">// 如果设置同步，则立即执行</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queueWatcher(<span class="built_in">this</span>); <span class="comment">//以当前实例为参数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Watcher.prototype.update</code> 主要针对配置的一些处理，然后将当前 <code>watcher</code> 传入 <code>queueWatcher</code>。</p><p>其中 <code>计算 watcher</code> 为懒加载（即 <code>this.lazy</code> 为 <code>true</code>），所以不会执行 <code>queueWatcher</code>，但会将标识位 <code>this.dirty</code> 置为 <code>true</code>。这样计算属性在后面 <code>computedGetter</code> 里取值时，就会通过 <code>Watcher.prototype.evaluate</code> 重新计算而不是直接取缓存值 <code>value</code>，并且还会将标识位 <code>this.dirty</code> 置为 <code>false</code>，这样在后续如果没有计算属性对应的表达式里的被监听的其他值更新触发计算属性 <code>watcher</code> 更新的情况下，就可以直接取 <code>value</code> 值了。</p><h2 id="queueWatcher"><a href="#queueWatcher" class="headerlink" title="queueWatcher"></a>queueWatcher</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span>(<span class="params">watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> id = watcher.id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span>; <span class="comment">// 防止同一时刻同一 watcher 的多次 push</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.push(watcher); <span class="comment">//是否在执行 flushSchedulerQueue</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if already flushing, splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="keyword">var</span> i = queue.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher);</span><br><span class="line">    &#125; <span class="comment">// queue the flush</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span>; <span class="comment">// 防止多次 nextTick，即防止多次注册新的微任务队列</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">true</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">        flushSchedulerQueue();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      nextTick(flushSchedulerQueue); <span class="comment">//将 flushSchedulerQueue 函数传入 nextTick</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>has</code> 为一个对象，用于过滤同一个 <code>watcher</code> 的同时间多次调用 <code>update</code></li><li><code>queue</code> 为一个数组，用于存放等待更新的 <code>watcher</code> 队列</li><li><code>flushing</code> 为一个布尔值，用于标识队列是否正在执行更新，直到 <code>queue</code> 执行完后才重置为 <code>false</code></li><li><code>flushSchedulerQueue</code> 为更新队列的执行函数</li><li><code>waiting</code> 为一个布尔值，用于标识已经把 <code>flushSchedulerQueue</code> 注册到下一次微循环的任务队列中，直到 <code>queue</code> 执行完后才重置为 <code>false</code></li></ul><p><code>queueWatcher</code> 里主要将当前实例 <code>Watcher</code> <code>push</code> 到 <code>queue</code> 即 <code>watcher</code> 队列里，然后将 <code>flushSchedulerQueue</code> 传入 <code>nextTick</code> 方法。</p><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">cb, ctx</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _resolve;</span><br><span class="line">  <span class="comment">// callbacks 保存异步执行的任务队列</span></span><br><span class="line">  callbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span>;</span><br><span class="line">    timerFunc();</span><br><span class="line">  &#125; <span class="comment">// $flow-disable-line</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      _resolve = resolve;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nextTick</code> 里对异步执行的任务队列 <code>cb</code> 统一收集到 <code>callbacks</code> 数组（ <code>flushSchedulerQueue</code> 为其中一项），然后执行 <code>timerFunc</code>。</p><p><code>timerFunc</code> 里通过异步执行 <code>flushCallbacks</code>。异步方法的选用优先级：<code>Promise.resolve().then</code>&gt;<code>MutationObserver</code>&gt;<code>setImmediate</code>&gt;<code>setTimeout</code>，前两个属于 <code>microTask</code> 微任务队列，后两个属于 <code>macroTask</code> 宏任务队列。</p><p>执行 <code>nextTick(flushSchedulerQueue)</code>后，进入异步等待，此时回到 <code>Dep.prototype.notify</code> 里执行下一个 <code>watcher</code> 的 <code>update</code> 把 <code>watcher</code> <code>push</code> 到 <code>queue</code> 里。</p><p>待到异步调用后，执行 <code>flushCallbacks</code>，该方法里遍历 <code>callbacks</code> 并执行。</p><h3 id="为什么要这么做"><a href="#为什么要这么做" class="headerlink" title="为什么要这么做"></a>为什么要这么做</h3><p>如果没有异步队列，则每一次的数据变化时，就会直接触发 <code>update-&gt;patch</code> 去比较 <code>vnode</code> 进行更新 <code>dom</code>，如果在同一时间有大量修改数据（<code>watcher</code> 被多次触发），则会反复频繁更新视图。而有了这个队列，在当前栈可以先判断 <code>watcher</code> 的重复性，过滤掉重复更新。保证更新视图操作 <code>DOM</code> 的动作是在当前栈执行完以后的下一个事件循环 <code>tick</code> 的时候调用，大大优化了性能。</p><h2 id="flushSchedulerQueue"><a href="#flushSchedulerQueue" class="headerlink" title="flushSchedulerQueue"></a>flushSchedulerQueue</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  currentFlushTimestamp = getNow();</span><br><span class="line">  flushing = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">var</span> watcher, id;</span><br><span class="line"></span><br><span class="line">  queue.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.id - b.id;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class="line">    watcher = queue[index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (watcher.before) &#123;</span><br><span class="line">      watcher.before();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    id = watcher.id;</span><br><span class="line">    has[id] = <span class="literal">null</span>;</span><br><span class="line">    watcher.run(); <span class="comment">// in dev build, check and stop circular updates.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">true</span> &amp;&amp; has[id] != <span class="literal">null</span>) &#123;</span><br><span class="line">      circular[id] = (circular[id] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (circular[id] &gt; MAX_UPDATE_COUNT) &#123;</span><br><span class="line">        warn(<span class="string">&#x27;You may have an infinite update loop &#x27;</span> + (watcher.user ? <span class="string">&#x27;in watcher with expression &quot;&#x27;</span> + watcher.expression + <span class="string">&#x27;&quot;&#x27;</span> : <span class="string">&#x27;in a component render function.&#x27;</span>), watcher.vm);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="comment">// keep copies of post queues before resetting state</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> activatedQueue = activatedChildren.slice();</span><br><span class="line">  <span class="keyword">var</span> updatedQueue = queue.slice();</span><br><span class="line">  resetSchedulerState(); <span class="comment">// call component updated and activated hooks</span></span><br><span class="line"></span><br><span class="line">  callActivatedHooks(activatedQueue);</span><br><span class="line">  callUpdatedHooks(updatedQueue); <span class="comment">// devtool hook</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (devtools &amp;&amp; config.devtools) &#123;</span><br><span class="line">    devtools.emit(<span class="string">&#x27;flush&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于本例，<code>queue</code> 里目前有两个 <code>watcher</code>： <code>watch watcher</code>，<code>渲染 watcher</code>。<code>flushSchedulerQueue</code> 里先对 <code>queue</code> 排序：</p><ul><li>组件的更新是由父到子的（因为父组件的创建在子组件之前），所以 <code>watcher</code> 的创建和执顺序行也应该是先父后子</li><li>用户自定义 <code>watcher</code> 应该在 <code>渲染 watcher</code> 之前执行（因为用户自定义 <code>watcher</code> 的创建在 <code>渲染 watcher</code> 之前）</li><li>如果一个组件在父组件的 <code>watcher</code> 执行期间被销毁，那么这个子组件的 <code>watcher</code> 都可以被跳过（<code>this.active</code> 标识）。</li></ul><p>然后执行 <code>queue</code> 队列中的每一个 <code>watcher</code> 的 <code>watcher.before</code> <strong>触发生命周期 <code>beforeUpdate</code> 钩子</strong>。然后执行 <code>watcher.run()</code>，下文分析。</p><p>执行结束后，调用 <code>resetSchedulerState</code> 重置状态，调用 <code>callActivatedHooks</code> 改变组件为 <code>activated</code> 状态并触发生命周期 <code>activated</code> 钩子，调用 <code>callUpdatedHooks</code> 触发生命周期 <code>update</code> 钩子，最后触发工具的 <code>flush</code> 事件，整个流程执行结束。</p><h2 id="Watcher-prototype-run"><a href="#Watcher-prototype-run" class="headerlink" title="Watcher.prototype.run"></a>Watcher.prototype.run</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.run = <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.active) &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="built_in">this</span>.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value !== <span class="built_in">this</span>.value || isObject(value) || <span class="built_in">this</span>.deep) &#123;</span><br><span class="line">      <span class="comment">// set new value</span></span><br><span class="line">      <span class="keyword">var</span> oldValue = <span class="built_in">this</span>.value;</span><br><span class="line">      <span class="built_in">this</span>.value = value;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, value, oldValue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          handleError(e, <span class="built_in">this</span>.vm, <span class="string">&#x27;callback for watcher &quot;&#x27;</span> + <span class="built_in">this</span>.expression + <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, value, oldValue);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>this.active</code> 用于标识该 <code>watcher</code> 是否已经被卸载。在 <code>Watcher.prototype.teardown</code> 里设置为 <code>false</code>（已卸载）。</p><p><code>Watcher.prototype.run</code> 执行 <code>this.get</code> 得到 <code>value</code> 赋给 <code>this.value</code>。然后更新 <code>watcher</code> 的 <code>value</code> 值。如果 <code>this.user</code> 为真这表示为用户定义的 <code>watch</code>，则执行 <code>cb</code> 即用户定义的回调方法，<code>watch watcher</code> 就会触发该回调。</p><h2 id="Watcher-prototype-get"><a href="#Watcher-prototype-get" class="headerlink" title="Watcher.prototype.get"></a>Watcher.prototype.get</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Watcher.prototype.get = <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  pushTarget(<span class="built_in">this</span>);</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line">  <span class="keyword">var</span> vm = <span class="built_in">this</span>.vm;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    value = <span class="built_in">this</span>.getter.call(vm, vm);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">      handleError(e, vm, <span class="string">&#x27;getter for watcher &quot;&#x27;</span> + <span class="built_in">this</span>.expression + <span class="string">&#x27;&quot;&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.deep) &#123;</span><br><span class="line">      traverse(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    popTarget();</span><br><span class="line">    <span class="built_in">this</span>.cleanupDeps();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Watcher.prototype.get</code> 里主要是通过 <code>this.getter</code> 得到 <code>value</code>。</p><p>先将本 <code>watcher</code> 推入全局变量 <code>Dep.target</code> 下，在添加订阅结束后，移除在 <code>Dep.target</code> 下的 <code>watcher</code>。</p><p>如果设置了 <code>deep</code> 为 <code>true</code>，那么执行 <code>traverse</code> 里递归执行 <code>_traverse</code> 读取对象里的每一项子属性给他们添加本 <code>watcher</code> 订阅。</p><ul><li><p>其中对于 <code>computed watcher</code> 的 <code>getter</code> 为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> watcher = <span class="built_in">this</span>._computedWatchers &amp;&amp; <span class="built_in">this</span>._computedWatchers[key];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">    <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">      watcher.evaluate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      watcher.depend();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> watcher.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>如果 <code>dirty</code> 为 <code>true</code>，则触发重新计算 <code>computed</code>，否则直接取 <code>value</code>。</p></li><li><p>其中对于 <code>watch watcher</code> 的 <code>getter</code> 为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; segments.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    obj = obj[segments[i]];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>在读取 <code>obj[segments[i]]</code> 时，会触发属性 <code>info</code> 的 <code>proxyGetter -&gt; reactiveGetter</code> ，在得到最新值的同时，将该 <code>watch watcher</code> 添加到对应的订阅列表，并且因为 <code>info</code> 是对象，所以还添加到 <code>info.__ob__</code> 上。</p></li><li><p>其中对于 <code>渲染 watcher</code> 的 <code>getter</code> 为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updateComponent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  vm._update(vm._render(), hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>vm._render</code> 会根据 <code>render</code> 函数得到 <code>vnode</code>。在执行 <code>render</code> 的过程中，读取到的每一个变量都会触发其对应的 <code>proxyGetter-&gt;reactiveGetter</code> 取得最新值和该 <code>渲染 watcher</code> 订阅到对应变量的订阅列表里。得到 <code>vnode</code> 后，然后执行 <code>vm._update</code> 更新视图，下一章分析。</p></li></ul><p>最后执行 <code>cleanupDeps</code> 方法通过对比新旧 <code>depIds</code> 来删除无效的订阅 <code>sub</code> ，最后返回 <code>value</code>，回到 <code>flushSchedulerQueue</code> 方法里。</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>本章以一个数据更新为始，分析了对数据的添加订阅和触发订阅的相关逻辑。</li><li>一共涉及到 3 个 <code>watcher</code>：分别是 <code>watch watcher</code>，<code>渲染 watcher</code>，<code>计算 watcher</code>，对不同 <code>watcher</code> 进行了不同的处理。</li><li>触发订阅涉及到了异步队列优化，优化了不必要的视图更新，大大提升了性能。</li></ol>]]></content>
      
      
      <categories>
          
          <category> FE Frame </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2.x（含组件）主流程源码笔记（七）：mount 阶段之生成 dom</title>
      <link href="398.html"/>
      <url>398.html</url>
      
        <content type="html"><![CDATA[<h2 id="vnode-渲染为真实-dom"><a href="#vnode-渲染为真实-dom" class="headerlink" title="vnode 渲染为真实 dom"></a>vnode 渲染为真实 dom</h2><p>接上文，<code>vm._render</code> 通过 <code>render</code> 生成 <code>vnode</code> 后，然后执行 <code>vm._update(vm._render(),hydrating)</code> 来首次渲染成真实 <code>dom</code>，里面执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">  <span class="comment">// initial render</span></span><br><span class="line">  vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// updates</span></span><br><span class="line">  vm.$el = vm.__patch__(prevVnode, vnode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处为初始渲染，执行第一个分支 <code>vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);</code> 即执行 <code>patch</code>。</p><p><code>patch</code> 中因为 <code>oldVnode</code> 即 <code>vm.$el</code> 是真实节点，则 <code>oldVnode</code> 替换为空 <code>vnode</code>，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createElm(vnode, insertedVnodeQueue, oldElm._leaveCb ? <span class="literal">null</span> : parentElm, nodeOps.nextSibling(oldElm));</span><br></pre></td></tr></table></figure><h3 id="createElm"><a href="#createElm" class="headerlink" title="createElm"></a>createElm</h3><p><code>createElm</code> 主要逻辑：</p><ul><li>是组件 <code>vnode</code>，则在 <code>createComponent</code> 处理</li><li>不是组件 <code>vnode</code><ul><li>是元素节点的 <code>vnode</code>，则创建该标签并设置 <code>css scope</code>，然后通过 <code>createChildren</code> 循环构建子 <code>vnode</code>，然后触发 <code>invokeCreateHooks</code> 处理标签的属性</li><li>是注释节点的 <code>vnode</code>，则创建注释节点</li><li>其他情况就创建文件节点</li><li>最后将创建的真实节点插入到根节点里</li></ul></li></ul><h3 id="createChildren"><a href="#createChildren" class="headerlink" title="createChildren"></a>createChildren</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createChildren(vnode, children, insertedVnodeQueue);</span><br></pre></td></tr></table></figure><p><code>createChildren</code> 标志开始构建子 <code>vnode</code>。方法里先通过 <code>checkDuplicateKeys</code> 检查 <code>key</code> 是否重复，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; children.length; ++i) &#123;</span><br><span class="line">  createElm(children[i], insertedVnodeQueue, vnode.elm, <span class="literal">null</span>, <span class="literal">true</span>, children, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即递归对每一个子 <code>vnode</code> 执行 <code>createElm</code>。</p><h3 id="invokeCreateHooks"><a href="#invokeCreateHooks" class="headerlink" title="invokeCreateHooks"></a>invokeCreateHooks</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">  <span class="comment">// `data` 为：`&#123;ref: &quot;btn&quot;, staticClass: &quot;side&quot;, on: &#123;click: ƒ&#125;&#125;`。</span></span><br><span class="line">  invokeCreateHooks(vnode, insertedVnodeQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>invokeCreateHooks</code> 处理该 <code>vnode</code> 上的 <code>data</code> 属性，里循环调用 <code>cbs.create</code> 数组里的 8 个方法如 <code>updateAttrs，updateClass，updateDOMListeners</code> 等，做一些 <code>style，class，event，$refs</code> 等相关的处理。如果是组件 <code>vnode</code> 且有 <code>insert</code> 方法则将该组件 <code>vnode</code> <code>push</code> 到 <code>insertedVnodeQueue</code>。</p><p><code>insertedVnodeQueue</code> 记录子节点组件创建顺序的队列。每创建一个组件实例就会往这个队列中插入当前的组件节点 <code>VNode</code>, 当整个 <code>VNode</code> 对象全部转换成为真实的 <code>DOM</code> 树时，会依次调用这个队列中的 <code>VNode hook</code> 的 <code>insert</code> 方法。</p><h3 id="invokeInsertHook"><a href="#invokeInsertHook" class="headerlink" title="invokeInsertHook"></a>invokeInsertHook</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeInsertHook</span>(<span class="params">vnode, queue, initial</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isTrue(initial) &amp;&amp; isDef(vnode.parent)) &#123;</span><br><span class="line">    vnode.parent.data.pendingInsert = queue;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; queue.length; ++i) &#123;</span><br><span class="line">      queue[i].data.hook.insert(queue[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暂时不考虑服务端渲染，<code>invokeInsertHook</code> 钩子在 <code>patch</code> 方法的最后执行。如果是新建的组件实例 <code>vnode</code>（如未挂载、组件实例）且有父 <code>vnode</code>，则将 <code>queue</code> 即之前的 <code>insertedVnodeQueue</code> 队列存到父 <code>vnode</code> 上的 <code>data.pendingInsert</code> 上，在 <code>initComponent</code> 时，会把其 <code>push</code> 到 <code>insertedVnodeQueue</code>。</p><p>如果不是，则就依次调用每个组件 <code>vnode</code> 的 <code>insert</code> 方法，如果组件还未 <code>mounted</code>，则触发 <code>mounted</code> 钩子，如果是 <code>keepAlive</code> 包裹的组件，则执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (vnode.data.keepAlive) &#123;</span><br><span class="line">  <span class="keyword">if</span> (context._isMounted) &#123;</span><br><span class="line">    <span class="comment">//已装载好，说明在更新，将 componentInstance push 到 activatedChildren</span></span><br><span class="line">    <span class="comment">//后面组件更新结束后，在 flushSchedulerQueue 执行 callActivatedHooks，即遍历整个activatedChildren队列 执行 activateChildComponent</span></span><br><span class="line">    queueActivatedComponent(componentInstance);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//触发子元素的 activated 钩子和自己的 activated 钩子。同理，keep-alive 的 deactivated 钩子原理一致</span></span><br><span class="line">    activateChildComponent(componentInstance, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="分析-demo"><a href="#分析-demo" class="headerlink" title="分析 demo"></a>分析 demo</h3><p>对于本例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 节点 1 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Bpp</span>&gt;</span><span class="tag">&lt;/<span class="name">Bpp</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 节点 2 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click</span>=<span class="string">&quot;plus&quot;</span>&gt;</span>info.name:&#123;&#123;info.name&#125;&#125;，计算属性:&#123;&#123;compute&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 节点 3 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">App</span> <span class="attr">name</span>=<span class="string">&quot;one&quot;</span> <span class="attr">v-bind:num</span>=<span class="string">&quot;info.age&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">App</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 节点 4 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click</span>=<span class="string">&quot;hide&quot;</span>&gt;</span>====点击让第二个App组件卸载====<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 节点 5 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">App</span> <span class="attr">name</span>=<span class="string">&quot;two&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">App</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除开 4 个空节点和一个异步组件占位的空注释节点，还有 4 个子节点。</p><p>接下来逐个分析创建流程：</p><ol><li>创建 4 个空节点，即在 <code>createElm</code> 里直接执行 <code>createTextNode</code> 生成空的文本节点后插入到对应的位置,下面的节点分析将略过空节点；</li><li>创建第一个节点（称为节点 1，下一个就为节点 2，以此类推）异步占位节点，即在 <code>createElm</code> 里直接执行 <code>createComment</code> 生成空的注释节点后插入到对应的位置；</li><li>创建节点 2，同前面逻辑一样走 <code>createElm -&gt; createChildren -&gt; createElm -&gt; createChildren ···</code>，递归执行 <code>createElm</code> 判断到 <code>tag</code> 为空，则执行 <code>createTextNode</code> 创建文本节点 <code>info.name:korey，计算属性:29</code> 并调 <code>insert</code> 插入到父节点。然后回到节点 2 的 <code>createElm</code> 继续执行 <code>invokeCreateHooks</code>，然后调 <code>insert</code> 插入到父节点即根组件的 <code>div</code>，此时生成的 <code>dom</code> 节点都赋值在各自 <code>vnode.elm</code> 下；</li><li>创建节点 3，<code>vnode</code> 为 <code>App</code> 组件节点，在 <code>createElm</code> 里走 <code>createComponent</code> 方法。下面单独分析；</li><li>创建节点 4，与节点 2 一致；</li><li>创建节点 5，与节点 3 一致；</li></ol><h2 id="组件-vnode-渲染为真实-dom"><a href="#组件-vnode-渲染为真实-dom" class="headerlink" title="组件 vnode 渲染为真实 dom"></a>组件 vnode 渲染为真实 dom</h2><p>组件节点在 <code>createElm</code> 里走 <code>createComponent</code>。因为组件 <code>vnode.data</code> 有 <code>hook.init</code> 等渲染 <code>vnode</code> 时安装的钩子函数，故执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i(vnode, <span class="literal">false</span> <span class="comment">/* hydrating */</span>); <span class="comment">//其中 i 为 componentVNodeHooks.init</span></span><br></pre></td></tr></table></figure><h3 id="实例化子组件"><a href="#实例化子组件" class="headerlink" title="实例化子组件"></a>实例化子组件</h3><p>执行 <code>componentVNodeHooks.init</code>，方法里先判断如果存在已被 <code>keep-alive</code> 缓存的组件实例 <code>vnode.componentInstance</code>，则调用 <code>componentVNodeHooks.prepatch</code> 直接 <code>updateChildComponent</code> 更新子组件实例即可，就不用去初始化和装载子组件，即不会走一系列常规生命周期钩子。否则执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = (vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance));</span><br></pre></td></tr></table></figure><p><code>createComponentInstanceForVnode</code> 用于创建 <code>component</code> 实例。</p><p>方法里执行：<code>new vnode.componentOptions.Ctor(options)</code>，即实例化 <code>VueComponent</code>，内部执行 <code>this._init(options)</code> 即原型链上的 <code>Vue</code> 的方法 <code>_init</code>，到此，<code>App</code> 子组件开始走 <code>vue</code> 的 <code>init</code> 流程（具体与 <code>Vue</code> 实例化差异可以参考第一章分析），触发 <code>App beforeCreate 钩子-&gt;App created 钩子</code>，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">  vm.$mount(vm.$options.el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因 <code>vm.$options.el</code> 不存在，所以子组件的 <code>_init</code> 的执行结束（即子组件实例化完成），将子组件实例赋给 <code>vnode.componentInstance</code> 即 <code>child</code>。</p><h3 id="构建子组件"><a href="#构建子组件" class="headerlink" title="构建子组件"></a>构建子组件</h3><p>回到 <code>componentVNodeHooks.init</code> 继续执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">child.$mount(hydrating ? vnode.elm : <span class="literal">undefined</span>, hydrating);</span><br></pre></td></tr></table></figure><p>执行 <code>child.$mount</code> 即原型链上的 <code>Vue</code> 的方法 <code>$mount</code>。因为存在 <code>render</code>，故触发 <code>App beforeMount 钩子</code> 后，直接进入 <code>mount</code> 阶段。</p><p>前面已分析，在实例化 <code>渲染 watcher</code> 里触发 <code>updateComponent</code> 先执行 <code>vm._render</code> 生成 <code>vnode</code>：</p><h4 id="子组件-render-函数"><a href="#子组件-render-函数" class="headerlink" title="子组件 render 函数"></a>子组件 render 函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _vm = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">var</span> _h = _vm.$createElement;</span><br><span class="line">  <span class="keyword">var</span> _c = _vm._self._c || _h;</span><br><span class="line">  <span class="keyword">return</span> _c(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">id</span>: <span class="string">&#x27;app&#x27;</span> &#125; &#125;, [_c(<span class="string">&#x27;div&#x27;</span>, [_vm._v(_vm._s(_vm.num ? <span class="string">&#x27;num:&#x27;</span> + _vm.num : <span class="string">&#x27;&#x27;</span>))]), _vm._v(<span class="string">&#x27; &#x27;</span>), _c(<span class="string">&#x27;Child&#x27;</span>, &#123; <span class="attr">staticClass</span>: <span class="string">&#x27;example&#x27;</span> &#125;)], <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>生成 <code>vnode</code> 后，执行 <code>vm._update</code> 渲染成真实 <code>dom</code>。在 <code>patch</code> 方法里，由于 <code>oldVnode</code> 即 <code>vm.$el</code> 不存在，执行 <code>createElm-&gt;createChildren-&gt;··</code> 递归生成每一个 <code>vnode</code> 及其子 <code>vnode</code> 对应的真实 <code>dom</code>。</p><h3 id="构建孙组件"><a href="#构建孙组件" class="headerlink" title="构建孙组件"></a>构建孙组件</h3><p>在子组件 <code>App</code> 的 <code>render</code> 函数里，创建孙组件 <code>Child</code>。与子组件流程一致，他同样会经历 <code>App</code> 组件的构建逻辑（触发 <code>Child beforeCreate-&gt;Child created-&gt;Child beforeMount</code> 钩子），执行 <code>vm._update</code> 渲染成真实 <code>dom</code>， 通过 <code>createElm-&gt;createChildren-&gt;··</code> 递归在其各层 <code>vnode</code> 里得到对应的 <code>vnode.elm</code>。</p><p>在孙组件 <code>Child</code> 里的根节点时（<code>createElm</code> 里），由于没有父节点 <code>parentElm</code>，所以执行 <code>insert</code> 时，不会插入节点。</p><p>然后回到 <code>patch</code> 触发 <code>invokeInsertHook</code>（此时不存在 <code>insertedVnodeQueue</code>），然后返回 <code>vnode.elm</code>（<code>vnode</code> 为 <code>Child</code> 组件根 <code>vnode</code>） 赋给 <code>vm.$el</code>（<code>vm</code> 为 <code>Child</code> 组件实例）。回到 <code>mountComponent</code> 中返回孙组件实例， <code>Child</code> 构建完毕。</p><h2 id="真实-dom-插入到文档"><a href="#真实-dom-插入到文档" class="headerlink" title="真实 dom 插入到文档"></a>真实 dom 插入到文档</h2><h3 id="孙组件-dom-插入到子组件-dom"><a href="#孙组件-dom-插入到子组件-dom" class="headerlink" title="孙组件 dom 插入到子组件 dom"></a>孙组件 dom 插入到子组件 dom</h3><p>回到 <code>createComponent</code> 方法里继续执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isDef(vnode.componentInstance)) &#123;</span><br><span class="line">  initComponent(vnode, insertedVnodeQueue);</span><br><span class="line">  insert(parentElm, vnode.elm, refElm);</span><br><span class="line">  <span class="keyword">if</span> (isTrue(isReactivated)) &#123;</span><br><span class="line">    reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="initComponent"><a href="#initComponent" class="headerlink" title="initComponent"></a>initComponent</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComponent</span>(<span class="params">vnode, insertedVnodeQueue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isDef(vnode.data.pendingInsert)) &#123;</span><br><span class="line">    insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);</span><br><span class="line">    vnode.data.pendingInsert = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vnode.elm = vnode.componentInstance.$el;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isPatchable(vnode)) &#123;</span><br><span class="line">    invokeCreateHooks(vnode, insertedVnodeQueue);</span><br><span class="line">    setScope(vnode);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    registerRef(vnode); <span class="comment">// make sure to invoke the insert hook</span></span><br><span class="line"></span><br><span class="line">    insertedVnodeQueue.push(vnode);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>initComponent</code> 里, <code>vnode</code> 为 <code>Child</code> 组件 <code>vnode</code>。若<code>vnode.data.pendingInsert</code> 存在（存在说明有子组件 <code>vnode</code> <code>push</code> 进入）则与 <code>insertedVnodeQueue</code> 合并，然后将 <code>Child</code> 组件实例生成的真实 <code>dom</code> 节点 <code>vnode.componentInstance.$el</code> 赋给 <code>Child</code> 组件 <code>vnode.elm</code> 上。</p><p>然后判断如果 <code>Child</code> 组件实例 <code>vnode</code> 有标签，则执行 <code>invokeCreateHooks</code>（此处会把 <code>Child</code> 组件 <code>vnode</code> <code>push</code> 到 <code>insertedVnodeQueue</code>）和 <code>setScope</code>。</p><p><code>initComponent</code> 执行完成后，此时调用 <code>insert</code> 将 <code>vnode.elm</code> 插入到 <code>App</code> 组件对应的 <code>dom</code> 上。到此 <code>Child</code> 孙组件渲染结束。</p><h3 id="子组件-dom-插入到根组件-dom"><a href="#子组件-dom-插入到根组件-dom" class="headerlink" title="子组件 dom 插入到根组件 dom"></a>子组件 dom 插入到根组件 dom</h3><p>父级即 <code>App</code> 组件的 <code>children</code> 渲染循环也结束，然后回到 <code>patch</code> 触发 <code>invokeInsertHook</code> 将 <code>insertedVnodeQueue</code> 存入 <code>vnode.parent.data.pendingInsert</code>，然后返回 <code>vnode.elm</code>（<code>vnode</code> 为 <code>App</code> 组件根 <code>vnode</code>） 赋给 <code>vm.$el</code>（<code>vm</code> 为 <code>App</code> 组件实例）。回到 <code>mountComponent</code> 中返回子组件实例， <code>App</code> 构建完毕。</p><p>同 <code>Child</code> 的流程一致，回到 <code>createComponent</code> 方法执行了 <code>initComponent</code> 后，此时调用 <code>insert</code> 将 <code>vnode.elm</code> 插入到根组件对应的 <code>dom</code> 上。到此，<code>App</code> 组件渲染结束。</p><h2 id="整体生命周期"><a href="#整体生命周期" class="headerlink" title="整体生命周期"></a>整体生命周期</h2><p>根组件下的 <code>createChildren</code> 里继续循环 <code>createElm</code>，遇到下一个 <code>App</code> 组件的构建 <code>dom</code> 跟之前的逻辑一样，其中构造函数复用。</p><p>待到根组件的 <code>createChildren</code> 里渲染循环也结束，在 <code>createElm</code> 里因为有 <code>parentElm</code> 为 <code>body</code> 节点，所以执行 <code>insert</code> 将整个父组件 <code>vnode.elm</code> 插入到 <code>body</code> 元素中。</p><p>回到 <code>patch</code> 方法里继续执行，删掉老的 <code>dom</code> 节点，然后触发 <code>invokeInsertHook</code>，此时 <code>insertedVnodeQueue</code> 里包含之前按顺序 <code>push</code> 进去的 4 个组件 <code>vnode</code>：</p><ol><li>第一个孙组件 <code>Child</code></li><li>第一个子组件 <code>App</code></li><li>第二个孙组件 <code>Child</code></li><li>第二个子组件 <code>App</code></li></ol><p>循环依次执行 <code>insert</code> 钩子，方法里会触发各组件生命周期钩子：<code>mounted</code>。</p><p>然后 <code>patch</code> 方法返回 <code>vnode.elm</code> 赋给根实例 <code>vm.$el</code>, <code>vm._update</code> 执行结束，实例化渲染 <code>watcher</code> 亦结束。</p><p>然后回到 <code>mountComponent</code> 继续执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, <span class="string">&#x27;mounted&#x27;</span>);</span><br></pre></td></tr></table></figure><p>触发生命周期钩子 <code>mounted</code>。在这之后，异步组件才加载结束，开始构建异步组件的生命周期（上一篇文章的异步组件第二阶段已分析），构建完成后，<code>Vue</code> 初始化全部完成。</p><p>整个过程中，生命周期顺序为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开始加载 Vue ↓↓</span></span><br><span class="line">vue beforeCreate</span><br><span class="line">vue created</span><br><span class="line">vue beforeMount</span><br><span class="line"><span class="comment">// 开始加载第一个 App 组件 ↓↓</span></span><br><span class="line">App beforeCreate</span><br><span class="line">App one created</span><br><span class="line">App one beforeMount</span><br><span class="line"><span class="comment">// 开始加载第一个 App 内的 Child 组件 ↓↓</span></span><br><span class="line">Child beforeCreate</span><br><span class="line">Child created</span><br><span class="line">Child beforeMount</span><br><span class="line"><span class="comment">// 开始加载第二个 App 组件 ↓↓</span></span><br><span class="line">App beforeCreate</span><br><span class="line">App two created</span><br><span class="line">App two beforeMount</span><br><span class="line"><span class="comment">// 开始加载第二个 App 内的 Child 组件 ↓↓</span></span><br><span class="line">Child beforeCreate</span><br><span class="line">Child created</span><br><span class="line">Child beforeMount</span><br><span class="line"><span class="comment">// 调用 invokeInsertHook 依次触发各组件 mounted</span></span><br><span class="line"><span class="comment">// 第一个 App 内的 Child 组件 ↓↓</span></span><br><span class="line">Child mounted</span><br><span class="line"><span class="comment">// 第一个 App 组件 ↓↓</span></span><br><span class="line">App one mounted</span><br><span class="line"><span class="comment">// 第二个 App 内的 Child 组件 ↓↓</span></span><br><span class="line">Child mounted</span><br><span class="line"><span class="comment">// 第二个 App 组件 ↓↓</span></span><br><span class="line">App two mounted</span><br><span class="line"><span class="comment">// Vue加载完成 ↓↓</span></span><br><span class="line">vue mounted</span><br><span class="line"><span class="comment">// 开始加载异步 Bpp 组件 ↓↓</span></span><br><span class="line">vue beforeUpdate</span><br><span class="line"><span class="keyword">async</span> Bpp beforeCreate</span><br><span class="line"><span class="keyword">async</span> Bpp created</span><br><span class="line"><span class="keyword">async</span> Bpp beforeMount</span><br><span class="line"><span class="keyword">async</span> Bpp mounted</span><br><span class="line">vue updated</span><br></pre></td></tr></table></figure><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>本章介绍了 <code>vue</code> 执行的 <code>Mount</code> 阶段中的通过 <code>vnode</code> 渲染为真实 <code>dom</code> 部分。</li><li>同时分析了组件里子组件，孙组件的渲染过程以及如何将渲染结果 <code>dom</code> 添加到对应的组件 <code>vnode</code> 上。</li><li>分析了 <code>Vue</code> 的整体生命周期。</li></ol>]]></content>
      
      
      <categories>
          
          <category> FE Frame </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2.x（含组件）主流程源码笔记（六）：mount 阶段之生成 vnode</title>
      <link href="397.html"/>
      <url>397.html</url>
      
        <content type="html"><![CDATA[<p>接上文，在触发生命周期钩子 <code>beforeMount</code> 后，执行：</p><h2 id="实例化-渲染-watcher"><a href="#实例化-渲染-watcher" class="headerlink" title="实例化 渲染 watcher"></a>实例化 渲染 watcher</h2><p>然后根据 <code>config.performance</code> 及 <code>mark</code> 是否存在，得到不同的 <code>updateComponent</code>，此处为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updateComponent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  vm._update(vm._render(), hydrating);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后实例化 <code>渲染 watcher</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Watcher(</span><br><span class="line">  vm,</span><br><span class="line">  updateComponent,</span><br><span class="line">  noop,</span><br><span class="line">  &#123;</span><br><span class="line">    before: <span class="function"><span class="keyword">function</span> <span class="title">before</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">        callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">true</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>渲染 watcher</code> 会触发 <code>render</code> 渲染 <code>vnode</code>，在渲染过程中，<code>get</code> 过程中，涉及到的所有变量都会添加此 <code>watcher</code> 作为订阅者。也就意味着在任一变量发生变化都会通知此 <code>watcher</code> 执行 <code>updateComponent</code> 方法。</p><p>前面已知，在实例化 <code>Watcher</code> 的过程中，会执行 <code>this.get -&gt; this.getter</code> 去获取当前 <code>value</code>。此时执行的 <code>this.getter</code> 即为 <code>updateComponent</code>。所以得知实例化 <code>渲染 watcher</code> 分两步：</p><ol><li>执行 <code>vm._render</code> 将 <code>render</code> 转化为 <code>vnode</code>，在 <code>render</code> 的过程中，读取到的所有变量都会触发对应的 <code>get</code> 将本 <code>渲染 watcher</code> 加入订阅，也就意味着在任一变量发生变化都会通知此 <code>渲染watcher</code> 执行 <code>updateComponent</code>；</li><li>执行 <code>vm._update</code> 将 得到的新 <code>vnode</code> 与旧 <code>vnode</code> 比较，最小差异的更新真实 <code>dom</code>。</li></ol><h2 id="执行-render-生成-vnode"><a href="#执行-render-生成-vnode" class="headerlink" title="执行 render 生成 vnode"></a>执行 render 生成 vnode</h2><p>先执行 <code>vm._render</code>，内部执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (_parentVnode) &#123;</span><br><span class="line">  vm.$scopedSlots = normalizeScopedSlots(_parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是子组件实例，即 <code>_parentVnode</code> 为父组件 <code>vnode</code>，并将其赋给 <code>vm.$node</code>。然后通过 <code>normalizeScopedSlots</code> 处理了作用域插槽相关。然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnode = render.call(vm._renderProxy, vm.$createElement); <span class="comment">//vm._renderProxy 在 initProxy 定义，vm.$createElement 在 initRender 定义</span></span><br></pre></td></tr></table></figure><p><code>render</code> 为渲染函数，此方法渲染生成返回一个 <strong>virtual dom</strong>。</p><h3 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h3><p><code>Virtual DOM</code> 建立在 <code>DOM</code> 之上，是基于 <code>DOM</code> 的一层抽象，实际可理解为用更轻量的纯 <code>JavaScript</code> 对象（树）描述 <code>DOM</code>（树），通过对比 <code>Virtual DOM</code>，只更新需要更新的 <code>DOM</code> 节点。</p><p>通常情况下，找到两棵任意的树之间最小修改的时间复杂度是 <code>O(n^3)</code>。<code>Virtual DOM</code> 根据前端实际场景，以深度优先，只进行同级比较，复杂度为 <code>O(n)</code>。</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NuYWJiZG9tL3NuYWJiZG9t">snabbdom<i class="fa fa-external-link-alt"></i></span> 就是 <code>Virtual DOM</code> 的一个简洁实现。</p><h3 id="分析-render-函数"><a href="#分析-render-函数" class="headerlink" title="分析 render 函数"></a>分析 <code>render</code> 函数</h3><p><code>demo</code> 编译出的 <code>render</code> 函数为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">anonymous</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">with</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> _c(</span><br><span class="line">      <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">      &#123; <span class="attr">attrs</span>: &#123; <span class="attr">id</span>: <span class="string">&#x27;main&#x27;</span> &#125; &#125;,</span><br><span class="line">      [</span><br><span class="line">        _c(<span class="string">&#x27;bpp&#x27;</span>), <span class="comment">// &lt;Bpp&gt;&lt;/Bpp&gt;</span></span><br><span class="line">        _v(<span class="string">&#x27; &#x27;</span>),</span><br><span class="line">        _c(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">on</span>: &#123; <span class="attr">click</span>: plus &#125; &#125;, [_v(<span class="string">&#x27;info.name:&#x27;</span> + _s(info.name) + <span class="string">&#x27;，计算属性:&#x27;</span> + _s(compute))]), <span class="comment">//&lt;div v-on:click=&quot;plus&quot;&gt;info.name:&#123;&#123;info.name&#125;&#125;，计算属性:&#123;&#123;compute&#125;&#125;&lt;/div&gt;</span></span><br><span class="line">        _v(<span class="string">&#x27; &#x27;</span>),</span><br><span class="line">        _c(<span class="string">&#x27;app&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;one&#x27;</span>, <span class="attr">num</span>: info.age &#125; &#125;), <span class="comment">//&lt;App name=&quot;one&quot; v-bind:num=&quot;info.age&quot;&gt;&lt;/App&gt;</span></span><br><span class="line">        _v(<span class="string">&#x27; &#x27;</span>),</span><br><span class="line">        _c(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">on</span>: &#123; <span class="attr">click</span>: hide &#125; &#125;, [_v(<span class="string">&#x27;====点击让第二个App组件卸载====&#x27;</span>)]), <span class="comment">// &lt;div v-on:click=&quot;hide&quot;&gt;====点击让第二个App组件卸载====&lt;/div&gt;</span></span><br><span class="line">        _v(<span class="string">&#x27; &#x27;</span>),</span><br><span class="line">        isShow ? _c(<span class="string">&#x27;app&#x27;</span>, &#123; <span class="attr">attrs</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;two&#x27;</span> &#125; &#125;) : _e(), <span class="comment">// &lt;App name=&quot;two&quot; v-if=&quot;isShow&quot;&gt;&lt;/App&gt;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="number">1</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上共 9 个子节点，具体的执行 <code>render</code> 中过程不具体分析，只说明其中的一些要点：</p><ul><li><code>_c</code> 返回一个普通 <code>vnode</code>，<code>_v</code> 返回一个文本 <code>vnode</code>，<code>_e</code> 返回一个注释 <code>vnode</code>， <code>_s</code> 返回一个字符串， <code>_l</code> 返回一个 <code>vnode</code> 数组 ， <code>_u</code> 返回 <code>scopedSlots</code> 的 <code>key</code> 和 <code>fn</code> 的键值对，<code>_t</code> 返回 <code>scopedSlot</code> 渲染的插槽 <code>vnode</code>。</li><li>其中读取每一个变量及 <code>_c，_v，_s，_l</code> 等挂载在 <code>vm</code> 下面的方法都会触发 <code>hasHandler</code> 检查。</li><li><strong>读取到 <code>info</code> 等 <code>data</code> 内的属性时触发监听会把这个 <code>watcher</code> 加到各自的 <code>dep</code> 订阅列表里面，并获得最新值。</strong></li><li><code>_s</code> 即 <code>toString</code> 执行 <code>JSON.stringify</code> 得到字符串的过程中，如果变量是对象则会触发该变量及其变量里的每一个属性的 <code>reactiveGetter</code>，即将 <code>渲染 watcher</code> 加到各属性的订阅列表。</li><li>读取到 <code>compute</code> 等计算属性触发监听走的 <code>get</code> 方法为 <code>computedGetter</code>，里面取得他自己之前的 <code>watcher</code>，然后 <code>evaluate</code> 惰性求值执行 <code>compute</code> 函数，执行过程中读取了 <code>info.age</code>，所以将他的 <code>watcher</code> 订阅到 <code>info.age</code> 的订阅列表里，同时也取得了最新的 <code>compute</code> 的值。所以在 <code>info.age</code> 变化时，就会通知该 <code>计算 wather</code> 触发更新即设置标识位 <code>dirty</code> 为 <code>true</code>，继而在通知 <code>渲染 watcher</code> 触发更新时获取 <code>compute</code> 取值时重新计算。</li><li>静态节点的构建会调用 <code>_m</code> 即 <code>renderStatic</code> 方法，根据传入的索引去执行对应的 <code>render</code> 得到 <code>vnode</code>，并增加属性 <code>isStatic,key,isOnce</code>。</li><li>执行到数组渲染方法 <code>_l</code>即 <code>renderList</code>，在方法内部循环对数组执行对应的 <code>render</code> 方法（<code>_l</code> 的第二个方法参数）,最终返回 <code>[VNode, VNode, VNode, _isVList: true]</code>，其中每一项 <code>vnode</code> 下有 <code>key</code> 值和 <code>vnode.data</code> 里多了一个 <code>key</code> 属性。数组会在最后的 <code>_c</code> 方法里 <code>normalizeChildren</code> 拍平。</li><li>读取到 <code>&lt;App&gt;,&lt;Bpp&gt;</code> 等同步异步组件，组件生成 <code>vnode</code> 下面单独说明。</li></ul><h2 id="render-同步组件生成-vnode"><a href="#render-同步组件生成-vnode" class="headerlink" title="render 同步组件生成 vnode"></a>render 同步组件生成 vnode</h2><p>执行 <code>_c(&#39;app&#39;)-&gt;createElement-&gt;_createElement</code>，在 <code>_createElement</code> 里，因为组件名不为保留标签（<code>config.isReservedTag(tag)</code>），所以执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((!data || !data.pre) &amp;&amp; isDef((Ctor = resolveAsset(context.$options, <span class="string">&#x27;components&#x27;</span>, tag)))) &#123;</span><br><span class="line"><span class="comment">// component</span></span><br><span class="line">vnode = createComponent(Ctor, data, context, children, tag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>其中 <code>children</code> 为 插槽 <code>Vnode</code>。</p><p>执行 <code>resolveAsset</code> 方法获取该组件在 <code>$options.components</code> 里对应的的组件上下文对象对应的经过 <code>webpack</code> 编译后包含 <code>render</code> 的组件选项对象，赋给 <code>Ctor</code>。</p><h3 id="构造子类构造函数"><a href="#构造子类构造函数" class="headerlink" title="构造子类构造函数"></a>构造子类构造函数</h3><p>然后执行 <code>createComponent</code> 方法，内部执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isObject(Ctor)) &#123;</span><br><span class="line">  Ctor = baseCtor.extend(Ctor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>baseCtor</code> 即为 <code>Vue</code> 构造函数，<code>extend</code> 即为 <code>Vue.extend</code>。使用基础 <code>Vue</code> 构造器，创建一个“子类”。参数是组件选项对象。</p><p><code>extend</code> 里先读取缓存 <code>Ctor</code> 下的 <code>_Ctor</code>，如果没有，将在构造构造函数结束后将 <code>Ctor</code> 即构造函数存入缓存。 这样在引入多个相同组件的时候，不用重复构造组件的构造函数了。</p><p><code>extend</code> 里通过 <code>validateComponentName</code> 验证组件名之后，继续执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>._init(options);</span><br><span class="line">&#125;;</span><br><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype);</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br><span class="line">Sub.cid = cid++;</span><br><span class="line">Sub.options = mergeOptions(Super.options, extendOptions);</span><br><span class="line">Sub[<span class="string">&#x27;super&#x27;</span>] = Super;</span><br></pre></td></tr></table></figure><p>定义了子类构造函数 <code>Sub</code>，并在 <code>Sub</code> 上设置了相关属性，建立了父组件和本组件之类的继承关系。</p><p>如果组件的 <code>options</code> 里有 <code>props</code> 及 <code>computed</code>，则添加监听挂载到 <code>Sub</code> 的原型即父组件的原型上。 最终返回 <code>Sub</code> 赋给 <code>Ctor</code>，<code>Vue.extend</code> 执行结束。<strong>Ctor 即为 Vue component 子组件构造函数。</strong></p><h3 id="处理属性及安装组件钩子函数"><a href="#处理属性及安装组件钩子函数" class="headerlink" title="处理属性及安装组件钩子函数"></a>处理属性及安装组件钩子函数</h3><p>然后依次判断是否是异步组件 -&gt; 处理 <code>options</code>（通过 <code>resolveConstructorOptions</code>）-&gt; 提取 <code>props</code>（通过 <code>extractPropsFromVNodeData</code>）-&gt; 判断是否是函数组件 -&gt; 提取 <code>listeners</code> 事件 -&gt; 判断是否是 <code>keepAlive/transition</code> 组件，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">installComponentHooks(data);</span><br></pre></td></tr></table></figure><p>安装合并 <code>data</code>（属性）里的组件钩子函数： <code>hooks：init，prepatch，insert，destroy</code>。</p><h3 id="实例化-vnode"><a href="#实例化-vnode" class="headerlink" title="实例化 vnode"></a>实例化 vnode</h3><p>然后一切准备工作结束后，调用 <code>new VNode</code> 方法生成组件 <code>vnode</code>（其中前面生成的 <code>Ctor</code> 挂载在 <code>vnode.componentOptions</code> 上，并且组件的 <code>vnode</code> 是没有 <code>children</code> 的，插槽 <code>children</code> 保存在了 <code>componentOptions</code> 上 ）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  tag: <span class="string">&quot;vue-component-1-app&quot;</span></span><br><span class="line">  data: &#123;<span class="attr">attrs</span>: &#123;…&#125;, <span class="attr">on</span>: <span class="literal">undefined</span>, <span class="attr">hook</span>: &#123;…&#125;&#125;</span><br><span class="line">  children: <span class="literal">undefined</span></span><br><span class="line">  text: <span class="literal">undefined</span></span><br><span class="line">  elm: <span class="literal">undefined</span></span><br><span class="line">  ns: <span class="literal">undefined</span></span><br><span class="line">  context: Vue &#123;<span class="attr">_uid</span>: <span class="number">0</span>, <span class="attr">_isVue</span>: <span class="literal">true</span>, <span class="attr">$options</span>: &#123;…&#125;, <span class="attr">_renderProxy</span>: <span class="built_in">Proxy</span>, <span class="attr">_self</span>: Vue, …&#125;</span><br><span class="line">  fnContext: <span class="literal">undefined</span></span><br><span class="line">  fnOptions: <span class="literal">undefined</span></span><br><span class="line">  fnScopeId: <span class="literal">undefined</span></span><br><span class="line">  key: <span class="literal">undefined</span></span><br><span class="line">  componentOptions: &#123;<span class="attr">propsData</span>: &#123;…&#125;, <span class="attr">listeners</span>: <span class="literal">undefined</span>, <span class="attr">tag</span>: <span class="string">&quot;app&quot;</span>, <span class="attr">children</span>: <span class="literal">undefined</span>, <span class="attr">Ctor</span>: ƒ&#125;</span><br><span class="line">  componentInstance: <span class="literal">undefined</span></span><br><span class="line">  parent: <span class="literal">undefined</span></span><br><span class="line">  raw: <span class="literal">false</span></span><br><span class="line">  isStatic: <span class="literal">false</span></span><br><span class="line">  isRootInsert: <span class="literal">true</span></span><br><span class="line">  isComment: <span class="literal">false</span></span><br><span class="line">  isCloned: <span class="literal">false</span></span><br><span class="line">  isOnce: <span class="literal">false</span></span><br><span class="line">  asyncFactory: <span class="literal">undefined</span></span><br><span class="line">  asyncMeta: <span class="literal">undefined</span></span><br><span class="line">  isAsyncPlaceholder: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终通过 <code>vm._render()</code> 得到整个 <code>vnode</code>，到此，通过 <code>render</code> 构建 <code>vnode</code> 过程结束。</p><h2 id="render-异步组件生成-vnode"><a href="#render-异步组件生成-vnode" class="headerlink" title="render 异步组件生成 vnode"></a>render 异步组件生成 vnode</h2><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p>同同步组件一致，得到 <code>Ctor</code> 为经 <code>webpack</code> 编译后的 <code>Bpp</code> 函数（而同步组件是一个组件选项对象）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() =&gt; __webpack_require__.e(<span class="comment">/*! import() */</span> <span class="number">0</span>).then(__webpack_require__.bind(<span class="literal">null</span>, <span class="comment">/*! ./bpp.vue */</span> <span class="string">&#x27;./src/bpp.vue&#x27;</span>));</span><br></pre></td></tr></table></figure><p>然后进入 <code>createComponent</code>，跳过构造子类构造函数，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isUndef(Ctor.cid)) &#123;</span><br><span class="line">  asyncFactory = Ctor;</span><br><span class="line">  Ctor = resolveAsyncComponent(asyncFactory, baseCtor);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="resolveAsyncComponent"><a href="#resolveAsyncComponent" class="headerlink" title="resolveAsyncComponent"></a>resolveAsyncComponent</h4><p><code>resolveAsyncComponent</code> 里，如果提供的异步组件选项是对象的形式，则先处理 <code>error</code> 等各配置。然后将 <code>currentRenderingInstance</code>(即 <code>vue</code> 实例) 赋到 <code>Bpp</code> 函数的 <code>owners</code> 属性上并定义 <code>forceRender，resolve，reject</code> 等异步函数钩子，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = factory(resolve, reject);</span><br></pre></td></tr></table></figure><p><code>res</code> 即为一个 <code>promise</code>，该 <code>promise</code> 会在 <code>__webpack_require__.bind(null, /*! ./bpp.vue */ &#39;./src/bpp.vue&#39;)</code> 执行完成后的回调里执行。然后对结果 <code>res</code> 做了一些判断处理，本 <code>demo</code> 执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.then(resolve, reject);</span><br></pre></td></tr></table></figure><p>意味着当 <code>bpp.vue</code> 加载完成后，就会来执行之前定义的 <code>resolve，reject</code> 回调。然后返回空，<code>resolveAsyncComponent</code> 执行结束。</p><p>回到 <code>createComponent</code>，将 <code>resolveAsyncComponent</code> 结果赋给 <code>Ctor</code>，因为为空，则返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> createAsyncPlaceholder(asyncFactory, data, context, children, tag);</span><br></pre></td></tr></table></figure><p>调用 <code>createEmptyVNode</code> 返回一个占位的空 <code>vnode</code>（注释类型）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  tag: <span class="literal">undefined</span></span><br><span class="line">  data: <span class="literal">undefined</span></span><br><span class="line">  children: <span class="literal">undefined</span></span><br><span class="line">  text: <span class="string">&quot;&quot;</span></span><br><span class="line">  elm: <span class="literal">undefined</span></span><br><span class="line">  ns: <span class="literal">undefined</span></span><br><span class="line">  context: <span class="literal">undefined</span></span><br><span class="line">  fnContext: <span class="literal">undefined</span></span><br><span class="line">  fnOptions: <span class="literal">undefined</span></span><br><span class="line">  fnScopeId: <span class="literal">undefined</span></span><br><span class="line">  key: <span class="literal">undefined</span></span><br><span class="line">  componentOptions: <span class="literal">undefined</span></span><br><span class="line">  componentInstance: <span class="literal">undefined</span></span><br><span class="line">  parent: <span class="literal">undefined</span></span><br><span class="line">  raw: <span class="literal">false</span></span><br><span class="line">  isStatic: <span class="literal">false</span></span><br><span class="line">  isRootInsert: <span class="literal">true</span></span><br><span class="line">  isComment: <span class="literal">true</span></span><br><span class="line">  isCloned: <span class="literal">false</span></span><br><span class="line">  isOnce: <span class="literal">false</span></span><br><span class="line">  asyncFactory: <span class="function">() =&gt;</span> &#123;…&#125;</span><br><span class="line">  asyncMeta: &#123;<span class="attr">data</span>: <span class="literal">undefined</span>, <span class="attr">context</span>: Vue, <span class="attr">children</span>: <span class="literal">undefined</span>, <span class="attr">tag</span>: <span class="string">&quot;bpp&quot;</span>&#125;</span><br><span class="line">  isAsyncPlaceholder: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异步组件的 <code>vnode</code> 创建第一阶段结束。</p><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p>引入异步 <code>bpp.vue</code> 后，执行 <code>resolve</code> 回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">factory.resolved = ensureCtor(res, baseCtor);</span><br></pre></td></tr></table></figure><p>其中 <code>res</code> 为 <code>module.exports</code>，<code>baseCtor</code> 为 <code>Vue</code> 构造函数。<code>ensureCtor</code> 里先取得 <code>module.exports.default</code>，然后同同步组件一致，执行构造子类构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> isObject(comp) ? base.extend(comp) : comp;</span><br></pre></td></tr></table></figure><p>将构造后的子类构造函数 <code>Vue.component</code> 赋给 <code>factory.resolved</code>，执行 <code>forceRender</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = owners.length; i &lt; l; i++) &#123;</span><br><span class="line">  owners[i].$forceUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>owners[]</code> 为 <code>vue</code> 实例，对每一个拥有该组件的父组件执行 <code>$forceUpdate</code> 强制更新。</p><h4 id="forceUpdate"><a href="#forceUpdate" class="headerlink" title="$forceUpdate"></a><code>$forceUpdate</code></h4><p>迫使 <code>Vue</code> 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件（不影响作用域插槽），而不是所有子组件。</p><p><code>$forceUpdate</code> 方法里执行：<code>vm._watcher.update()</code> 进入渲染 <code>watcher</code> 更新流程。在触发父组件 <code>vue</code> 钩子 <code>beforeUpdate</code> 后，执行 <code>vm._update(vm._render(), hydrating)</code>（中间流程在本系列后续篇章详解）</p><p>此时，再次调用 <code>vm._render</code>，其他节点渲染成 <code>vnode</code> 不变，而对于该异步节点渲染，方法里再次进入 <code>resolveAsyncComponent</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isDef(factory.resolved)) &#123;</span><br><span class="line">  <span class="keyword">return</span> factory.resolved;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与第一次不一样的是，本次 <code>factory.resolved</code> 有值为子类构造函数 <code>Vue.component</code>，所以直接返回，就不走之前<code>resolveAsyncComponent</code> 方法里剩下的逻辑了，然后在 <code>createComponent</code> 里就跟同步组件路线一致，生成 <code>vnode</code>。</p><p>然后会执行 <code>vm._update</code> 方法更新真实 <code>dom</code>，异步 <code>vnode</code> 会通过 <code>createElm</code> 创建一个新的组件对应的真实 <code>dom</code>，所以会依次触发 <code>async Bpp beforeCreate-&gt;async Bpp created-&gt;async Bpp beforeMount-&gt;async Bpp mounted</code>,其中 <code>async Bpp mounted</code> 钩子在父组件的 <code>patch</code> 里 <code>invokeInsertHook</code> 中触发。</p><p>另外，异步组件的强制更新会引起父组件里的其他子组件执行 <code>updateChildComponent</code>，如果该子组件判断有普通插槽或动态插槽（不包含具名插槽），则会强行渲染包含插槽的子组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (needsForceUpdate) &#123;</span><br><span class="line">  vm.$slots = resolveSlots(renderChildren, parentVnode.context);</span><br><span class="line">  vm.$forceUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 <code>flushSchedulerQueue</code> 里执行 <code>callUpdatedHooks(updatedQueue)</code> 触发父组件 <code>vue updated</code> 钩子，异步组件加载完成。</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>本章介绍了 <code>vue</code> 执行的 <code>Mount</code> 阶段中的通过 <code>render</code> 生成 <code>vnode</code> 部分。</li><li>在执行实例化 <code>渲染 watcher</code> 时，触发 <code>render</code> 生成 <code>vnode</code>。</li><li>分析了普通节点 <code>render</code>、同步/异步组件 <code>render</code> 的过程。</li></ol>]]></content>
      
      
      <categories>
          
          <category> FE Frame </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2.x（含组件）主流程源码笔记（五）：beforeMount 阶段</title>
      <link href="396.html"/>
      <url>396.html</url>
      
        <content type="html"><![CDATA[<p>接上文，在触发生命周期钩子 <code>created</code> 后，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">  vm.$mount(vm.$options.el);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该句执行完后，<code>_init</code> 方法（位置在 <code>src/core/instance/init.js</code>）执行结束。</p><h2 id="mount-简述"><a href="#mount-简述" class="headerlink" title="$mount 简述"></a><code>$mount</code> 简述</h2><p>判断是否有 <code>$options.el</code>，如果有就直接执行：<code>vm.$mount(vm.$options.el)</code>。在前面已经提到 <code>$mount</code> 方法与平台相关，所以在本例会执行 <code>entry-runtime-with-compiler.js</code> 中的 <code>$mount</code>。</p><p><code>$mount</code> 的主要功能是根据 <code>el</code> 或者 <code>options</code> 里的 <code>template</code>，通过编译器编译成 <code>render</code> 和 <code>staticRenderFns</code>。</p><h2 id="构建-render"><a href="#构建-render" class="headerlink" title="构建 render"></a>构建 <code>render</code></h2><p><code>$mount</code> 里先取得 <code>el</code> 对应的 <code>dom</code> 节点，然后判断 <code>options</code>(即 <code>this.$options</code>) 里有没有 <code>render</code> 方法，有 <code>render</code> 就可以直接跳过取 <code>template</code> 的过程了；没有 <code>render</code> 则判断 <code>options</code> 有没有 <code>template</code>，没有提供 <code>template</code> 就用 <code>getOuterHTML(el)</code> 得一个 <code>template</code>。</p><h3 id="compileToFunctions"><a href="#compileToFunctions" class="headerlink" title="compileToFunctions"></a>compileToFunctions</h3><p>得到 <code>template</code> 后，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ref = compileToFunctions(</span><br><span class="line">  template,</span><br><span class="line">  &#123;</span><br><span class="line">    outputSourceRange: process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">    shouldDecodeNewlines: shouldDecodeNewlines,</span><br><span class="line">    shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,</span><br><span class="line">    delimiters: options.delimiters,</span><br><span class="line">    comments: options.comments,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">this</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>compileToFunctions</code> 是柯里化函数 <code>createCompileToFunctionFn(compile)</code> 的返回值，主要作用是将 <code>template</code> 转化为 <code>render</code> 函数。</p><p>内部先执行 <code>new Function(&#39;return 1&#39;)</code> 来判断 <code>csp</code> 的配置，然后根据(<code>options.delimiters</code>)是否存在设置 <code>key</code>， 判断缓存后执行：</p><h4 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compiled = compile(template, options);</span><br></pre></td></tr></table></figure><p><code>compile</code> 在 <code>createCompiler</code> 里定义，方法里先处理合并处理了 <code>compileToFunctions</code> 传入的 <code>options</code> 和 <code>baseOptions</code>(来自平台相关) 相关配置（定义了 <code>warn</code>，合并了 <code>modules</code>，<code>directives</code>）得到 <code>finalOptions</code>，然后执行：</p><h5 id="baseCompile"><a href="#baseCompile" class="headerlink" title="baseCompile"></a>baseCompile</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> compiled = baseCompile(template.trim(), finalOptions);</span><br></pre></td></tr></table></figure><p><code>baseCompile</code> 方法里执行 3 个步骤：</p><ul><li><p><code>parse</code> 模板解析为 <code>ast</code></p></li><li><p><code>optimize</code> 标记静态节点,分别递归调用 <code>markStatic$1</code> 和 <code>markStaticRoots</code> 方法得到静态节点标志挂载在 <code>ast</code> 对象下的的 <code>static</code> 和 <code>staticRoot</code> 属性。其中 <code>static</code>代表该节点是普通静态节点，<code>staticRoot</code> 代表是可以优化的静态节点，他来自于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node.static &amp;&amp; node.children.length &amp;&amp; !(node.children.length === <span class="number">1</span> &amp;&amp; node.children[<span class="number">0</span>].type === <span class="number">3</span>)) &#123;</span><br><span class="line">  node.staticRoot = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  node.staticRoot = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表明如果 <code>node.static</code> 为真(即静态节点)且他不仅仅只有一个文本子元素为的时候 <code>node.staticRoot</code> 就为真，即用来优化。如果只有一个子文本元素就无需优化，优化反而增加成本。</p></li><li><p><code>generate</code> 将 <code>AST</code> 转换成渲染函数，其中如果有标记 <code>node.staticRoot</code> 为真，则将 <code>staticRenderFns</code> 数组增加一个静态的 <code>render</code>。</p></li></ul><p>最终 <code>baseCompile</code> 返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  ast: ast,</span><br><span class="line">  render: code.render,</span><br><span class="line">  staticRenderFns: code.staticRenderFns,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>继而 <code>compile</code> 返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  ast: &#123;<span class="attr">type</span>: <span class="number">1</span>, <span class="attr">tag</span>: <span class="string">&quot;div&quot;</span>, <span class="attr">attrsList</span>: <span class="built_in">Array</span>(<span class="number">1</span>), <span class="attr">attrsMap</span>: &#123;…&#125;, <span class="attr">rawAttrsMap</span>: &#123;…&#125;, …&#125;</span><br><span class="line">  render: <span class="string">&quot;with(this)&#123;return _c(&#x27;div&#x27;,&#123;attrs:&#123;&quot;</span>id<span class="string">&quot;:&quot;</span>main<span class="string">&quot;&#125;...&quot;</span></span><br><span class="line">  staticRenderFns: []</span><br><span class="line">  errors: []</span><br><span class="line">  tips: []</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>处理编译错误后，对 <code>render</code> 和 <code>staticRenderFns</code> 进行函数包装( <code>createFunction</code> )并缓存结果，这样在后续如果再次解析到相同的模板可以直接读缓存。</p><p>继而 <code>compileToFunctions</code> 返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  render: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">with</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;xxx&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  staticRenderFns: [],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>到此 <code>template-&gt;render</code> 的编译过程结束。</p><h2 id="执行-runtime-里的原-mount-及-mountComponent"><a href="#执行-runtime-里的原-mount-及-mountComponent" class="headerlink" title="执行 runtime 里的原 $mount 及 mountComponent"></a>执行 runtime 里的原 <code>$mount</code> 及 mountComponent</h2><p>回到 <code>vm.$mount</code> 方法里继续执行，将 <code>render</code> 和 <code>staticRenderFns</code> 赋到 <code>vm.$options</code> 上后，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> mount.call(<span class="built_in">this</span>, el, hydrating);</span><br></pre></td></tr></table></figure><p>即执行被覆盖的之前的 <code>$mount</code> (<code>/runtime/index</code> 中定义)，内部执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mountComponent(<span class="built_in">this</span>, el, hydrating);</span><br></pre></td></tr></table></figure><p>在 <code>mountComponent</code> (<code>core/instance/lifecycle</code> 中定义)里先将原始的真实 <code>el</code> 赋给 <code>vm.$el</code>，判断 <code>$options.render</code> 是否存在进行相关报错处理。</p><h2 id="触发-beforeMount-钩子"><a href="#触发-beforeMount-钩子" class="headerlink" title="触发 beforeMount 钩子"></a>触发 beforeMount 钩子</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, <span class="string">&#x27;beforeMount&#x27;</span>);</span><br></pre></td></tr></table></figure><p>执行生命周期钩子 <code>beforeMount</code>，打印 <code>vue beforeMount</code>。</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>本章介绍了 <code>vue</code> 执行的 <code>beforeMount</code> 阶段；</li><li>该阶段主要执行与平台相关的 <code>$mount</code>，主要生成 <code>render</code> 函数；</li><li><code>$mount</code>经过 <code>compileToFunctions -&gt; compile -&gt; baseCompile</code> 得到 <code>render</code>，其中 <code>baseCompile</code> 的执行会经过 3 个阶段；</li><li>在 <code>$mount</code> 最后执行原 <code>$mount</code>（平台相关），方法里执行 <code>mountComponent</code> 开始进入构建 <code>vnode</code> 阶段。</li></ol>]]></content>
      
      
      <categories>
          
          <category> FE Frame </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2.x（含组件）主流程源码笔记（四）：created 阶段</title>
      <link href="395.html"/>
      <url>395.html</url>
      
        <content type="html"><![CDATA[<p>接上文继续分析，在触发生命周期钩子 <code>beforeCreate</code> 后，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">initInjections(vm); <span class="comment">// resolve injections before data/props</span></span><br><span class="line">initState(vm);</span><br><span class="line">initProvide(vm); <span class="comment">// resolve provide after data/props</span></span><br><span class="line">callHook(vm, <span class="string">&#x27;created&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="initInjections"><a href="#initInjections" class="headerlink" title="initInjections"></a>initInjections</h2><p>依赖注入，用于层级组件间传值，不可响应。</p><p>判断是否存在 <code>$options.inject</code>，然后在 <code>resolveInject</code> 里递归向上各级父元素中查找 <code>vm._provided</code> 属性值里是否有对应的注入值。找到最新值后放在实例下监听， <code>set</code> 方法设置无法重写，即不能更改注入值。</p><h2 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initState</span>(<span class="params">vm</span>) </span>&#123;</span><br><span class="line">  vm._watchers = [];</span><br><span class="line">  <span class="keyword">var</span> opts = vm.$options;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (opts.props) &#123;</span><br><span class="line">    initProps(vm, opts.props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (opts.methods) &#123;</span><br><span class="line">    initMethods(vm, opts.methods);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe(</span><br><span class="line">      (vm._data = &#123;&#125;),</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">      <span class="comment">/* asRootData */</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (opts.computed) &#123;</span><br><span class="line">    initComputed(vm, opts.computed);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依次对用户提供的 <code>options</code> 的字段进行初始化处理，会判断字段名是否合法等。顺序是：<code>props，methods，data，computed，watch</code>。</p><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>如果是子组件的 <code>props</code>，则对每一项 <code>propsOptions</code> 执行 <code>loop</code>，方法里将 <code>propsOptions</code> 的 <code>key</code> 存入 <code>vm.$options._propKeys</code>，验证 <code>props</code> 类型，然后将每一项 <code>props</code> 存入 <code>vm._props</code> 里并监听，<code>set</code> 方法设置无法重写，即不能更改注入值。</p><h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><p>其中初始化 <code>methods</code> 会把方法验证后，依次附到 <code>Vue</code> 实例 <code>vm</code> 下。</p><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>如果不是组件，其中初始化 <code>data</code> 会执行 <code>getData() =&gt; data() =&gt; mergedInstanceDataFn()</code>，即在 <code>mergeOptions</code> 方法里 <code>strats</code> 处理 <code>data</code> 的时候返回的 <code>mergedInstanceDataFn</code>。在其中 <code>mergeData</code> 了父 <code>data</code> 和自己的 <code>data</code>，然后返回。</p><p>如果是组件，则在执行 <code>data()</code> 即执行传入的 <code>options</code> 里的 <code>data</code> 函数，然后返回 <code>data</code> 对象值并赋给 <code>_data</code>。所以须保证 <code>data</code> 为函数返回一个新的对象，否则如果在模板中多次声明同一组件，组件中的 <code>data</code> 会指向同一个引用。</p><p>然后对 <code>data</code> 中每一项进行了合法性判断，然后执行 <code>proxy(vm, &quot;_data&quot;, key)</code> ，将 <code>key</code> 挂载在 <code>vm</code> 实例上，监听 <code>data</code> 第一层的所有属性。保证在读取或者设置 <code>vm.someData</code> 时会触发监听执行 <code>return vm[&#39;_data&#39;][&#39;somedata&#39;]</code> 或 <code>vm[&#39;_data&#39;][&#39;somedata&#39;] = val</code>，进而触发下文 <code>data</code> 上对每一个属性的监听。</p><p>循环执行完后，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>); <span class="comment">//即 _data</span></span><br></pre></td></tr></table></figure><p>方法里先判断 <code>data</code> 里 <code>__ob__</code> 是否存在，如果不存在则执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Observer = <span class="function"><span class="keyword">function</span> <span class="title">Observer</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.value = value;</span><br><span class="line">  <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  <span class="built_in">this</span>.vmCount = <span class="number">0</span>;</span><br><span class="line">  def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">      protoAugment(value, arrayMethods);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      copyAugment(value, arrayMethods, arrayKeys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.observeArray(value); <span class="comment">//递归遍历监听数组的每一项</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.walk(value); <span class="comment">//递归遍历监听对象的每一个属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>该方法里对每一个属性及其子属性递归初始化订阅者列表，当读取到某一属性时，就会把当前 watcher 加入到该属性的订阅列表里，当设置某一属性时，就会去通知订阅列表里所有的 watcher 执行其对应的 update 方法。</strong></p><h4 id="ob"><a href="#ob" class="headerlink" title="__ob__"></a><code>__ob__</code></h4><p><code>__ob__</code> 为 <code>Observer</code> 实例，每一个被监听的对象（包括数组）下都会拥有一个 <code>__ob__</code> 属性，内部保存着 <code>data</code> 值和该 <code>data</code> 的订阅列表。在 <code>reactiveGetter</code> 里可以对其添加订阅：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">  childOb.dep.depend();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">    dependArray(value); <span class="comment">// 循环给数组的每一项添加订阅</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="protoAugment"><a href="#protoAugment" class="headerlink" title="protoAugment"></a>protoAugment</h4><p>其中，对应数组类型的监听执行 <code>protoAugment</code>，改写 <code>value</code>（数组类型）的 <code>__proto__</code> 为 <code>arrayMethods</code>，这样在执行数组方法的时候，就会被拦截执行 <code>arrayMethods</code> 对象里重写后的变异方法，在变异方法里触发通知订阅该数组订阅的列表。</p><h4 id="检测变化的注意事项（来自文档）"><a href="#检测变化的注意事项（来自文档）" class="headerlink" title="检测变化的注意事项（来自文档）"></a>检测变化的注意事项（来自文档）</h4><ul><li>对于对象：<code>Vue</code> 无法检测 <code>property</code> 的添加或移除。由于 <code>Vue</code> 会在初始化实例时对属性执行 <code>getter/setter</code> 转化，所以属性必须在 <code>data</code> 对象上存在才能让 <code>Vue</code> 将它转换为响应式；</li><li>对于数组：<code>Vue</code> 无法监听通过索引（即下标）设置数组项（性能原因）和修改数组的长度（<code>length</code> 属性无法设置 <code>get/set</code>）。</li></ul><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>其中对 <code>computed</code> 里的每一项判断是否是 <code>SSR</code> 后，执行:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watchers[key] = <span class="keyword">new</span> Watcher(vm, getter || noop, noop, computedWatcherOptions);</span><br></pre></td></tr></table></figure><p>其中 <code>watchers</code> 即 <code>vm._computedWatchers</code>，这里实例化了一个 <code>计算 watcher</code>，其中 <code>computedWatcherOptions</code> 为 <code>&#123;lazy: true&#125;</code>，所以不会立即得到值，进而不会触发 <code>get</code> 增加订阅。然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defineComputed(vm, key, userDef);</span><br></pre></td></tr></table></figure><p>方法里将 <code>key</code> 挂载在实例下监听，<code>get</code> 方法为 <code>computedGetter</code>（执行 <code>createComputedGetter(key)</code>（柯里化）的结果），<code>set</code> 方法设置无法重写。</p><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>其中对 <code>watch</code> 里的每一项执行:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createWatcher(vm, key, handler);</span><br></pre></td></tr></table></figure><p>即执行 <code>vm.$watch(expOrFn, handler, options)</code>，方法里会执行 <code>new Watcher(vm, expOrFn, cb, options)</code>，其中 <code>expOrFn:&#39;info&#39;,&#39;cb&#39;:&#39;handler&#39;,&#39;options&#39;:&#39;&#123;handler: handler,deep: true,user: true&#125;&#39;</code>。其中 <code>user: true</code> 表示用户自己写的 <code>watcher</code>。</p><p><code>watcher</code> 里执行 <code>this.get-&gt;this.getter</code> 方法取 <code>value</code> 时，会触发之前监听该变量的 <code>proxyGetter</code>，然后将该 <code>watcher</code> 订阅到对应变量上（<code>watcher</code> <code>push</code> 到 <code>Dep</code> 的实例属性 <code>subs</code> 里），当变量后续变化时就会通知 <code>subs</code> 里的 <code>watcher</code> 列表做更新操作。</p><p>也就是说，在执行 <code>expression</code> 获取对应 <code>value</code> 的过程中，<code>expression</code> 里涉及到哪个已经被监听的属性，都会给该属性添加本 <code>watcher</code>，即订阅。当变量后续变化就会来通知该 <code>watcher</code> 执行 <code>update</code> 操作。</p><p>此时，因为 <code>deep: true</code>，所以在 <code>Watcher.prototype.get</code> 里的 <code>finally</code> 里执行 <code>traverse(value)</code>，递归读取 <code>value</code> 对象（包含数组）的每一个属性，即会触发监听每个变量的 <code>proxyGetter</code>，将该<code>watcher</code> 订阅到所有变量上。</p><p>判断有无 <code>immediate</code> 控制是否立即执行后，返回 <code>unwatchFn</code> 提供销毁该 <code>watcher</code> 的执行方法。</p><h2 id="initProvide"><a href="#initProvide" class="headerlink" title="initProvide"></a>initProvide</h2><p>判断是否存在 <code>$options.provide</code>，将其赋到 <code>vm._provided</code>属性上。</p><h2 id="触发-created-钩子"><a href="#触发-created-钩子" class="headerlink" title="触发 created 钩子"></a>触发 created 钩子</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, <span class="string">&#x27;created&#x27;</span>);</span><br></pre></td></tr></table></figure><p>执行生命周期钩子 <code>created</code>，打印 <code>vue created</code>。异步数据读取可在此钩子执行。</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>本章介绍了 <code>vue</code> 执行的 <code>created</code> 阶段；</li><li>初始化了依赖注入 <code>inject/provide</code> 相关；</li><li>对 <code>options</code> 里的 <code>props，methods，data，computed，watch</code> 属性进行处理，做一些监听，绑定，订阅之类的操作，包括数组的监听等等。</li></ol>]]></content>
      
      
      <categories>
          
          <category> FE Frame </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2.x（含组件）主流程源码笔记（三）：beforeCreate 阶段</title>
      <link href="394.html"/>
      <url>394.html</url>
      
        <content type="html"><![CDATA[<p>根据 <code>demo</code> 配置，将 <code>demo</code> 跑起来，然后忽略掉分支剧情，只分析 <code>Vue</code> 运行的主流程。</p><h2 id="引入-Vue-和-App"><a href="#引入-Vue-和-App" class="headerlink" title="引入 Vue 和 App"></a>引入 Vue 和 App</h2><p>执行 <code>index.js</code>, 先执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./app.vue&#x27;</span>;</span><br></pre></td></tr></table></figure><ul><li>变量 <code>Vue</code> 为 <code>Vue</code> 的构造函数，在执行 <code>Vue</code> 文件的过程中，会初始化设置 <code>Vue</code> 上的原型变量方法，<code>Watch</code> 类，<code>Dep</code> 类等等。</li><li>变量 <code>App</code> 为经过 <code>webpack</code> 编译，通过 <code>vue-loader，vue-template-compiler，VueLoaderPlugin</code> 作用后的包含 <code>render</code> 和 <code>staticRenderFns</code> 的<code>组件选项对象</code>:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: <span class="string">&quot;app&quot;</span></span><br><span class="line">  data: ƒ data()</span><br><span class="line">  components: &#123;<span class="attr">Child</span>: &#123;…&#125;&#125;</span><br><span class="line">  props: &#123;<span class="attr">num</span>: ƒ, <span class="attr">name</span>: ƒ&#125;</span><br><span class="line">  beforeCreate: ƒ beforeCreate()</span><br><span class="line">  created: ƒ created()</span><br><span class="line">  beforeMount: ƒ beforeMount()</span><br><span class="line">  mounted: ƒ mounted()</span><br><span class="line">  beforeUpdate: ƒ beforeUpdate()</span><br><span class="line">  updated: ƒ updated()</span><br><span class="line">  beforeDestroy: ƒ beforeDestroy()</span><br><span class="line">  destroyed: ƒ destroyed()</span><br><span class="line">  render: ƒ ()</span><br><span class="line">  staticRenderFns: []</span><br><span class="line">  _compiled: <span class="literal">true</span></span><br><span class="line">  __file: <span class="string">&quot;src/app.vue&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>staticRenderFns</code> 包含标记为静态节点的 <code>vnode</code> 单独生成的 <code>render</code> 函数的数组。</p><h2 id="处理-vm-options"><a href="#处理-vm-options" class="headerlink" title="处理 vm.$options"></a>处理 <code>vm.$options</code></h2><p>执行 <code>new Vue()</code>，即执行了 <code>Vue</code> 原型链上 <code>_init</code> 方法，内部执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">  initInternalComponent(vm, options);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据传入的 <code>options</code> 里是否包含组件标识而执行不同的方法。</p><h3 id="initInternalComponent"><a href="#initInternalComponent" class="headerlink" title="initInternalComponent"></a><code>initInternalComponent</code></h3><p>如果是组件调用，则执行 <code>initInternalComponent</code> 设置 <code>vm.$options</code>。</p><p>以第一个 <code>App</code> 组件为例，方法中将组件的 <code>options</code> 赋给 <code>vm.$options</code> 的原型上。最后经过一系列的设置得到 <code>vm.$options</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">parent: Vue &#123;<span class="attr">_uid</span>: <span class="number">0</span>, <span class="attr">_isVue</span>: <span class="literal">true</span>, <span class="attr">$options</span>: &#123;…&#125;, <span class="attr">_renderProxy</span>: <span class="built_in">Proxy</span>, <span class="attr">_self</span>: Vue, …&#125; <span class="comment">//父组件实例</span></span><br><span class="line">_parentVnode: VNode &#123;<span class="attr">tag</span>: <span class="string">&quot;vue-component-1-app&quot;</span>, <span class="attr">data</span>: &#123;…&#125;, <span class="attr">children</span>: <span class="literal">undefined</span>, <span class="attr">text</span>: <span class="literal">undefined</span>, <span class="attr">elm</span>: <span class="literal">undefined</span>, …&#125; <span class="comment">// 组件vnode</span></span><br><span class="line">propsData: &#123;<span class="attr">title</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&quot;one&quot;</span>&#125; <span class="comment">//组件vnode上的props</span></span><br><span class="line">_parentListeners: &#123;<span class="attr">welcome</span>: ƒ&#125; <span class="comment">//组件vnode上的事件</span></span><br><span class="line">_renderChildren: <span class="literal">undefined</span> <span class="comment">//插槽vnode</span></span><br><span class="line">_componentTag: <span class="string">&quot;app&quot;</span> <span class="comment">//组件vnode对应的组件实例名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其原型为挂载在子组件构造函数下的 <code>options</code> 属性（<code>Vue.extend</code> 里定义，为 <code>mergeOptions</code> 后的组件选项对象）。</p><h3 id="resolveConstructorOptions"><a href="#resolveConstructorOptions" class="headerlink" title="resolveConstructorOptions"></a><code>resolveConstructorOptions</code></h3><p>如果不是组件，则执行 <code>resolveConstructorOptions</code> 和 <code>mergeOptions</code> 设置 <code>vm.$options</code>。</p><p>参数 <code>Ctor</code> 即为传入的 <code>vm.constructor</code> 即 <code>Vue</code> 构造函数。<code>Ctor.options</code> 即为 <code>Vue.options</code>，该 <code>options</code> 在方法 <code>initGlobalAPI</code> 中定义。本 <code>demo</code> 的 <code>Ctor.options</code> 为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  components: &#123;<span class="attr">KeepAlive</span>: &#123;…&#125;, <span class="attr">Transition</span>: &#123;…&#125;, <span class="attr">TransitionGroup</span>: &#123;…&#125;&#125;</span><br><span class="line">  directives: &#123;<span class="attr">model</span>: &#123;…&#125;, <span class="attr">show</span>: &#123;…&#125;&#125;</span><br><span class="line">  filters: &#123;&#125;</span><br><span class="line">  _base: ƒ Vue(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断 <code>Ctor.super</code> 是否存在，不存在即为普通构造器，方法直接返回 <code>Ctor.options</code>；若存在，说明这是通过 <code>Vue.extend</code> 构造的子类，那么就递归合并其父级构造器的 <code>options</code> 和本身的 <code>Ctor.extendOptions</code>，最后返回合并后的 <code>options</code> <span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNDYwNjgxNw==">详解<i class="fa fa-external-link-alt"></i></span>。</p><h3 id="mergeOptions"><a href="#mergeOptions" class="headerlink" title="mergeOptions"></a><code>mergeOptions</code></h3><p><code>mergeOptions</code> 里先对 <code>child（即参数 options）</code> 执行 <code>checkComponents</code> 方法检查 <code>options.components</code> 命名是否合法。然后根据 <code>options</code> 的配置，接着检查并格式化了 <code>Props，Inject，Directives</code>。然后根据是否有 <code>extends</code> 和 <code>mixins</code> 递归调用 <code>mergeOptions</code> 合并 <code>extends</code> 和 <code>mixins</code>。</p><p>调用 <code>mergeField</code> 对 <code>parent（resolveConstructorOptions(vm.constructor) 得到）</code> 和 <code>child（options）</code> 进行了 <code>strats</code> 处理。 <code>strats</code> 用于合并处理 <code>options</code> <span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNDczODMxNA==">详解<i class="fa fa-external-link-alt"></i></span>。合并后，其中 <code>data</code> 为函数 <code>mergedInstanceDataFn</code>。最后将 <code>options</code> 赋给实例 <code>$options</code> 属性上。得到 <code>vm.$options</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  components: &#123;<span class="attr">App</span>: &#123;…&#125;, <span class="attr">Bpp</span>: ƒ&#125;</span><br><span class="line">  directives: &#123;&#125;</span><br><span class="line">  filters: &#123;&#125;</span><br><span class="line">  _base: ƒ Vue(options)</span><br><span class="line">  el: <span class="string">&quot;#main&quot;</span></span><br><span class="line">  data: ƒ mergedInstanceDataFn()</span><br><span class="line">  computed: &#123;<span class="attr">compute</span>: ƒ&#125;</span><br><span class="line">  methods: &#123;<span class="attr">plus</span>: ƒ, <span class="attr">hide</span>: ƒ&#125;</span><br><span class="line">  watch: &#123;<span class="attr">b</span>: &#123;…&#125;&#125;</span><br><span class="line">  beforeCreate: [ƒ]</span><br><span class="line">  created: [ƒ]</span><br><span class="line">  beforeMount: [ƒ]</span><br><span class="line">  mounted: [ƒ]</span><br><span class="line">  beforeUpdate: [ƒ]</span><br><span class="line">  updated: [ƒ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initProxy(vm);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">initLifecycle(vm);</span><br><span class="line">initEvents(vm);</span><br><span class="line">initRender(vm);</span><br></pre></td></tr></table></figure><p>下面分别分析各初始化内容：</p><h3 id="initProxy"><a href="#initProxy" class="headerlink" title="initProxy"></a>initProxy</h3><p>即执行 <code>vm._renderProxy = new Proxy(vm, handlers);</code> 其中 <code>handlers</code> 为 <code>hasHandler</code>。</p><p>如果 <code>options</code> 有 <code>render</code>，且 <code>_withStripped</code> 为真（比如组件），<code>handlers</code> 为 <code>getHandler</code>。</p><h3 id="initLifecycle"><a href="#initLifecycle" class="headerlink" title="initLifecycle"></a>initLifecycle</h3><p>初始化了实例上 <code>$parent</code>, <code>$root</code>, <code>$children</code>, <code>_watcher</code>, <code>_isMounted</code> 等属性。</p><p>这里如果是组件执行的话，会更新其父子组件的对应关系，更新父组件上的 <code>$children</code> 实例数组，更新当前组件的 <code>$parent</code>, <code>$root</code> 实例。</p><p>这里如果是 <code>keep-alive</code> 组件里的子组件的话，即 <code>parent.options.abstract</code> 为真，则更新子组件的 <code>$parent</code> 为 <code>keep-alive</code> 的父组件。</p><h3 id="initEvents"><a href="#initEvents" class="headerlink" title="initEvents"></a>initEvents</h3><p>如果是在子组件，则判断是否存在 <code>$options._parentListeners</code> 即在组件 <code>Vnode</code> 上的事件，如果有则通过 <code>updateComponentListeners-&gt;updateListeners-&gt;add</code> 执行 <code>vm.$on</code> 监听当前子组件实例上的自定义事件，事件由 <code>vm.$emit</code> 触发。</p><blockquote><p><code>$on，$emit</code> 本质为一个发布订阅，<code>$on</code> 收集订阅挂载在实例的 <code>_events</code> 属性下， <code>$emit</code> 执行订阅事件列表。</p></blockquote><h3 id="initRender"><a href="#initRender" class="headerlink" title="initRender"></a>initRender</h3><p>初始化了渲染相关的函数 <code>_c</code> , <code>$createElement</code> 等，然后监听了实例上：</p><ul><li><code>$attrs</code>(包含了父作用域中不作为 <code>prop</code> 被识别 (且获取) 的特性绑定)</li><li><code>$listeners</code>(包含了父作用域中的 (不含 <code>.native</code> 修饰器的) <code>v-on</code> 事件监听器)</li></ul><p>这里两个属性（各自 <code>new</code> 了一个 <code>Dep</code> 订阅者列表）。</p><p>如果是子组件，会将 <code>_parentVnode</code> 赋给 <code>vm.$vnode</code>。</p><p>如果有普通插槽，命名插槽，作用域插槽等，则初始化 <code>$slots</code>， <code>$scopedSlots</code> 。</p><h2 id="触发-beforeCreate-钩子"><a href="#触发-beforeCreate-钩子" class="headerlink" title="触发 beforeCreate 钩子"></a>触发 beforeCreate 钩子</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">callHook(vm, <span class="string">&#x27;beforeCreate&#x27;</span>);</span><br></pre></td></tr></table></figure><p>执行生命周期钩子 <code>beforeCreate</code>，打印 <code>vue beforeCreate</code>。</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>本章介绍了 <code>vue</code> 执行的 <code>beforeCreate</code> 阶段；</li><li>合并处理了组件 <code>options</code> ，父组件 <code>options</code>，平台初始化的 <code>options</code>，得到 <code>vm.$options</code>；</li><li>初始化与生命周期相关的 <code>Vue</code> 实例的各种属性，如父子关系的 <code>$parent</code> 等，初始化 <code>event</code> 事件传递相关；</li><li>初始化了渲染相关的 <code>Vue</code> 实例上的函数，插槽等。</li></ol>]]></content>
      
      
      <categories>
          
          <category> FE Frame </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2.x（含组件）主流程源码笔记（二）：源码结构及调试相关介绍</title>
      <link href="393.html"/>
      <url>393.html</url>
      
        <content type="html"><![CDATA[<h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>拉取 <code>vue</code> 代码到本地仓库，并切换版本到 <code>v2.6.11</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/vuejs/vue.git</span><br><span class="line">git checkout v2.6.11</span><br></pre></td></tr></table></figure><p>进入 <code>vue</code> 文件夹根目录下安装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn</span><br></pre></td></tr></table></figure><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>忽略掉 <code>.babelrc.js,.editorconfig</code> 等常规项目文件，只介绍 <code>vue</code> 相关。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">├─ benchmarks                 <span class="comment">// 基准数据,一些测试性能的 demo，用于与竞品框架对比</span></span><br><span class="line">├─ dist                       <span class="comment">// 构建后输出的不同版本的 Vue 文件</span></span><br><span class="line">├─ examples                   <span class="comment">// 用 Vue 写的一些小 demo</span></span><br><span class="line">├─ flow                       <span class="comment">// flow 静态类型声明文件</span></span><br><span class="line">├─ packages                   <span class="comment">// 构建后输出的服务端渲染、模板编译器、weex 相关的NPM包</span></span><br><span class="line">├─ scripts                    <span class="comment">// 存放 npm scripts 执行的各种 script，用于项目编译、测试、构建。</span></span><br><span class="line">├─ src                        <span class="comment">// 核心</span></span><br><span class="line">│   ├─ compiler               <span class="comment">// 编译器相关，用于解析模版，template-&gt;render()</span></span><br><span class="line">│       ├─ codegen            <span class="comment">// AST 转换为 render()</span></span><br><span class="line">│       ├─ directives         <span class="comment">// 生成 render() 之前需要处理的指令</span></span><br><span class="line">│       ├─ parser             <span class="comment">// template 解析为 AST</span></span><br><span class="line">│       ├─ codeframe.js       <span class="comment">// 导出 generateCodeFrame，用于格式化 console template</span></span><br><span class="line">│       ├─ create-compiler.js <span class="comment">// 导出 createCompilerCreator，用于返回 createCompiler</span></span><br><span class="line">│       ├─ error-detector.js  <span class="comment">// 检查 AST 的错误</span></span><br><span class="line">│       ├─ helpers.js         <span class="comment">// 一些编译的帮助方法</span></span><br><span class="line">│       ├─ index.js           <span class="comment">// 导出 createCompiler 方法，用于返回 compile 和 compileToFunctions</span></span><br><span class="line">│       ├─ optimizer.js       <span class="comment">// 标记静态节点，用于重建优化</span></span><br><span class="line">│       └─ tofunction.js      <span class="comment">// 导出 createCompileToFunctionFn，用于返回 compileToFunctions</span></span><br><span class="line">│   ├─ core                   <span class="comment">// 核心代码，包括内置组件，全局API封装，Vue 实例化，观察者，虚拟DOM, 工具函数等等。</span></span><br><span class="line">│       ├─ components         <span class="comment">// 内置组件定义，目前包含 Keep-Alive</span></span><br><span class="line">│       ├─ <span class="built_in">global</span>-api         <span class="comment">// 全局 api 定义，如 Vue.component,Vue.use,Vue.extend,Vue.mixin等</span></span><br><span class="line">│       ├─ instance           <span class="comment">// 实例化相关内容，生命周期定义、事件等</span></span><br><span class="line">│       ├─ observer           <span class="comment">// 数据监听，双向数据绑定，订阅中心设置等</span></span><br><span class="line">│       ├─ util               <span class="comment">// 工具方法</span></span><br><span class="line">│       ├─ vdom               <span class="comment">// 虚拟DOM相关</span></span><br><span class="line">│       ├─ config.js          <span class="comment">// 基础配置</span></span><br><span class="line">│       └─ index.js           <span class="comment">// 导出 Vue</span></span><br><span class="line">│   ├─ platforms              <span class="comment">// 跨平台相关</span></span><br><span class="line">│       ├─ web                <span class="comment">// web端</span></span><br><span class="line">│           ├─ compiler       <span class="comment">// 创建 createCompiler 所需参数 baseOptions，导出compile，compileToFunctions</span></span><br><span class="line">│           ├─ runtime        <span class="comment">// 在Vue上挂载了一些新的directives，components，config，__patch__，$mount(重写)等</span></span><br><span class="line">│           ├─ server         <span class="comment">// 服务端渲染</span></span><br><span class="line">│           ├─ util           <span class="comment">// 工具方法</span></span><br><span class="line">│           └─ xxx.js         <span class="comment">// 5个入口js，不同构建调用不用的方法</span></span><br><span class="line">│       └─ weex               <span class="comment">// weex相关</span></span><br><span class="line">│   ├─ server                 <span class="comment">// 服务端渲染（ssr）</span></span><br><span class="line">│   ├─ sfc                    <span class="comment">// 单文件组件解析（*.vue）</span></span><br><span class="line">│   └─ shared                 <span class="comment">// 全局共享的常量，方法</span></span><br><span class="line">├─ test                       <span class="comment">// 测试用例</span></span><br><span class="line">├─ types                      <span class="comment">// typescript 类型声明文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="针对目录的一些解释"><a href="#针对目录的一些解释" class="headerlink" title="针对目录的一些解释"></a>针对目录的一些解释</h2><h3 id="dist"><a href="#dist" class="headerlink" title="dist"></a>dist</h3><p><code>dist</code> 下有 10 几种不同版本的 <code>vue</code> 文件，他们是根据 <code>不同规范（包括 CommonJS 规范，ES Module，UMD）</code> 和 <code>是否包含编译器</code> 和 <code>不同环境</code> 构建出的不同版本。</p><p>具体查阅 <span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcvdjIvZ3VpZGUvaW5zdGFsbGF0aW9uLmh0bWw/c3BtPWEyYzdqLi16aC1ndWlkZS11c2UtdnVlLWluLXdlZXguMC4wLjc4Mjg0MDBlMEZyb0plIyVFNSVBRiVCOSVFNCVCOCU4RCVFNSU5MCU4QyVFNiU5RSU4NCVFNSVCQiVCQSVFNyU4OSU4OCVFNiU5QyVBQyVFNyU5QSU4NCVFOCVBNyVBMyVFOSU4NyU4QQ==">文档<i class="fa fa-external-link-alt"></i></span></p><h3 id="flow"><a href="#flow" class="headerlink" title="flow"></a>flow</h3><p>类似 <code>TypeScript</code>，<span class="exturl" data-url="aHR0cHM6Ly9mbG93Lm9yZy8=">Flow<i class="fa fa-external-link-alt"></i></span> 是 <code>facebook</code> 出品的 <code>JavaScript</code> 静态类型检查工具。<code>Vue.js</code> 的源码利用了 <code>Flow</code> 做了静态类型检查。</p><h3 id="packages"><a href="#packages" class="headerlink" title="packages"></a>packages</h3><p>通过执行 <code>npm script</code> 对应的命令可编译出以下 <code>npm</code> 包。</p><h4 id="vue-server-renderer"><a href="#vue-server-renderer" class="headerlink" title="vue-server-renderer"></a>vue-server-renderer</h4><p><code>Vue.js</code> <span class="exturl" data-url="aHR0cHM6Ly9zc3IudnVlanMub3JnL3poLw==">服务器端渲染(SSR)<i class="fa fa-external-link-alt"></i></span> 所用。</p><h4 id="vue-template-compiler"><a href="#vue-template-compiler" class="headerlink" title="vue-template-compiler"></a>vue-template-compiler</h4><p><code>vue-template-compiler</code> 通常与 <span class="exturl" data-url="aHR0cHM6Ly92dWUtbG9hZGVyLnZ1ZWpzLm9yZy96aC8=">vue-loader<i class="fa fa-external-link-alt"></i></span> 连用，用于将单文件组件 (<code>SFCs</code>)预编译为渲染函数。</p><p><code>vue-template-compiler</code> 作为 <code>compiler</code> 在 <code>vue-loader/lib/index.js</code> 的 <code>parse</code> 方法里传入，（其中会调用 <code>compiler.parseComponent</code>）得到 <code>descriptor</code>，根据 <code>descriptor</code> 可以生成不同模块的 <code>import</code> 请求，然后通过 <code>pitcher</code> 将原 <code>import</code> 请求转化为新的 <code>import</code> 请求，然后根据新的 <code>import</code> 请求执行 <code>js</code>，转化不同模块，其中转化 <code>template</code> 执行 <code>templateLoader.js</code> 时会去依赖 <code>vue-template-compiler</code> 提供 <code>compiler.compile</code> 方法解析。</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3hpeGl6aGFuZ2ZlL3Z1ZS1sb2FkZXIvYmxvYi9tYXN0ZXIvUkVBRE1FLm1k">vue-loader 解析<i class="fa fa-external-link-alt"></i></span></p><h4 id="weex-template-compiler"><a href="#weex-template-compiler" class="headerlink" title="weex-template-compiler"></a>weex-template-compiler</h4><p><code>weex</code> 相关（略过）</p><h4 id="weex-vue-framework"><a href="#weex-vue-framework" class="headerlink" title="weex-vue-framework"></a>weex-vue-framework</h4><p><code>weex</code> 相关（略过）</p><h3 id="weex"><a href="#weex" class="headerlink" title="weex"></a>weex</h3><p><span class="exturl" data-url="aHR0cHM6Ly93ZWV4LmFwYWNoZS5vcmcvemgvZ3VpZGUvaW50cm9kdWN0aW9uLmh0bWw=">Weex<i class="fa fa-external-link-alt"></i></span> 是使用流行的 <code>Web</code> 开发体验来开发高性能原生应用的框架，集成的是运行时版本的 <code>Vue</code>。</p><p>加载流程参考：<span class="exturl" data-url="aHR0cDovL3d3dy56aWppYW4uc2l0ZS8/cD0xMzE=">Weex 加载流程<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8zMjI4NWM3MDk2ODI=">浅说 Weex 工作原理<i class="fa fa-external-link-alt"></i></span></p><h3 id="sfc"><a href="#sfc" class="headerlink" title="sfc"></a>sfc</h3><p><code>sfc</code> 即单文件组件（<code>Single File Components</code>），执行 <code>sfc</code> 下的 <code>parse.js</code> 里导出的 <code>parseComponent</code> 方法得到 <code>SFCDescriptor</code> 对象。该文件最终会打包到 <code>vue-template-compiler</code> 里。</p><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>包含 <span class="exturl" data-url="aHR0cDovL2thcm1hLXJ1bm5lci5naXRodWIuaW8vNC4wL2luZGV4Lmh0bWw=">karma<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly9qYXNtaW5lLmdpdGh1Yi5pby8=">jasmine<i class="fa fa-external-link-alt"></i></span> 两种测试工具。</p><h2 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h2><p><code>vue</code> 采用 <span class="exturl" data-url="aHR0cHM6Ly93d3cucm9sbHVwanMuY29tL2d1aWRlL2ludHJvZHVjdGlvbi8=">rollup<i class="fa fa-external-link-alt"></i></span> 作为构建工具。</p><p>修改 <code>npm scripts</code> 里的 <code>dev</code> 字段对应的命令，在命令后面增加 <code>--sourcemap</code>，然后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p>此时会在 <code>dist</code> 生成 <code>vue.js</code> 和 <code>vue.js.map</code>，然后在在任意处新增 <code>html</code> 文件，然后 <code>script</code> 标签引入刚生成的 <code>vue.js</code>，然后书写 <code>vue</code> 代码在浏览器打开即可断点到源代码而不是打包后的代码。</p><h3 id="程序入口"><a href="#程序入口" class="headerlink" title="程序入口"></a>程序入口</h3><p><code>dev</code> 命令对应的 <code>TARGET</code> 为 <code>web-full-dev</code>，即对应的平台入口为 <code>platforms/web/entry-runtime-with-compiler.js</code>，该文件里面引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;./runtime/index&#x27;</span>;</span><br></pre></td></tr></table></figure><p>该文件会从 <code>core/index</code>(他又会从 <code>./instance/index</code> 引入<code>Vue</code>，该文件里会初始化 <code>Vue</code> 的各项，通过传入 <code>Vue</code> 作为参数的方式（<code>Mixin</code>）扩展原型) 里引入 <code>Vue</code>，并进行平台化相关的定制，如扩展了 <code>Vue.options.directives、Vue.options.components</code>。 初始化了 <code>Vue.prototype.__patch__</code> 为 <code>patch</code> 方法，初始化了 <code>Vue.prototype.$mount</code>，该 <code>$mount</code> 会调用 <code>core/instance/lifecycle</code> 里的 <code>mountComponent</code>。</p><p>回到 <code>entry-runtime-with-compiler.js</code> 分析，继续引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; compileToFunctions &#125; <span class="keyword">from</span> <span class="string">&#x27;./compiler/index&#x27;</span>;</span><br></pre></td></tr></table></figure><p>该文件里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; compile, compileToFunctions &#125; = createCompiler(baseOptions);</span><br></pre></td></tr></table></figure><p>其中 <code>createCompiler</code> 为 <code>compiler/index</code> 的导出，用于创建编译器。这里传入平台相关的参数 <code>baseOptions</code> 得到对应的 <code>compile，compileToFunctions</code>。<code>compileToFunctions</code> 用于将 <code>template</code> 转化为 <code>render</code> 函数。</p><p>回到 <code>entry-runtime-with-compiler.js</code> 继续分析，重写了 <code>Vue.prototype.$mount</code>，并在方法里末尾执行了原 <code>$mount</code>，然后将 <code>compileToFunctions</code> 赋给了 <code>Vue.compile</code>，最后导出 <code>Vue</code>。</p><h2 id="demo-分析使用编译后的-vue"><a href="#demo-分析使用编译后的-vue" class="headerlink" title="demo 分析使用编译后的 vue"></a>demo 分析使用编译后的 vue</h2><p>因为 <code>demo</code> 里会涉及到组件引入和其他模块，所以采用 <code>webpack</code> 打包，将 <code>vue</code> 作为 <code>npm</code> 包引入，所以意味着断点将会打到编译后的 <code>vue</code> 的 <code>js</code> 里，后续分析将会在那个文件里进行。</p>]]></content>
      
      
      <categories>
          
          <category> FE Frame </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue2.x（含组件）主流程源码笔记（一）：前言及总流程概览</title>
      <link href="392.html"/>
      <url>392.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Vue</code> 是一套用于构建用户界面的渐进式框架，被设计为可以自底向上逐层应用。本系列不会刻意梳理讲解 <code>API</code> 及 <code>Vue</code> 的用法，<span class="exturl" data-url="aHR0cHM6Ly9jbi52dWVqcy5vcmcvdjIvZ3VpZGUvaW5kZXguaHRtbA==">官方文档<i class="fa fa-external-link-alt"></i></span>已经有清晰的讲解。</p><p>本系列文章作为笔记，用于记录 <code>vue2.x</code> 的构建（含组件）主流程。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>根据 <code>vue</code> 构建 <code>demo</code> 的生命周期及其数据变化的更新作为流程线及相关，本系列文章一共分为以下章节：</p><ol start="0"><li>前言及总流程概览</li><li>源码结构及调试相关介绍</li><li><code>beforeCreate</code> 阶段</li><li><code>created</code> 阶段</li><li><code>beforeMount</code> 阶段</li><li><code>mount</code> 阶段之生成 <code>vnode</code></li><li><code>mount</code> 阶段之生成 <code>dom</code></li><li><code>update</code> 阶段（上）</li><li><code>update</code> 阶段（下）</li><li><code>destroyed</code> 阶段</li></ol><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="npm-安装"><a href="#npm-安装" class="headerlink" title="npm 安装"></a>npm 安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add vue</span><br><span class="line">yarn add vue-loader vue-style-loader vue-template-compiler css-loader -D</span><br><span class="line">yarn add @babel/core babel-loader webpack-cli webpack webpack-dev-server html-webpack-plugin -D</span><br></pre></td></tr></table></figure><h3 id="代码环境"><a href="#代码环境" class="headerlink" title="代码环境"></a>代码环境</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">  &quot;vue&quot;: &quot;^2.6.11&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;devDependencies&quot;: &#123;</span><br><span class="line">  &quot;@babel/core&quot;: &quot;^7.9.0&quot;,</span><br><span class="line">  &quot;babel-loader&quot;: &quot;^8.1.0&quot;,</span><br><span class="line">  &quot;css-loader&quot;: &quot;^3.4.2&quot;,</span><br><span class="line">  &quot;html-webpack-plugin&quot;: &quot;^4.0.4&quot;,</span><br><span class="line">  &quot;vue-loader&quot;: &quot;^15.9.1&quot;,</span><br><span class="line">  &quot;vue-style-loader&quot;: &quot;^4.1.2&quot;,</span><br><span class="line">  &quot;vue-template-compiler&quot;: &quot;^2.6.11&quot;,</span><br><span class="line">  &quot;webpack&quot;: &quot;^4.42.1&quot;,</span><br><span class="line">  &quot;webpack-cli&quot;: &quot;^3.3.11&quot;,</span><br><span class="line">  &quot;webpack-dev-server&quot;: &quot;^3.10.3&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>版本不同，源码略微有差异。</p><h3 id="demo-文件"><a href="#demo-文件" class="headerlink" title="demo 文件"></a>demo 文件</h3><p>本项目 <code>demo</code> 开源在 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3poYW9reS92dWUtZGVtbw==">github<i class="fa fa-external-link-alt"></i></span>，欢迎交流学习。</p><h4 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Bpp</span>&gt;</span><span class="tag">&lt;/<span class="name">Bpp</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click</span>=<span class="string">&quot;plus&quot;</span>&gt;</span>a:&#123;&#123;a&#125;&#125;，计算属性:&#123;&#123;compute&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">App</span> <span class="attr">name</span>=<span class="string">&quot;one&quot;</span> <span class="attr">v-bind:num</span>=<span class="string">&quot;a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">App</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click</span>=<span class="string">&quot;hide&quot;</span>&gt;</span>====点击让第二个App组件卸载====<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">App</span> <span class="attr">name</span>=<span class="string">&quot;two&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">App</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./app.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#main&#x27;</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    App,</span><br><span class="line">    Bpp: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./bpp.vue&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    info: &#123; <span class="attr">name</span>: <span class="string">&#x27;korey&#x27;</span>, <span class="attr">age</span>: <span class="number">28</span> &#125;,</span><br><span class="line">    isShow: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="function"><span class="title">compute</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.info.age + <span class="number">1</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="function"><span class="title">plus</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.info.age++;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">hide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.isShow = <span class="literal">false</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    info: &#123;</span><br><span class="line">      <span class="function"><span class="title">handler</span>(<span class="params">val, oldVal</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;变量info变化了：&#x27;</span>, val, oldVal);</span><br><span class="line">      &#125;,</span><br><span class="line">      deep: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">beforeCreate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`vue beforeCreate`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`vue created`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">beforeMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`vue beforeMount`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`vue mounted`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">beforeUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;vue beforeUpdate&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">updated</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;vue updated&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="app-vue"><a href="#app-vue" class="headerlink" title="app.vue"></a>app.vue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; num ? &#96;num:$&#123;num&#125;&#96; : &#96;&#96; &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;Child class&#x3D;&quot;example&quot;&gt;&lt;&#x2F;Child&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &#39;.&#x2F;child.vue&#39;;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;app&#39;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Child,</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    num: Number,</span><br><span class="line">    name: String,</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeCreate() &#123;</span><br><span class="line">    console.log(&#96;App beforeCreate&#96;);</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(&#96;App $&#123;this.name&#125; created&#96;);</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeMount() &#123;</span><br><span class="line">    console.log(&#96;App $&#123;this.name&#125; beforeMount&#96;);</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(&#96;App $&#123;this.name&#125; mounted&#96;);</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeUpdate() &#123;</span><br><span class="line">    console.log(&#96;App $&#123;this.name&#125; beforeUpdate&#96;);</span><br><span class="line">  &#125;,</span><br><span class="line">  updated() &#123;</span><br><span class="line">    console.log(&#96;App $&#123;this.name&#125; updated&#96;);</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    console.log(&#96;App $&#123;this.name&#125; beforeDestroy&#96;);</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    console.log(&#96;App $&#123;this.name&#125; destroyed&#96;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.example &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h4 id="bpp-vue"><a href="#bpp-vue" class="headerlink" title="bpp.vue"></a>bpp.vue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;bpp&quot;&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#39;异步Bpp组件&#39;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeCreate() &#123;</span><br><span class="line">    console.log(&#39;async Bpp beforeCreate&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(&#39;async Bpp created&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeMount() &#123;</span><br><span class="line">    console.log(&#39;async Bpp beforeMount&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(&#39;async Bpp mounted&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    console.log(&#39;async Bpp beforeDestroy&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    console.log(&#39;async Bpp destroyed&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h4 id="child-vue"><a href="#child-vue" class="headerlink" title="child.vue"></a>child.vue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;child&quot;&gt;</span><br><span class="line">    &lt;div&gt;Child组件&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  beforeCreate() &#123;</span><br><span class="line">    console.log(&#39;Child beforeCreate&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(&#39;Child created&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeMount() &#123;</span><br><span class="line">    console.log(&#39;Child beforeMount&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    console.log(&#39;Child mounted&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy() &#123;</span><br><span class="line">    console.log(&#39;Child beforeDestroy&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed() &#123;</span><br><span class="line">    console.log(&#39;Child destroyed&#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h4 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader/lib/plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  devtool: <span class="string">&#x27;hidden-source-map&#x27;</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: path.resolve(__dirname, <span class="string">&#x27;./src/index.js&#x27;</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">&#x27;./dist&#x27;</span>),</span><br><span class="line">    filename: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.vue&#x27;</span>],</span><br><span class="line">    alias: &#123;</span><br><span class="line">      vue$: <span class="string">&#x27;vue/dist/vue.esm.js&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.vue$/</span>,</span><br><span class="line">        loader: [<span class="string">&#x27;vue-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">&#x27;vue-style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> VueLoaderPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">&#x27;src/index.html&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="为什么要写这个系列"><a href="#为什么要写这个系列" class="headerlink" title="为什么要写这个系列"></a>为什么要写这个系列</h3><p>从 <code>vue</code> 过去的 <code>1.x</code> 到现在主流的 <code>2.x</code> 到即将发布的 <code>3.x</code> 版本，网上的各种相关教程多不胜数。但纸上得来终觉浅，只有自己亲自来梳理一遍，才更能对 <code>vue</code> 有更深刻的认知。</p><p>在这之前曾自己手撸了一个类 <code>vue</code> <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZDc3NGE3YWYyNjVkYTAzYmQwNTQ1OWE=">使用 proxy 实现一个简单完整的 MVVM 库<i class="fa fa-external-link-alt"></i></span>，如今整体对比 <code>vue</code> 来看，无论是功能、性能、还是框架设计都远远不如，从中学到的东西很多很多。</p>]]></content>
      
      
      <categories>
          
          <category> FE Frame </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）10 种常见的前端跨域解决方案</title>
      <link href="391.html"/>
      <url>391.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81ZDFlY2I5NmYyNjVkYTFiNmQ0MDQ0MzM=">https://juejin.im/post/5d1ecb96f265da1b6d404433<i class="fa fa-external-link-alt"></i></span></p></blockquote><h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h2><p>当一个资源从与该资源本身所在的服务器不同的域、协议、端口请求一个资源时，资源会发起一个跨域 <code>HTTP</code> 请求。</p><p>出于安全原因，浏览器做出了一些限制，跨站请求可以正常发起，但是返回结果被浏览器拦截了。</p><h3 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h3><p>同源策略是一种约定，由 Netscape 公司 1995 年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到 <code>XSS、CSRF</code> 等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个 ip 地址，也非同源。</p><p>同源策略限制以下几种行为：</p><ul><li><code>Cookie</code>、<code>LocalStorage</code> 和 <code>IndexDB</code> 无法读取</li><li><code>DOM</code> 和 <code>JS</code> 对象无法获得</li><li><code>AJAX</code> 请求不能发送</li></ul><h2 id="常见的跨域场景"><a href="#常见的跨域场景" class="headerlink" title="常见的跨域场景"></a>常见的跨域场景</h2><table><thead><tr><th>URL</th><th>说明</th><th>是否允许通信</th></tr></thead><tbody><tr><td><code>www.domain.com/a.js/</code> <br /> <code>www.domain.com/b.js</code> <br /> <code>www.domain.com/lab/c.js</code></td><td>同一域名，不同文件或路径</td><td>允许</td></tr><tr><td><code>www.domain.com:8000/a.js</code> <br /> <code>www.domain.com/b.js</code></td><td>同一域名，不同端口</td><td>不允许</td></tr><tr><td><code>http://www.domain.com/a.js</code> <br /> <code>https://www.domain.com/b.js</code></td><td>同一域名，不同协议</td><td>不允许</td></tr><tr><td><code>http://www.domain.com/a.js</code> <br /> <code>http://192.168.4.12/b.js</code></td><td>域名和域名对应相同 ip</td><td>不允许</td></tr><tr><td><code>http://www.domain.com/a.js</code> <br /> <code>http://x.domain.com/b.js</code> <br /> <code>http://domain.com/c.js</code></td><td>主域相同，子域不同</td><td>不允许</td></tr><tr><td><code>http://www.domain1.com/a.js</code> <br /> <code>http://www.domain2.com/b.js</code></td><td>不同域名</td><td>不允许</td></tr></tbody></table><h2 id="10-种跨域解决方案"><a href="#10-种跨域解决方案" class="headerlink" title="10 种跨域解决方案"></a>10 种跨域解决方案</h2><h3 id="JSONP-跨域"><a href="#JSONP-跨域" class="headerlink" title="JSONP 跨域"></a>JSONP 跨域</h3><p><code>jsonp</code> 的原理就是利用 <code>&lt;script&gt;</code> 标签没有跨域限制，通过 <code>&lt;script&gt;</code> 标签 <code>src</code> 属性，发送带有 <code>callback</code> 参数的 <code>GET</code> 请求，服务端将接口返回数据拼凑到 <code>callback</code> 函数中，返回给浏览器，浏览器解析执行，从而前端拿到 <code>callback</code> 函数返回的数据。</p><h4 id="原生-JS-实现"><a href="#原生-JS-实现" class="headerlink" title="原生 JS 实现"></a>原生 JS 实现</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  script.type = <span class="string">&#x27;text/javascript&#x27;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span></span></span><br><span class="line"><span class="javascript">  script.src = <span class="string">&#x27;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#x27;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.head.appendChild(script);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 回调执行函数</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">handleCallback</span>(<span class="params">res</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    alert(<span class="built_in">JSON</span>.stringify(res));</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>服务端返回如下（返回时即执行全局函数）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handleCallback(&#123; <span class="attr">success</span>: <span class="literal">true</span>, <span class="attr">user</span>: <span class="string">&#x27;admin&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><h4 id="jquery-Ajax-实现"><a href="#jquery-Ajax-实现" class="headerlink" title="jquery Ajax 实现"></a>jquery Ajax 实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://www.domain2.com:8080/login&#x27;</span>,</span><br><span class="line">  type: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  dataType: <span class="string">&#x27;jsonp&#x27;</span>, <span class="comment">// 请求方式为jsonp</span></span><br><span class="line">  jsonpCallback: <span class="string">&#x27;handleCallback&#x27;</span>, <span class="comment">// 自定义回调函数名</span></span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Vue-axios-实现"><a href="#Vue-axios-实现" class="headerlink" title="Vue axios 实现"></a>Vue axios 实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$http = axios;</span><br><span class="line"><span class="built_in">this</span>.\$http</span><br><span class="line">  .jsonp(<span class="string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, &#123;</span><br><span class="line">    params: &#123;&#125;,</span><br><span class="line">    jsonp: <span class="string">&#x27;handleCallback&#x27;</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>后端 <code>node.js</code> 代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> params = querystring.parse(req.url.split(<span class="string">&#x27;?&#x27;</span>)[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">var</span> fn = params.callback;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// jsonp返回设置</span></span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/javascript&#x27;</span> &#125;);</span><br><span class="line">  res.write(fn + <span class="string">&#x27;(&#x27;</span> + <span class="built_in">JSON</span>.stringify(params) + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p><code>jsonp</code> 的缺点：只能发送 <code>get</code> 一种请求。</p></blockquote><h3 id="跨域资源共享（CORS）"><a href="#跨域资源共享（CORS）" class="headerlink" title="跨域资源共享（CORS）"></a>跨域资源共享（CORS）</h3><p><code>CORS</code> 是一个 W3C 标准，全称是”跨域资源共享”（<code>Cross-origin resource sharing</code>）。它允许浏览器向跨源服务器，发出 <code>XMLHttpRequest</code> 请求，从而克服了 <code>AJAX</code> 只能同源使用的限制。<code>CORS</code> 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，<code>IE</code> 浏览器不能低于 <code>IE10</code>。</p><p>更多<span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDE2LzA0L2NvcnMuaHRtbA==">参考<i class="fa fa-external-link-alt"></i></span></p><p>浏览器将 <code>CORS</code> 跨域请求分为 <strong>简单请求</strong> 和 <strong>非简单请求</strong>。</p><p>只要同时满足一下两个条件，就属于简单请求:</p><p>使用下列方法之一：</p><ul><li><code>head</code></li><li><code>get</code></li><li><code>post</code></li></ul><p>请求的 <code>Heder</code> 是：</p><ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code>: 只限于三个值：<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul><p>不同时满足上面的两个条件，就属于非简单请求。浏览器对这两种的处理，是不一样的。</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>对于简单请求，浏览器直接发出 <code>CORS</code> 请求。具体来说，就是在头信息之中，增加一个 <code>Origin</code> 字段。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>上面的头信息中，<code>Origin</code> 字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p><code>CORS</code> 请求设置的响应头字段，都以 <code>Access-Control-</code> 开头:</p><ul><li><p><code>Access-Control-Allow-Origin</code>：必选</p><p>它的值要么是请求时 <code>Origin</code> 字段的值，要么是一个<code>*</code>，表示接受任意域名的请求，也可以设为动态 <code>$&#123;origin.protocol&#125;//$&#123;origin.host&#125;</code> 支持所有访问者的地址</p></li><li><p><code>Access-Control-Allow-Credentials</code>：可选</p><p>它的值是一个布尔值，表示是否允许发送 <code>Cookie</code>。默认情况下，<code>Cookie</code> 不包括在 <code>CORS</code> 请求之中。设为 <code>true</code>，即表示服务器明确许可，<code>Cookie</code> 可以包含在请求中，一起发给服务器。这个值也只能设为 <code>true</code>，如果服务器不要浏览器发送 <code>Cookie</code>，删除该字段即可。</p></li><li><p><code>Access-Control-Expose-Headers</code>：可选</p><p><code>CORS</code> 请求时，<code>XMLHttpRequest</code> 对象的 <code>getResponseHeader()</code> 方法只能拿到 6 个基本字段：<code>Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma</code>。如果想拿到其他字段，就必须在 <code>Access-Control-Expose-Headers</code> 里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code> 可以返回 <code>FooBar</code> 字段的值。</p></li></ul><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是 <code>PUT</code> 或 <code>DELETE</code>，或者 <code>Content-Type</code> 字段的类型是 <code>application/json</code>。非简单请求的 <code>CORS</code> 请求，会在正式通信之前，增加一次 <code>HTTP</code> 查询请求，称为”预检”请求（<code>preflight request</code>）。服务器确认允许之后，才发起实际的 <code>HTTP</code> 请求。</p><h5 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h5><p>预检请求用的请求方法是 <code>OPTIONS</code>，表示这个请求是用来询问的。请求头信息里面，关键字段是 <code>Origin</code>，表示请求来自哪个源。除了 <code>Origin</code> 字段，”预检”请求的头信息包括两个特殊字段。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0..</span><br></pre></td></tr></table></figure><ul><li><code>Access-Control-Request-Method</code>：必选</li></ul><p>用来列出浏览器的 <code>CORS</code> 请求会用到哪些 <code>HTTP</code> 方法，上例是 <code>PUT</code>。</p><ul><li><code>Access-Control-Request-Headers</code>：可选</li></ul><p>该字段是一个逗号分隔的字符串，指定浏览器 <code>CORS</code> 请求会额外发送的头信息字段，上例是 <code>X-Custom-Header</code>。</p><h5 id="预检请求的回应"><a href="#预检请求的回应" class="headerlink" title="预检请求的回应"></a>预检请求的回应</h5><p>服务器收到”预检”请求以后，检查了 <code>Origin</code>、<code>Access-Control-Request-Method</code> 和 <code>Access-Control-Request-Headers</code> 字段以后，确认允许跨源请求，就可以做出回应。</p><p><code>HTTP</code> 回应中，除了关键的是 <code>Access-Control-Allow-Origin</code> 字段，其他 <code>CORS</code> 相关字段如下：</p><ul><li><p><code>Access-Control-Allow-Methods</code>：必选</p><p>它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p></li><li><p><code>Access-Control-Allow-Headers</code></p><p>如果浏览器请求包括 <code>Access-Control-Request-Headers</code> 字段，则 <code>Access-Control-Allow-Headers</code> 字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p></li><li><p><code>Access-Control-Allow-Credentials</code>：可选</p><p>该字段与简单请求时的含义相同。</p></li><li><p><code>Access-Control-Max-Age</code>：可选</p><p>用来指定本次预检请求的有效期，单位为秒。</p></li></ul><h4 id="请求附带身份凭证-gt-cookies"><a href="#请求附带身份凭证-gt-cookies" class="headerlink" title="请求附带身份凭证 -&gt; cookies"></a>请求附带身份凭证 -&gt; cookies</h4><p>如果发起请求时设置 <code>withCredentials</code> 标志设置为 <code>true</code>，从而向服务器发送 <code>cookie</code>， 但是如果服务器端的响应中未携带 <code>Access-Control-Allow-Credentials: true</code>，浏览器将不会把响应内容返回给请求的发送者</p><p>对于附带身份凭证的请求，服务器不得设置 <code>Access-Control-Allow-Origin</code> 的值为 <code>*</code>， 必须是某个具体的域名</p><h4 id="CORS-跨域示例"><a href="#CORS-跨域示例" class="headerlink" title="CORS 跨域示例"></a>CORS 跨域示例</h4><h5 id="前端设置"><a href="#前端设置" class="headerlink" title="前端设置"></a>前端设置</h5><p>原生 <code>ajax</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// IE8/9 需用 window.XDomainRequest 兼容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端设置是否带 cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">&#x27;Content-Type&#x27;</span>, <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>);</span><br><span class="line">xhr.send(<span class="string">&#x27;user=admin&#x27;</span>);</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">    alert(xhr.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>jquery ajax</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">...</span><br><span class="line">xhrFields: &#123;</span><br><span class="line">withCredentials: <span class="literal">true</span> <span class="comment">// 前端设置是否带 cookie</span></span><br><span class="line">&#125;,</span><br><span class="line">crossDomain: <span class="literal">true</span>, <span class="comment">// 会让请求头中包含跨域的额外信息，但不会含 cookie</span></span><br><span class="line">...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="服务端设置"><a href="#服务端设置" class="headerlink" title="服务端设置"></a>服务端设置</h5><p><code>nodejs</code> 代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="keyword">var</span> qs = <span class="built_in">require</span>(<span class="string">&#x27;querystring&#x27;</span>);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">&#x27;request&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> postData = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据块接收中</span></span><br><span class="line">  req.addListener(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    postData += chunk;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据接收完毕</span></span><br><span class="line">  req.addListener(<span class="string">&#x27;end&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    postData = qs.parse(postData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跨域后台设置</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>: <span class="string">&#x27;true&#x27;</span>, <span class="comment">// 后端允许发送Cookie</span></span><br><span class="line">      <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="string">&#x27;http://www.domain1.com&#x27;</span>, <span class="comment">// 允许访问的域（协议+域名+端口）</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，</span></span><br><span class="line"><span class="comment">       * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="string">&#x27;Set-Cookie&#x27;</span>: <span class="string">&#x27;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#x27;</span>, <span class="comment">// HttpOnly的作用是让js无法读取cookie</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    res.write(<span class="built_in">JSON</span>.stringify(postData));</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="nginx-代理跨域"><a href="#nginx-代理跨域" class="headerlink" title="nginx 代理跨域"></a>nginx 代理跨域</h3><p><code>nginx</code> 代理跨域，实质和 <code>CORS</code> 跨域原理一样，通过配置文件设置请求响应头 <code>Access-Control-Allow-Origin...</code> 等字段。</p><h4 id="nginx-配置解决-iconfont-跨域"><a href="#nginx-配置解决-iconfont-跨域" class="headerlink" title="nginx 配置解决 iconfont 跨域"></a>nginx 配置解决 iconfont 跨域</h4><p>浏览器跨域访问 <code>js、css、img</code> 等常规静态资源被同源策略许可，但 <code>iconfont</code> 字体文件(<code>eot|otf|ttf|woff|svg</code>)例外，此时可在 <code>nginx</code> 的静态资源服务器中加入以下配置。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    add_header Access-Control-Allow-Origin *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nginx-反向代理接口跨域"><a href="#nginx-反向代理接口跨域" class="headerlink" title="nginx 反向代理接口跨域"></a>nginx 反向代理接口跨域</h4><blockquote><p>跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用 <code>HTTP</code> 接口只是使用 <code>HTTP</code> 协议，不需要同源策略，也就不存在跨域问题。</p></blockquote><p>实现思路：通过 <code>Nginx</code> 配置一个代理服务器域名与 <code>domain1</code> 相同，端口不同）做跳板机，反向代理访问 <code>domain2</code> 接口，并且可以顺便修改 <code>cookie</code> 中 <code>domain</code> 信息，方便当前域 <code>cookie</code> 写入，实现跨域访问。</p><p><code>nginx</code> 具体配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#proxy 服务器</span></span><br><span class="line">server &#123;</span><br><span class="line">listen 81;</span><br><span class="line">server_name www.domain1.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http://www.domain2.com:8080;  <span class="comment">#反向代理</span></span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; <span class="comment">#修改cookie里域名</span></span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span></span><br><span class="line">        add_header Access-Control-Allow-Origin http://www.domain1.com;  <span class="comment">#当前端只跨域不带cookie时，可为*</span></span><br><span class="line">        add_header Access-Control-Allow-Credentials <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="nodejs-中间件代理跨域"><a href="#nodejs-中间件代理跨域" class="headerlink" title="nodejs 中间件代理跨域"></a>nodejs 中间件代理跨域</h3><p><code>node</code> 中间件实现跨域代理，原理大致与 <code>nginx</code> 相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置 <code>cookieDomainRewrite</code> 参数修改响应头中 <code>cookie</code> 中域名，实现当前域的 <code>cookie</code> 写入，方便接口登录认证。</p><h4 id="非-vue-框架的跨域"><a href="#非-vue-框架的跨域" class="headerlink" title="非 vue 框架的跨域"></a>非 vue 框架的跨域</h4><p>使用 <code>node + express + http-proxy-middleware</code> 搭建一个 <code>proxy</code> 服务器。</p><p>前端代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前端开关：浏览器是否读写 cookie</span></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问 http-proxy-middleware 代理服务器</span></span><br><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;http://www.domain1.com:3000/login?user=admin&#x27;</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>中间件服务器代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(</span><br><span class="line">  <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">  proxy(&#123;</span><br><span class="line">    <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">    target: <span class="string">&#x27;http://www.domain2.com:8080&#x27;</span>,</span><br><span class="line">    changeOrigin: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改响应头信息，实现跨域并允许带cookie</span></span><br><span class="line">    onProxyRes: <span class="function"><span class="keyword">function</span> (<span class="params">proxyRes, req, res</span>) </span>&#123;</span><br><span class="line">      res.header(<span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="string">&#x27;http://www.domain1.com&#x27;</span>);</span><br><span class="line">      res.header(<span class="string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="string">&#x27;true&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改响应信息中的cookie域名</span></span><br><span class="line">    cookieDomainRewrite: <span class="string">&#x27;www.domain1.com&#x27;</span>, <span class="comment">// 可以为false，表示不修改</span></span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Proxy server is listen at port 3000...&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="vue-框架的跨域"><a href="#vue-框架的跨域" class="headerlink" title="vue 框架的跨域"></a>vue 框架的跨域</h4><p><code>node + vue + webpack + webpack-dev-server</code> 搭建的项目，跨域请求接口，直接修改 <code>webpack.config.js</code> 配置。开发环境下，<code>vue</code> 渲染服务和接口代理服务都是 <code>webpack-dev-server</code> 同一个，所以页面与代理接口之间不再跨域。</p><p><code>webpack.config.js</code> 部分配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;&#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;&#125;,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    historyApiFallback: <span class="literal">true</span>,</span><br><span class="line">    proxy: [</span><br><span class="line">      &#123;</span><br><span class="line">        context: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">        target: <span class="string">&#x27;http://www.domain2.com:8080&#x27;</span>, <span class="comment">// 代理跨域目标接口</span></span><br><span class="line">        changeOrigin: <span class="literal">true</span>,</span><br><span class="line">        secure: <span class="literal">false</span>, <span class="comment">// 当代理某些 https 服务报错时用</span></span><br><span class="line">        cookieDomainRewrite: <span class="string">&#x27;www.domain1.com&#x27;</span>, <span class="comment">// 可以为 false，表示不修改</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    noInfo: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="document-domain-iframe-跨域"><a href="#document-domain-iframe-跨域" class="headerlink" title="document.domain + iframe 跨域"></a>document.domain + iframe 跨域</h3><p>此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过 <code>js</code> 强制设置 <code>document.domain</code> 为基础主域，就实现了同域。</p><ul><li>父窗口：(<code>www.domain.com/a.html</code>)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://child.domain.com/b.html&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.domain = <span class="string">&#x27;domain.com&#x27;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> user = <span class="string">&#x27;admin&#x27;</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>子窗口：(<code>child.domain.com/a.html</code>)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.domain = <span class="string">&#x27;domain.com&#x27;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 获取父窗口中变量</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">&#x27;get js data from parent ---&gt; &#x27;</span> + <span class="built_in">window</span>.parent.user);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="location-hash-iframe-跨域"><a href="#location-hash-iframe-跨域" class="headerlink" title="location.hash + iframe 跨域"></a>location.hash + iframe 跨域</h3><p>实现原理： a 欲与 b 跨域相互通信，通过中间页 c 来实现。 三个页面，不同域之间利用 <code>iframe</code> 的 <code>location.hash</code> 传值，相同域之间直接 <code>js</code> 访问来通信。</p><p>具体实现：<code>A 域：a.html -&gt; B 域：b.html -&gt; A 域：c.html</code>，a 与 b 不同域只能通过 <code>hash</code> 值单向通信，b 与 c 也不同域也只能单向通信，但 c 与 a 同域，所以 c 可通过 <code>parent.parent</code> 访问 a 页面所有对象。</p><ul><li><code>a.html</code>：(<code>www.domain1.com/a.html</code>)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://www.domain2.com/b.html&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 向b.html传hash值</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    iframe.src = iframe.src + <span class="string">&#x27;#user=admin&#x27;</span>;</span></span><br><span class="line">  &#125;, 1000);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 开放给同域c.html的回调方法</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">onCallback</span>(<span class="params">res</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    alert(<span class="string">&#x27;data from c.html ---&gt; &#x27;</span> + res);</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>b.html</code>：(<code>www.domain2.com/b.html</code>)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://www.domain1.com/c.html&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 监听a.html传来的hash值，再传给c.html</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line">    iframe.src = iframe.src + location.hash;</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>c.html</code>：(<code>www.domain1.com/c.html</code>)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 监听b.html传来的hash值</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onhashchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 再通过操作同域a.html的js回调，将结果传回</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.parent.parent.onCallback(<span class="string">&#x27;hello: &#x27;</span> + location.hash.replace(<span class="string">&#x27;#user=&#x27;</span>, <span class="string">&#x27;&#x27;</span>));</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="window-name-iframe-跨域"><a href="#window-name-iframe-跨域" class="headerlink" title="window.name + iframe 跨域"></a>window.name + iframe 跨域</h3><p><code>window.name</code> 属性的独特之处：<code>name</code> 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 <code>name</code> 值（2MB）。</p><ul><li><code>a.html</code>：(<code>www.domain1.com/a.html</code>)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="function"><span class="keyword">function</span> (<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> state = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 加载跨域页面</span></span><br><span class="line">  iframe.src = url;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span></span><br><span class="line">  iframe.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span></span><br><span class="line">      callback(iframe.contentWindow.name);</span><br><span class="line">      destoryFrame();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span></span><br><span class="line">      iframe.contentWindow.location = <span class="string">&#x27;http://www.domain1.com/proxy.html&#x27;</span>;</span><br><span class="line">      state = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">destoryFrame</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    iframe.contentWindow.document.write(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    iframe.contentWindow.close();</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(iframe);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求跨域 b 页面数据</span></span><br><span class="line">proxy(<span class="string">&#x27;http://www.domain2.com/b.html&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  alert(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>proxy.html</code>：(<code>www.domain1.com/proxy.html</code>)</li></ul><p>中间代理页，与 <code>a.html</code> 同域，内容为空即可。</p><ul><li><code>b.html</code>：(<code>www.domain2.com/b.html</code>)</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.name = <span class="string">&#x27;This is domain2 data!&#x27;</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 <code>iframe</code> 的 <code>src</code> 属性由外域转向本地域，跨域数据即由 <code>iframe</code> 的 <code>window.name</code> 从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h3 id="postMessage-跨域"><a href="#postMessage-跨域" class="headerlink" title="postMessage 跨域"></a>postMessage 跨域</h3><p><code>postMessage</code> 是 <code>HTML5 XMLHttpRequest Level 2</code> 中的 <code>API</code>，且是为数不多可以跨域操作的 <code>window</code> 属性之一，它可用于解决以下方面的问题：</p><ul><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的 <code>iframe</code> 消息传递</li><li>上面三个场景的跨域数据传递</li></ul><p>用法：<code>postMessage(data,origin)</code> 方法接受两个参数：</p><ul><li><code>data</code>： html5 规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用 <code>JSON.stringify()</code> 序列化。</li><li><code>origin</code>： 协议+主机+端口号，也可以设置为”<code>*</code>“，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”<code>/</code>“。</li></ul><p><code>a.html</code>：(<code>www.domain1.com/a.html</code>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">&quot;iframe&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://www.domain2.com/b.html&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> iframe = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;iframe&#x27;</span>);</span></span><br><span class="line"><span class="javascript">  iframe.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> data = &#123;</span></span><br><span class="line"><span class="javascript">      name: <span class="string">&#x27;aym&#x27;</span>,</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="javascript">    <span class="comment">// 向domain2传送跨域数据</span></span></span><br><span class="line"><span class="javascript">    iframe.contentWindow.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">&#x27;http://www.domain2.com&#x27;</span>);</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 接受domain2返回数据</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.addEventListener(</span></span><br><span class="line"><span class="javascript">    <span class="string">&#x27;message&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      alert(<span class="string">&#x27;data from domain2 ---&gt; &#x27;</span> + e.data);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="literal">false</span></span></span><br><span class="line">  );</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>b.html</code>：(<code>www.domain2.com/b.html</code>)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 接收domain1的数据</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.addEventListener(</span></span><br><span class="line"><span class="javascript">    <span class="string">&#x27;message&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      alert(<span class="string">&#x27;data from domain1 ---&gt; &#x27;</span> + e.data);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> data = <span class="built_in">JSON</span>.parse(e.data);</span></span><br><span class="line">      if (data) &#123;</span><br><span class="line">        data.number = 16;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="comment">// 处理后再发回domain1</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.parent.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">&#x27;http://www.domain1.com&#x27;</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="literal">false</span></span></span><br><span class="line">  );</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="WebSocket-协议跨域"><a href="#WebSocket-协议跨域" class="headerlink" title="WebSocket 协议跨域"></a>WebSocket 协议跨域</h3><p><code>WebSocket protocol</code> 是 <code>HTML5</code> 一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是 <code>server push</code> 技术的一种很好的实现。</p><p>原生 <code>WebSocket API</code> 使用起来不太方便，我们使用 <code>Socket.io</code>，它很好地封装了 <code>webSocket</code> 接口，提供了更简单、灵活的接口，也对不支持 <code>webSocket</code> 的浏览器提供了向下兼容。</p><p>前端代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>user input：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> socket = io(<span class="string">&#x27;http://www.domain2.com:8080&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 连接成功处理</span></span></span><br><span class="line"><span class="javascript">  socket.on(<span class="string">&#x27;connect&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 监听服务端消息</span></span></span><br><span class="line"><span class="javascript">    socket.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;data from server: ---&gt; &#x27;</span> + msg);</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 监听服务端关闭</span></span></span><br><span class="line"><span class="javascript">    socket.on(<span class="string">&#x27;disconnect&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;Server socket has closed.&#x27;</span>);</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;input&#x27;</span>)[<span class="number">0</span>].onblur = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    socket.send(<span class="built_in">this</span>.value);</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>Nodejs socket</code> 后台：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> socket = <span class="built_in">require</span>(<span class="string">&#x27;socket.io&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启 http 服务</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">    <span class="string">&#x27;Content-type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="string">&#x27;8080&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;Server is running at port 8080...&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 socket 连接</span></span><br><span class="line">socket.listen(server).on(<span class="string">&#x27;connection&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">client</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 接收信息</span></span><br><span class="line">  client.on(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    client.send(<span class="string">&#x27;hello：&#x27;</span> + msg);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;data from client: ---&gt; &#x27;</span> + msg);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 断开处理</span></span><br><span class="line">  client.on(<span class="string">&#x27;disconnect&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Client socket has closed.&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="修改-host-跨域"><a href="#修改-host-跨域" class="headerlink" title="修改 host 跨域"></a>修改 host 跨域</h3><p>修改本机 <code>host</code> 为接口同域，可以在本地测试接口。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上就是 10 种常见的跨域解决方案：</p><ul><li><code>jsonp</code>（只支持 <code>get</code> 请求，支持老的 IE 浏览器）适合加载不同域名的 <code>js、css，img</code> 等静态资源；</li><li><code>CORS</code>（支持所有类型的 <code>HTTP</code> 请求，但浏览器 <code>IE10</code> 以下不支持）适合做 <code>ajax</code> 各种跨域请求；</li><li><code>Nginx</code> 代理跨域和 <code>nodejs</code> 中间件跨域原理都相似，都是搭建一个服务器，直接在服务器端请求 <code>HTTP</code> 接口，这适合前后端分离的前端项目调后端接口；</li><li><code>document.domain+iframe</code> 适合主域名相同，子域名不同的跨域请求；</li><li><code>postMessage、websocket</code> 都是 <code>HTML5</code> 新特性，兼容性不是很好，只适用于主流浏览器和 <code>IE10+</code>；</li><li>修改 <code>host</code> 用于本地测试接口</li></ul>]]></content>
      
      
      <categories>
          
          <category> FE Summary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端安全汇总（持续更新）</title>
      <link href="390.html"/>
      <url>390.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>在移动互联网时代，信息安全越来越重要。前端方面也面临着越来越多的安全挑战，本文收集了网上各位大佬的分析总结，将持续整理总结常见的安全问题及其防御措施。</p></blockquote><h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><h3 id="CSRF-概念"><a href="#CSRF-概念" class="headerlink" title="CSRF 概念"></a>CSRF 概念</h3><p><code>CSRF</code>（Cross-site request forgery）<strong>跨站请求伪造</strong>：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证(<code>cookies</code> 等)，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><h3 id="CSRF-攻击流程"><a href="#CSRF-攻击流程" class="headerlink" title="CSRF 攻击流程"></a>CSRF 攻击流程</h3><ol><li>受害者登录 <code>a.com</code>，并保留了登录凭证（<code>Cookie</code>）。</li><li>攻击者引诱受害者访问了 <code>b.com</code>。</li><li><code>b.com</code> 向 <code>a.com</code> 发送了一个请求：<code>a.com/act=xx</code>。浏览器会<strong>默认携带</strong> <code>a.com</code> 的 <code>Cookie</code>。</li><li><code>a.com</code> 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</li><li><code>a.com</code> 以受害者的名义执行了 <code>act=xx</code>。</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 <code>a.com</code> 执行了自己定义的操作。</li></ol><h3 id="CSRF-攻击类型"><a href="#CSRF-攻击类型" class="headerlink" title="CSRF 攻击类型"></a>CSRF 攻击类型</h3><h4 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h4><p><code>GET</code> 类型的 <code>CSRF</code> 利用非常简单，只需要一个 <code>HTTP</code> 请求，一般会这样利用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://bank.example/withdraw?amount=10000&amp;for=hacker&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在受害者访问含有这个 <code>img</code> 的页面后，浏览器会自动向 <code>http://bank.example/withdraw?account=xiaoming&amp;amount=10000&amp;for=hacker</code> 发出一次 <code>HTTP</code> 请求。<code>bank.example</code> 就会收到包含受害者登录信息的一次跨域请求。</p><h4 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h4><p>这种类型的 <code>CSRF</code> 利用起来通常使用的是一个自动提交的表单，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://bank.example/withdraw&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;account&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xiaoming&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;amount&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10000&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;for&quot;</span> <span class="attr">value</span>=<span class="string">&quot;hacker&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.forms[<span class="number">0</span>].submit();</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次 <code>POST</code> 操作。<br><code>POST</code> 类型的攻击通常比 <code>GET</code> 要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许 <code>POST</code> 上面。</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>链接类型的 <code>CSRF</code> 并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker&quot;</span> <span class="attr">taget</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line">  重磅消息！！</span><br><span class="line">  &lt;a</span><br><span class="line">/&gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于之前用户登录了信任的网站 <code>A</code>，并且保存登录状态，只要用户主动访问上面的这个 <code>PHP</code> 页面，则表示攻击成功。</p><h3 id="CSRF-特性"><a href="#CSRF-特性" class="headerlink" title="CSRF 特性"></a>CSRF 特性</h3><ul><li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</li><li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。</li><li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。</li><li>跨站请求可以用各种方式：<code>图片 URL</code>、<code>超链接</code>、<code>CORS</code>、<code>Form 提交</code>等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</li></ul><h3 id="CSRF-防御措施"><a href="#CSRF-防御措施" class="headerlink" title="CSRF 防御措施"></a>CSRF 防御措施</h3><p><code>CSRF</code> 通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对 <code>CSRF</code> 的防护能力来提升安全性。</p><h4 id="同源检测"><a href="#同源检测" class="headerlink" title="同源检测"></a>同源检测</h4><p>服务器可通过 <code>request headers</code> 里 <code>origin</code> 和 <code>referer</code> 两个字段确定请求的来源域。</p><p>如果攻击者设置 <code>Referrer Policy</code> 隐藏了 <code>referer</code>，则建议直接阻止(考虑排除搜索引擎搜索的情况)。</p><blockquote><p>cookie 是不能跨域访问的，为什么还会有 csrf？<br>浏览器会依据加载的域名附带上对应域名 cookie。如用户在 a 网站登录且生成了授权的 cookies，然后访问 b 网站，b 站故意构造请求 a 站的请求，如删除操作之类的，用<strong>不受同源影响</strong>的 script，img 或者 iframe 之类的标签加载 a 地址，浏览器会附带上 a 站此登录用户的授权 cookie 信息，这样就构成 crsf，会删除掉当前用户的数据。</p></blockquote><h4 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h4><p>而 <code>CSRF</code> 攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个 <code>CSRF</code> 攻击者无法获取到的 <code>Token</code>。服务器通过校验请求是否携带正确的 <code>Token</code>，来把正常的请求和攻击的请求区分开，也可以防范 <code>CSRF</code> 的攻击。</p><ol><li>将 <code>Token</code> 输出到页面中,对于页面整个 <code>DOM</code> 树中所有的 <code>a</code> 和 <code>form</code> 标签后都加入 <code>Token</code>。</li><li>页面提交的请求携带这个 <code>Token</code></li><li>服务器验证 <code>Token</code> 是否正确</li></ol><h4 id="验证码-amp-密码"><a href="#验证码-amp-密码" class="headerlink" title="验证码&amp;密码"></a>验证码&amp;密码</h4><p>在关键请求时要求再次输入验证码和密码之类的，打断 <code>csrf</code> 的进程，简单粗暴且有效。</p><h4 id="双重-Cookie-验证"><a href="#双重-Cookie-验证" class="headerlink" title="双重 Cookie 验证"></a>双重 Cookie 验证</h4><p>利用 <code>CSRF</code> 攻击不能获取到用户 <code>Cookie</code> 的特点，我们可以要求 <code>Ajax</code> 和表单请求携带一个 <code>Cookie</code> 中的值。</p><ol><li>在用户访问网站页面时，向请求域名注入一个 <code>Cookie</code>，内容为随机字符串（例如 <code>csrfcookie=v8g9e4ksfhw</code>）。</li><li>在前端向后端发起请求时，取出 <code>Cookie</code>，并添加到 <code>URL</code> 的参数中（接上例 <code>POST</code> <code>https://www.a.com/comment?csrfcookie=v8g9e4ksfhw</code>）。</li><li>后端接口验证 <code>Cookie</code> 中的字段与 <code>URL</code> 参数中的字段是否一致，不一致则拒绝。</li></ol><h4 id="Samesite-属性"><a href="#Samesite-属性" class="headerlink" title="Samesite 属性"></a>Samesite 属性</h4><p>Chrome 51 开始，浏览器的 <code>Cookie</code> 新增加了一个 <code>SameSite</code> 属性限制第三方 <code>Cookie</code>，用来防止 <code>CSRF</code> 攻击和用户追踪。</p><p><code>SameSite</code> 根据严格程度取值为 <code>Strict</code>, <code>Lax</code>, <code>None</code>。</p><p>目前兼容性及实用性都不太好（不支持子域），暂时不用。</p><h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><h3 id="XSS-概念"><a href="#XSS-概念" class="headerlink" title="XSS 概念"></a>XSS 概念</h3><p><code>Cross-Site Scripting</code>（跨站脚本攻击）简称 <code>XSS</code>，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 <code>Cookie</code>、<code>SessionID</code> 等，进而危害数据安全。</p><h3 id="XSS-分类"><a href="#XSS-分类" class="headerlink" title="XSS 分类"></a>XSS 分类</h3><table><thead><tr><th>类型</th><th>存储区</th><th>插入点</th></tr></thead><tbody><tr><td>存储型 XSS</td><td>后端数据库</td><td>HTML</td></tr><tr><td>反射型 XSS</td><td>URL</td><td>HTML</td></tr><tr><td>DOM 型 XSS</td><td>后端数据库/前端存储/URL</td><td>前端 JavaScript</td></tr></tbody></table><h4 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h4><ol><li>攻击者将恶意代码提交到目标网站的数据库中。</li><li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 <code>HTML</code> 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p><h4 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h4><ol><li>攻击者构造出特殊的 <code>URL</code>，其中包含恶意代码。</li><li>用户打开带有恶意代码的 <code>URL</code> 时，网站服务端将恶意代码从 <code>URL</code> 中取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>反射型 <code>XSS</code> 漏洞常见于通过 <code>URL</code> 传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的 <code>URL</code> 才能生效，攻击者往往会结合多种手段诱导用户点击。</p><h4 id="DOM-型-XSS"><a href="#DOM-型-XSS" class="headerlink" title="DOM 型 XSS"></a>DOM 型 XSS</h4><ol><li>攻击者构造出特殊的 <code>URL</code>，其中包含恶意代码。</li><li>用户打开带有恶意代码的 <code>URL</code>。</li><li>用户浏览器接收到响应后解析执行，前端 <code>JavaScript</code> 取出 <code>URL</code> 中的恶意代码并执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p><code>DOM</code> 型 <code>XSS</code> 跟前两种 <code>XSS</code> 的区别：<code>DOM</code> 型 <code>XSS</code> 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 <code>JavaScript</code> 自身的安全漏洞，而其他两种 <code>XSS</code> 都属于服务端的安全漏洞。</p><h3 id="XSS-防御"><a href="#XSS-防御" class="headerlink" title="XSS 防御"></a>XSS 防御</h3><h4 id="针对攻击者提交恶意代码"><a href="#针对攻击者提交恶意代码" class="headerlink" title="针对攻击者提交恶意代码"></a>针对攻击者提交恶意代码</h4><h5 id="输入过滤"><a href="#输入过滤" class="headerlink" title="输入过滤"></a>输入过滤</h5><p>对前端而言，输入过滤不可靠。因为一旦攻击者绕过前端过滤，直接构造请求，就可以提交恶意代码了。</p><h5 id="输入内容长度控制"><a href="#输入内容长度控制" class="headerlink" title="输入内容长度控制"></a>输入内容长度控制</h5><p>对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 <code>XSS</code> 发生，但可以增加 <code>XSS</code> 攻击的难度。</p><h5 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h5><p>防止脚本冒充用户提交危险操作。</p><h4 id="针对浏览器执行恶意代码"><a href="#针对浏览器执行恶意代码" class="headerlink" title="针对浏览器执行恶意代码"></a>针对浏览器执行恶意代码</h4><h5 id="纯前端渲染"><a href="#纯前端渲染" class="headerlink" title="纯前端渲染"></a>纯前端渲染</h5><p>在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（<code>.innerText</code>），还是属性（<code>.setAttribute</code>），还是样式（<code>.style</code>）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。</p><h5 id="转义-HTML"><a href="#转义-HTML" class="headerlink" title="转义 HTML"></a>转义 HTML</h5><p>应当尽量避免转义 <code>HTML</code>。但如果不是纯前端渲染，就需要采用合适的转义库，对 <code>HTML</code> 模板各处插入点进行充分的转义。</p><h5 id="预防-DOM-型-XSS-攻击"><a href="#预防-DOM-型-XSS-攻击" class="headerlink" title="预防 DOM 型 XSS 攻击"></a>预防 DOM 型 XSS 攻击</h5><p>防范存储型和反射型 <code>XSS</code> 是后端 <code>RD</code> 的责任。而 <code>DOM</code> 型 <code>XSS</code> 攻击不发生在后端。<code>DOM</code> 型 <code>XSS</code> 攻击，实际上就是网站前端 <code>JavaScript</code> 代码本身不够严谨，把不可信的数据当作代码执行了。</p><p>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 <code>HTML</code> 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等。</p><p>如果用 <code>Vue/React</code> 技术栈，并且不使用 <code>v-html/dangerouslySetInnerHTML</code> 功能，就在前端 <code>render</code> 阶段避免 <code>innerHTML、outerHTML</code> 的 <code>XSS</code> 隐患。</p><p><code>DOM</code> 中的内联事件监听器，如 <code>location、onclick、onerror、onload、onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，<code>JavaScript</code> 的 <code>eval()、setTimeout()、setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 <code>API</code>，很容易产生安全隐患，请务必避免。</p><h5 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h5><p>内容安全策略 (<code>CSP</code>) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (<code>XSS</code>) 和数据注入攻击等。</p><p>通过 <code>HTTP Header</code> 来定义(优先)：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Content-Security-Policy:&quot;</span> 策略集</span><br></pre></td></tr></table></figure><p>通过 <code>html meta</code> 标签使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;content-security-policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;策略集&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0NvbnRlbnQtU2VjdXJpdHktUG9saWN5">更多<i class="fa fa-external-link-alt"></i></span>策略</p><ul><li>禁止加载外域代码，防止复杂的攻击逻辑。</li><li>禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。</li><li>禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。</li><li>禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。</li><li>合理使用上报可以及时发现 XSS，利于尽快修复问题。</li></ul><h5 id="HttpOnly-amp-Secure"><a href="#HttpOnly-amp-Secure" class="headerlink" title="HttpOnly &amp; Secure"></a>HttpOnly &amp; Secure</h5><ul><li><code>cookie</code> 中设置了 <code>HttpOnly</code> 属性，禁止 <code>JavaScript</code> 读取某些敏感 <code>Cookie</code>，攻击者完成 <code>XSS</code> 注入后也无法窃取此 <code>Cookie</code>。</li><li><code>cookie</code> 中设置了 <code>Secure</code> 属性,规定 <code>cookie</code> 只能在 <code>https</code> 协议下才能够发送到服务器。防止信息在传递的过程中被监听捕获后信息泄漏。</li></ul><h2 id="iframe-嵌套"><a href="#iframe-嵌套" class="headerlink" title="iframe 嵌套"></a>iframe 嵌套</h2><p>点击劫持 (<code>ClickJacking</code>) 一般会利用透明 <code>iframe</code> 覆盖原网页诱导用户进行某些操作达成目的。</p><h3 id="防止其他页面通过-iframe-引用"><a href="#防止其他页面通过-iframe-引用" class="headerlink" title="防止其他页面通过 iframe 引用"></a>防止其他页面通过 iframe 引用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自己网站添加</span></span><br><span class="line"><span class="keyword">if</span> (top.location != self.location) &#123;</span><br><span class="line">  top.location.href = <span class="string">&#x27;http://www.baidu.com&#x27;</span>; <span class="comment">//若被其他网站引用则强制跳转</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="X-FRAME-OPTIONS"><a href="#X-FRAME-OPTIONS" class="headerlink" title="X-FRAME-OPTIONS"></a>X-FRAME-OPTIONS</h4><p>或者添加 <code>HTTP</code> 响应头： <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9YLUZyYW1lLU9wdGlvbnM=">X-FRAME-OPTIONS<i class="fa fa-external-link-alt"></i></span></p><p><code>HTTP</code> 响应头信息中的 <code>X-Frame-Options</code>，可以指示浏览器是否应该加载一个 <code>iframe</code> 中的页面。如果服务器响应头信息中没有 <code>X-Frame-Options</code>，则该网站存在 <code>ClickJacking</code> 攻击风险。</p><h3 id="防止引用的其他-iframe-篡改自己的页面"><a href="#防止引用的其他-iframe-篡改自己的页面" class="headerlink" title="防止引用的其他 iframe 篡改自己的页面"></a>防止引用的其他 iframe 篡改自己的页面</h3><p>添加 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRNTC9FbGVtZW50L2lmcmFtZQ==">sandbox<i class="fa fa-external-link-alt"></i></span> 属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;其他页面.html&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">sandbox</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="opener"><a href="#opener" class="headerlink" title="opener"></a>opener</h2><p>通过以下两种方式打开的页面可以使用 <code>window.opener</code> 来访问源页面的 <code>window</code> 对象，进而进行篡改原页面：</p><h3 id="window-open"><a href="#window-open" class="headerlink" title="window.open"></a>window.open</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.open(<span class="string">&#x27;http://www.baidu.com&#x27;</span>);</span><br></pre></td></tr></table></figure><p>防御方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newTab = <span class="built_in">window</span>.open();</span><br><span class="line">newTab.opener = <span class="literal">null</span>;</span><br><span class="line">newTab.location = url;</span><br></pre></td></tr></table></figure><h3 id="a-标签加-blank"><a href="#a-标签加-blank" class="headerlink" title="a 标签加 _blank"></a>a 标签加 <code>_blank</code></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>防御方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;noopener noreferrer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="CDN-劫持"><a href="#CDN-劫持" class="headerlink" title="CDN 劫持"></a>CDN 劫持</h2><p>出于性能考虑，前端应用通常会把一些静态资源存放到 <code>CDN</code>（Content Delivery Networks）上面，例如 <code>js</code> 脚本和 <code>style</code> 文件。这么做可以显著提高前端应用的访问速度，但与此同时却也隐含了一个新的安全风险。如果攻击者劫持了 <code>CDN</code>，或者对 <code>CDN</code> 中的资源进行了污染，攻击者可以肆意篡改我们的前端页面，对用户实施攻击。</p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzM1NzIwMDkyL2Fuc3dlci81MjM1NjM4NzM=">应对流量劫持，前端能做哪些工作？<i class="fa fa-external-link-alt"></i></span></p><h3 id="SRI"><a href="#SRI" class="headerlink" title="SRI"></a>SRI</h3><h4 id="SRI-简介"><a href="#SRI-简介" class="headerlink" title="SRI 简介"></a>SRI 简介</h4><p>子资源完整性(<code>SRI</code>)是允许浏览器检查其获得的资源（例如从 <code>CDN</code> 获得的）是否被篡改的一项安全特性。它通过验证获取文件的哈希值是否和你提供的哈希值一样来判断资源是否被篡改。</p><p>通过给 <code>link</code> 标签或者 <code>script</code> 标签增加 <code>integrity</code> 属性即可开启 <code>SRI</code> 功能.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;//s.url.cn/xxxx/aaa.js&quot;</span> <span class="attr">integrity</span>=<span class="string">&quot;sha256-xxx sha384-yyy&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>integrity</code> 值分成两个部分，第一部分指定哈希值的生成算法（<code>sha256</code>、<code>sha384</code> 及 <code>sha512</code>），第二部分是经过 <code>base64</code> 编码的实际哈希值，两者之间通过一个短横（<code>-</code>）分割。<code>integrity</code> 值可以包含多个由空格分隔的哈希值，只要文件匹配其中任意一个哈希值，就可以通过校验并加载该资源。</p><p><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRNTC9DT1JTX3NldHRpbmdzX2F0dHJpYnV0ZXM=">crossorigin=”anonymous”<i class="fa fa-external-link-alt"></i></span> 的作用是引入跨域脚本，使用 <code>SRI</code> 要保证资源同域或开启跨域。如果不加此属性则表示不开启 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9BY2Nlc3NfY29udHJvbF9DT1JT">CORS<i class="fa fa-external-link-alt"></i></span> 策略。</p><h4 id="浏览器处理-SRI-原理"><a href="#浏览器处理-SRI-原理" class="headerlink" title="浏览器处理 SRI 原理"></a>浏览器处理 SRI 原理</h4><ul><li>当浏览器在 <code>script</code> 或者 <code>link</code> 标签中遇到 <code>integrity</code> 属性之后，会在执行脚本或者应用样式表之前对比所加载文件的哈希值和期望的哈希值。</li><li>当脚本或者样式表的哈希值和期望的不一致时，浏览器必须拒绝执行脚本或者应用样式表，并且必须返回一个网络错误说明获得脚本或样式表失败。</li></ul><h4 id="如何使用-SRI"><a href="#如何使用-SRI" class="headerlink" title="如何使用 SRI"></a>如何使用 SRI</h4><p>通过使用 <code>webpack</code> 的 <code>html-webpack-plugin</code> 和 <code>webpack-subresource-integrity</code> 可以生成包含 <code>integrity</code> 属性 <code>script</code> 标签。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SriPlugin <span class="keyword">from</span> <span class="string">&#x27;webpack-subresource-integrity&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> compiler = webpack(&#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    crossOriginLoading: <span class="string">&#x27;anonymous&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> SriPlugin(&#123;</span><br><span class="line">      hashFuncNames: [<span class="string">&#x27;sha256&#x27;</span>, <span class="string">&#x27;sha384&#x27;</span>],</span><br><span class="line">      enabled: process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后通过插件 <code>script-ext-html-webpack-plugin</code> 在 <code>script</code> 里注入 <code>onerror</code> 事件和 <code>onsuccess</code> <code>事件。onerror</code> 事件里再次请求一次数据，比较两次数据是否一致来判断是否被 <code>CDN</code> 劫持。</p><h4 id="联合-CSP"><a href="#联合-CSP" class="headerlink" title="联合 CSP"></a>联合 CSP</h4><p>另外，通过在 <code>CSP</code> 头部添加：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy: require-sri-for script;</span><br></pre></td></tr></table></figure><p>这条指令规定了所有 <code>JavaScript</code> 都要有 <code>integrity</code> 属性，且通过验证才能被加载。</p><h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>用户在访问某个网站的时候，在浏览器里却往往直接输入网站域名。浏览器便向网站发起一次 <code>HTTP</code> 请求，在得到一个重定向响应后，再发起一次 <code>HTTPS</code> 请求并得到最终的响应内容。由于在建立起 <code>HTTPS</code> 连接之前存在一次明文的 <code>HTTP</code> 请求和重定向，使得攻击者可以以中间人的方式劫持这次请求，从而进行后续的攻击，例如窃听数据，篡改请求和响应，跳转到钓鱼网站等。</p><h3 id="HSTS"><a href="#HSTS" class="headerlink" title="HSTS"></a>HSTS</h3><p><code>HSTS</code> 的全称是 <code>HTTP</code> <code>Strict-Transport-Security</code>（严格传输安全），它是一个 <code>Web</code> 安全策略机制，通过服务器设置 <code>HTTP Response Header</code> 告诉浏览器只能通过 <code>HTTPS</code> 访问当前资源，而不是 <code>HTTP</code>。</p><h4 id="HSTS-语法"><a href="#HSTS-语法" class="headerlink" title="HSTS 语法"></a>HSTS 语法</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Strict-Transport-Security: &lt;max-age=&gt;[; includeSubDomains][; preload]</span><br></pre></td></tr></table></figure><ul><li><code>max-age</code> 是必选参数，是一个以秒为单位的数值，它代表着 <code>HSTS Header</code> 的过期时间，通常设置为 1 年，即 31536000 秒。</li><li><code>includeSubDomains</code> 是可选参数，如果包含它，则意味着当前域名及其子域名均开启 <code>HSTS</code> 保护。</li><li><code>preload</code> 是可选参数，只有当你申请将自己的域名加入到浏览器内置列表的时候才需要使用到它</li></ul><h4 id="HSTS-更多"><a href="#HSTS-更多" class="headerlink" title="HSTS 更多"></a>HSTS 更多</h4><ul><li>只要是在有效期内，浏览器都将直接强制性的发起 <code>HTTPS</code> 请求。</li><li><code>HSTS</code> 让浏览器强制拒绝不安全的链接，不给用户选择的机会。</li><li>第一次访问网站的时候，依然需要一次明文的 <code>HTTP</code> 请求和重定向才能切换到 <code>HTTPS</code>，以及刷新 <code>HSTS</code> 信息，此时仍然可以进行中间人攻击，对此，浏览器里内置一个列表 <code>Preload List</code>，只要是在这个列表里的域名，无论何时、何种情况，浏览器都只使用 <code>HTTPS</code> 发起连接。</li></ul><h3 id="cookie-secure"><a href="#cookie-secure" class="headerlink" title="cookie secure"></a>cookie secure</h3><p>通过 <code>cookie</code> <code>secure</code> 保证你的 <code>session cookie</code> 对于攻击者是不可见的，避免中间人攻击。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p><code>HTTPS=HTTP+SSL</code></p><p>确保所有需要的资源都用 <code>HTTPS</code> 引入.</p><h4 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h4><p>传输层安全协议（<code>Transport Layer Security / TLS</code>）及其前身安全套接层（<code>Secure Sockets Layer / SSL</code>）为浏览器和服务器提供了端到端的加密手段，为互联网通信提供了安全可靠性保障。没有 <code>TLS</code>，其他安全手段不堪一击。<code>TLS</code> 是 <code>HTTP</code> 安全的基石。</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache Control"></a>Cache Control</h3><p>指定页面的缓存策略。强烈建议手动指定页面缓存策略，否则会由浏览器和代理来控制是否缓存内容。一个不当的缓存策略可能会导致性能问题和安全问题。</p><h3 id="Content-Type-Options"><a href="#Content-Type-Options" class="headerlink" title="Content Type Options"></a>Content Type Options</h3><p>通常浏览器根据响应头的 <code>Content Type</code> 字段分辨资源类型，但假若某些资源 <code>Content Type</code> 是错的或未定义，浏览器会启用 <code>MIME-sniffing</code> 来猜测该资源的类型，解析内容并执行。</p><p><code>X-Content-Type-Options</code> 响应头可以关闭浏览器的资源 <code>MIME-sniffing</code> 功能:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Content-Type-Options: nosniff</span><br></pre></td></tr></table></figure><h3 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h3><p>以下都应删除</p><ul><li><code>Server Banner</code><br>响应头里加入 <code>Server Banner</code> 来标明自己身份和版本号 如：<code>server:nginx/1.10.0 (Ubuntu)</code></li><li><code>Web</code> 框架信息<br>很多 <code>Web</code> 框架都会设置响应头来标示自己身份、版本。这些响应头都是非标准的，而且也不影响页面渲染，只是为了框架自身的宣传。如：<code>X-Powered-By, X-Runtime, X-Version, X-AspNet-Version</code> 等</li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YmFkOTE0MGU1MWQ0NTBlOTM1YzZkNjQ=">前端安全系列（一）：如何防止 XSS 攻击？<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YmMwMDk5OTZmYjlhMDVkMGEwNTUxOTI=">前端安全系列（二）：如何防止 CSRF 攻击？<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTkvMDkvY29va2llLXNhbWVzaXRlLmh0bWw=">Cookie 的 SameSite 属性<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRUUC9DU1A=">内容安全策略( CSP )<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC84Mzg2NTE4NQ==">前端安全问题汇总（实战）<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veGQ1MDJkamovcC8xMTY2MDQ5Ni5odG1s">HSTS 详解<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nob2tjb2NvL2h0dHBoaWphY2svYmxvYi9tYXN0ZXIvaHR0cGhpamFjazEuMS4wLmpz">前端监控方案<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzM1NWE4MTZmYjlhMDQ5YTQyZjNhYzg=">使用 SRI 解决 CDN 劫持<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNTkxMjdhYzMyZjMwMWUwMDU3ZWY3Y2Zj">HTTP 安全最佳实践<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> FE Summary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）柯里化与反柯里化</title>
      <link href="389.html"/>
      <url>389.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RjYXRjaGUvdGNhdGNoZS5naXRodWIuaW8vaXNzdWVzLzIy">https://github.com/tcatche/tcatche.github.io/issues/22<i class="fa fa-external-link-alt"></i></span></p></blockquote><h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>柯里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p><p>柯里化，作为高阶函数的一种应用，是一个逐步接收参数的过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curriedAdd = <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="function">(<span class="params">y</span>) =&gt;</span> x + y;</span><br><span class="line"><span class="keyword">var</span> addOne = curriedAdd(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> addTen = curriedAdd(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">addOne(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line">addTen(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>上述示例，将原本接收两个参数的 <code>add</code> 改造成了接收一个参数的 <code>addOne</code> 和 <code>addTen</code> 函数，每个函数都具有独立的语义。</p><p>这种方式有一个优点，可以把易变的参数固定下来。这个最典型的应用场景是使用 <code>bind</code> 函数（<strong>偏函数的一种实现</strong>）绑定 <code>this</code> 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="built_in">this</span>；</span><br><span class="line">  <span class="keyword">var</span> _args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _this.apply(context, _args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)))；</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>柯里化的另一个应用场景是在如果有多个不同的执行场景，可以提前确定当前执行环境。这个最典型的例子是兼容现代浏览器以及 <code>IE</code> 浏览器的事件监听：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addEvent = <span class="function">(<span class="params">root, ele, type, fn, capture = <span class="literal">false</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (root.attachEvent) &#123;</span><br><span class="line">    ele.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, fn);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.addEventListener) &#123;</span><br><span class="line">    ele.addEventListener(type, fn, capture);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个函数执行倒没有问题，只是每次调用都会执行一次 <code>if...else</code>，挺繁琐的，完全可以通过柯里化只做一次判定：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addEvent = (<span class="function">(<span class="params">root</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (root.attachEvent) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">ele, type, fn</span>) =&gt;</span> ele.attachEvent(<span class="string">&#x27;on&#x27;</span> + type, fn);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.addEventListener) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">ele, type, fn, capture = <span class="literal">false</span></span>) =&gt;</span> ele.addEventListener(type, fn, capture);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure><p>这样 <code>addEvent</code> 函数实际上已经是本浏览器支持的事件添加方法。</p><h2 id="curry-的实现"><a href="#curry-的实现" class="headerlink" title="curry 的实现"></a>curry 的实现</h2><p><code>curry</code> 的实现有两种方法，第一种是自己手工实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function">(<span class="params">x, y, z</span>) =&gt;</span> x + y + z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curriedAdd = <span class="function">(<span class="params">x</span>) =&gt;</span> <span class="function">(<span class="params">y</span>) =&gt;</span> <span class="function">(<span class="params">z</span>) =&gt;</span> x + y + z;</span><br></pre></td></tr></table></figure><p>还有一种方法就是使用 <code>curry</code> 函数进行转换， 如 <code>lodash</code> 和 <code>ramda</code> 都提供有函数可以自动完成 <code>curry</code>， 这里写一个简单的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> curry = <span class="function">(<span class="params">fn, length = fn.length</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">var</span> _curryN = <span class="function">(<span class="params">...<span class="built_in">arguments</span></span>) =&gt;</span> &#123;</span><br><span class="line">    args = args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>));</span><br><span class="line">    <span class="keyword">if</span> (args.length == length) &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _curryN;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> _curryN;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>就是，生成一个 <code>curry</code> 函数，每次调用 <code>curry</code> 函数的时候计算函数的参数是否满足定义时候的参数数量，如果不满足，则缓存当前的参数，否则，把多次调用 <code>curry</code> 函数的参数传入原始函数执行。</p><p>中间的 <code>_curryN</code> 是个挺有用的工具，可以将一个接受多个参数的函数转化为接受部分参数的 <code>curry</code> 函数，将其进一步分离，并优化代码结构如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> curryN = <span class="function">(<span class="params">fn, length</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//对原始函数的包装，合并多次调用的柯里化的函数的参数，作为原始函数 fn 的参数，调用 fn</span></span><br><span class="line">  <span class="keyword">var</span> _warpFunc = <span class="function">(<span class="params">fn, args</span>) =&gt;</span> <span class="function">(<span class="params">...<span class="built_in">arguments</span></span>) =&gt;</span> fn.apply(<span class="literal">null</span>, args.concat(<span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (args.length &lt; length) &#123;</span><br><span class="line">      <span class="keyword">return</span> curryN(_warpFunc(fn, args), length - args.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, args);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> curry = <span class="function">(<span class="params">fn, length = fn.length</span>) =&gt;</span> curryN(fn, length);</span><br></pre></td></tr></table></figure><h2 id="反柯里化-uncurry"><a href="#反柯里化-uncurry" class="headerlink" title="反柯里化 uncurry"></a>反柯里化 uncurry</h2><p>反柯里化（<code>uncurry</code>）从字面上就可以看出和柯里化（<code>curry</code>）的含义正好相反，如果说柯里化的作用是固定部分参数，使函数针对性更强，那么反柯里化的作用就是扩大一个函数的应用范围，使一个函数适用于其他的对象。</p><p>如果说 <code>curry</code> 是预先传入一些参数，那么 <code>uncurry</code> 就是把原来已经固定的参数或者 <code>this</code> 上下文当作参数延迟来传递，也就是把 <code>this.method</code> 的调用模式转化成 <code>method(this,arg1,arg2....)</code>，目的是创建一个更普适性的函数，可以被不同的对象使用。</p><p>比如，<code>Array</code> 上有一个 <code>push</code> 的方法，想让 <code>push</code> 这个函数不仅仅支持数组，还能够被其他对象使用：<code>push(obj,args)</code> ，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.push(<span class="number">4</span>);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> push = <span class="built_in">Array</span>.prototype.push.unCurry();</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">push(obj, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"><span class="comment">// Object &#123;0: &quot;a&quot;, length: 1&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>javascript</code> 里面，很多函数都不做对象的类型检测，而是只关心这些对象能做什么，如 <code>Array</code> 和 <code>String</code> 的 <code>prototype</code> 上的方法就被特意设计成了这种模式，这些方法不对 <code>this</code> 的数据类型做任何校验，因此 <code>obj</code> 可以冒用 <code>Array</code> 的 <code>push</code> 方法进行操作。这里再看一个 <code>String</code> 的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toUpperCase = <span class="built_in">String</span>.prototype.toUpperCase.unCurry();</span><br><span class="line">toUpperCase(<span class="string">&#x27;js&#x27;</span>);</span><br><span class="line"><span class="comment">// JS</span></span><br></pre></td></tr></table></figure><p><code>call</code> 方法也可以被 <code>unCurry</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  name: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  print: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  change: <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.print();</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = &#123;</span><br><span class="line">  name: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.print.call(b);</span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> call = <span class="built_in">Function</span>.prototype.call.unCurry();</span><br><span class="line">call(a.print, b);</span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"></span><br><span class="line">call(a.print, b, <span class="string">&#x27;bb&#x27;</span>);</span><br><span class="line">a.name;</span><br><span class="line"><span class="comment">// &quot;aa&quot;</span></span><br><span class="line"></span><br><span class="line">b.name;</span><br><span class="line"><span class="comment">// &quot;bb&quot;</span></span><br></pre></td></tr></table></figure><p><code>unCurry</code> 本身也是方法，它也可以被反柯里化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unCurry = <span class="built_in">Function</span>.prototype.unCurry.unCurry();</span><br><span class="line"><span class="keyword">var</span> toUpperCase = unCurry(<span class="built_in">String</span>.prototype.toUpperCase);</span><br><span class="line">toUpperCase(<span class="string">&#x27;js&#x27;</span>);</span><br><span class="line"><span class="comment">// JS</span></span><br></pre></td></tr></table></figure><h2 id="反柯里化的实现"><a href="#反柯里化的实现" class="headerlink" title="反柯里化的实现"></a>反柯里化的实现</h2><p>实现的代码很简单，只有几行，但是比较绕：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 为 Function 原型添加 unCurry 方法，这样所有的 function 都可以被修改适用范围；</span></span><br><span class="line"><span class="comment">- 需要返回一个修改后的适用范围的函数，此时需要借用 call 方法实现</span></span><br><span class="line"><span class="comment">- 但是需要处理参数，此时借用 apply 传入参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.unCurry = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// _fn 在本例中是 Array.prototype.push</span></span><br><span class="line">  <span class="keyword">var</span> _fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里有点绕，做个说明：</span></span><br><span class="line">    <span class="comment">// return Function.prototype.call.apply(_fn, arguments);</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 等价于：</span></span><br><span class="line">    <span class="comment">// var fCall = Function.prototype.call;</span></span><br><span class="line">    <span class="comment">// return fCall.apply(_fn, arguments);</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 等价于：</span></span><br><span class="line">    <span class="comment">// return _fn.fCall(...arguments);</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 等价于：</span></span><br><span class="line">    <span class="comment">// return _fn.apply(arguments[0], [].slice.call(arguments, 1));</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 即修改 _fn 中的 this 指向第一个参数，在本例中是 obj，</span></span><br><span class="line">    <span class="comment">// 剩下的参数传入原函数 _fn</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(_fn, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="柯里化扩展"><a href="#柯里化扩展" class="headerlink" title="柯里化扩展"></a>柯里化扩展</h2><p>实现 <code>add(1)(2, 3)(4)(5) = 15</code> 的效果。<br>很多人这里就犯嘀咕了：我怎么知道执行的时机？<br>其实，这里有个忍者技艺：<code>valueOf</code> 和 <code>toString</code>。<br><code>js</code> 在获取当前变量值的时候，会根据语境，隐式调用 <code>valueOf</code> 和 <code>toString</code> 方法进行获取需要的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> allArgs = [];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    allArgs = allArgs.concat(args);</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 字符类型</span></span><br><span class="line">  next.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, allArgs);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 数值类型</span></span><br><span class="line">  next.valueOf = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="literal">null</span>, allArgs);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add = currying(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    sum += <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FE Code </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于 Generator 与 Promise 的异步编程解决方案</title>
      <link href="388.html"/>
      <url>388.html</url>
      
        <content type="html"><![CDATA[<h2 id="先看-async-await-异步解决方案"><a href="#先看-async-await-异步解决方案" class="headerlink" title="先看 async / await 异步解决方案"></a>先看 async / await 异步解决方案</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sleep 函数，返回一个 Promise 对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 循环 100 次</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 等待 100ms 再返回</span></span><br><span class="line">    <span class="keyword">await</span> sleep(<span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="通过-babel-编译成-Generator-与-Promise"><a href="#通过-babel-编译成-Generator-与-Promise" class="headerlink" title="通过 babel 编译成 Generator 与 Promise"></a>通过 babel 编译成 Generator 与 Promise</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_asyncToGenerator</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gen = fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">key, arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> info = gen[key](arg);</span><br><span class="line">          <span class="keyword">var</span> value = info.value;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">          reject(error);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (info.done) &#123;</span><br><span class="line">          resolve(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(value).then(</span><br><span class="line">            <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> step(<span class="string">&#x27;next&#x27;</span>, value);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> step(<span class="string">&#x27;throw&#x27;</span>, err);</span><br><span class="line">            &#125;</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> step(<span class="string">&#x27;next&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ref = _asyncToGenerator(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">yield</span> sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ref.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>从上相关直观的看出来如何使用 <code>Generator</code> 与 <code>Promise</code> 进行的异步解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> FE Code </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）ES6 系列之 let 和 const</title>
      <link href="387.html"/>
      <url>387.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接：<span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNDk1MTY5MT91dG1fc291cmNlPXRhZy1uZXdlc3Q=">https://segmentfault.com/a/1190000014951691?utm_source=tag-newest<i class="fa fa-external-link-alt"></i></span></p></blockquote><h2 id="块级作用域的出现"><a href="#块级作用域的出现" class="headerlink" title="块级作用域的出现"></a>块级作用域的出现</h2><p>通过 <code>var</code> 声明的变量存在变量提升的特性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br></pre></td></tr></table></figure><p>初学者可能会觉得只有 <code>condition</code> 为 <code>true</code> 的时候，才会创建 <code>value</code>，如果 <code>condition</code> 为 <code>false</code>，结果应该是报错，然而因为变量提升的原因，代码相当于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value;</span><br><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">  value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br></pre></td></tr></table></figure><p>如果 <code>condition</code> 为 <code>false</code>，结果会是 <code>undefined</code>。</p><p>除此之外，在 <code>for</code> 循环中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>即便循环已经结束了，我们依然可以访问 <code>i</code> 的值。</p><p>为了加强对变量生命周期的控制，<code>ECMAScript 6</code> 引入了块级作用域。</p><p>块级作用域存在于：</p><ul><li>函数内部</li><li>块中(字符 <code>&#123;</code> 和 <code>&#125;</code>之间的区域)</li></ul><h2 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h2><p>块级声明用于声明在指定块的作用域之外无法访问的变量。</p><p><code>let</code> 和 <code>const</code> 都是块级声明的一种。</p><p>我们来回顾下 <code>let</code> 和 <code>const</code> 的特点：</p><h3 id="不会被提升"><a href="#不会被提升" class="headerlink" title="不会被提升"></a>不会被提升</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// Uncaught ReferenceError: value is not defined</span></span><br></pre></td></tr></table></figure><h3 id="重复声明报错"><a href="#重复声明报错" class="headerlink" title="重复声明报错"></a>重复声明报错</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> value = <span class="number">2</span>; <span class="comment">// Uncaught SyntaxError: Identifier &#x27;value&#x27; has already been declared</span></span><br></pre></td></tr></table></figure><h3 id="不绑定全局作用域"><a href="#不绑定全局作用域" class="headerlink" title="不绑定全局作用域"></a>不绑定全局作用域</h3><p>当在全局作用域中使用 <code>var</code> 声明的时候，会创建一个新的全局变量作为全局对象的属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.value); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>然而 <code>let</code> 和 <code>const</code> 不会：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.value); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>再来说下 <code>let</code> 和 <code>const</code> 的区别：</p><p><code>const</code> 用于声明常量，其值一旦被设定不能再被修改，否则会报错。</p><p>值得一提的是：<code>const</code> 声明不允许修改绑定，但允许修改值。这意味着当用 <code>const</code> 声明对象时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  value: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有问题</span></span><br><span class="line">data.value = <span class="number">2</span>;</span><br><span class="line">data.num = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line">data = &#123;&#125;; <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><h2 id="临时死区"><a href="#临时死区" class="headerlink" title="临时死区"></a>临时死区</h2><p>临时死区(Temporal Dead Zone)，简写为 TDZ。</p><p><code>let</code> 和 <code>const</code> 声明的变量不会被提升到作用域顶部，如果在声明之前访问这些变量，会导致报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> value); <span class="comment">// Uncaught ReferenceError: value is not defined</span></span><br><span class="line"><span class="keyword">let</span> value = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这是因为 <code>JavaScript</code> 引擎在扫描代码发现变量声明时，要么将它们提升到作用域顶部(遇到 <code>var</code> 声明)，要么将声明放在 <code>TDZ</code> 中(遇到 <code>let</code> 和 <code>const</code> 声明)。访问 <code>TDZ</code> 中的变量会触发运行时错误。只有执行过变量声明语句后，变量才会从 <code>TDZ</code> 中移出，然后方可访问。</p><p>看似很好理解，不保证你不犯错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> value = <span class="string">&#x27;local&#x27;</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例子 2</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> value = <span class="string">&#x27;local&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个例子中，结果并不会打印 “global”，而是报错 <code>Uncaught ReferenceError: value is not defined</code>，就是因为 <code>TDZ</code> 的缘故。</p><h2 id="循环中的块级作用域"><a href="#循环中的块级作用域" class="headerlink" title="循环中的块级作用域"></a>循环中的块级作用域</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  funcs[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">funcs[<span class="number">0</span>](); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>一个老生常谈的面试题，解决方案如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  funcs[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">funcs[<span class="number">0</span>](); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p><code>ES6</code> 的 <code>let</code> 为这个问题提供了新的解决方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  funcs[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">funcs[<span class="number">0</span>](); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>问题在于，上面讲了 <code>let</code> 不提升，不能重复声明，不能绑定全局作用域等等特性，可是为什么在这里就能正确打印出 <code>i</code> 值呢？</p><p>如果是不重复声明，在循环第二次的时候，又用 <code>let</code> 声明了 <code>i</code>，应该报错呀，就算因为某种原因，重复声明不报错，一遍一遍迭代，<code>i</code> 的值最终还是应该是 5 呀，还有人说 <code>for</code> 循环的<br>设置循环变量的那部分是一个单独的作用域，就比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure><p>这个例子是对的，如果我们把 <code>let</code> 改成 <code>var</code> 呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure><p>为什么结果就不一样了呢，如果有单独的作用域，结果应该是相同的呀……</p><p>如果要追究这个问题，就要抛弃掉之前所讲的这些特性！这是因为 <code>let</code> 声明在循环内部的行为是标准中专门定义的，不一定就与 <code>let</code> 的不提升特性有关，其实，在早期的 <code>let</code> 实现中就不包含这一行为。</p><p>我们查看 <span class="exturl" data-url="aHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLWZvci1zdGF0ZW1lbnQtcnVudGltZS1zZW1hbnRpY3MtbGFiZWxsZWRldmFsdWF0aW9u">ECMAScript 规范第 13.7.4.7 节<i class="fa fa-external-link-alt"></i></span>，在 <code>for</code> 循环中使用 <code>let</code> 和 <code>var</code>，底层会使用不同的处理方式。</p><p>那么当使用 <code>let</code> 的时候底层到底是怎么做的呢？</p><p>简单的来说，就是在 for <code>(let i = 0; i &lt; 3; i++)</code> 中，即圆括号之内建立一个隐藏的作用域，这就可以解释为什么:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure><p>然后<strong>每次迭代循环时都创建一个新变量，并以之前迭代中同名变量的值将其初始化</strong>。这样对于下面这样一段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  funcs[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">funcs[<span class="number">0</span>](); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>就相当于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line">(<span class="keyword">let</span> i = <span class="number">0</span>) &#123;</span><br><span class="line">funcs[<span class="number">0</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">let</span> i = <span class="number">1</span>) &#123;</span><br><span class="line">funcs[<span class="number">1</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">let</span> i = <span class="number">2</span>) &#123;</span><br><span class="line">funcs[<span class="number">2</span>] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当执行函数的时候，根据词法作用域就可以找到正确的值，其实你也可以理解为 <code>let</code> 声明模仿了闭包的做法来简化循环过程。</p><h2 id="循环中的-let-和-const"><a href="#循环中的-let-和-const" class="headerlink" title="循环中的 let 和 const"></a>循环中的 let 和 const</h2><p>不过到这里还没有结束，如果我们把 <code>let</code> 改成 <code>const</code> 呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  funcs[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">funcs[<span class="number">0</span>](); <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure><p>结果会是报错，因为虽然我们每次都创建了一个新的变量，然而我们却在迭代中尝试修改 <code>const</code> 的值，所以最终会报错。</p><p>说完了普通的 <code>for</code> 循环，我们还有 <code>for in</code> 循环呢~</p><p>那下面的结果是什么呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [],</span><br><span class="line">  object = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span>, <span class="attr">c</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> object) &#123;</span><br><span class="line">  funcs.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcs[<span class="number">0</span>]();</span><br></pre></td></tr></table></figure><p>结果是 <code>&#39;c&#39;</code>;</p><p>那如果把 <code>var</code> 改成 <code>let</code> 或者 <code>const</code> 呢？</p><p>使用 <code>let</code>，结果自然会是 <code>&#39;a&#39;</code>，<code>const</code> 呢？ 报错还是 <code>&#39;a&#39;</code>?</p><p>结果是正确打印 <code>&#39;a&#39;</code>，这是因为在 <code>for in</code> 循环中，每次迭代不会修改已有的绑定，而是会创建一个新的绑定。</p><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>在 <code>Babel</code> 中是如何编译 <code>let</code> 和 <code>const</code> 的呢？我们来看看编译后的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>编译为:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>我们可以看到 <code>Babel</code> 直接将 <code>let</code> 编译成了 <code>var</code>，如果是这样的话，那么我们来写个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">// Uncaught ReferenceError: value is not defined</span></span><br></pre></td></tr></table></figure><p>如果还是直接编译成 <code>var</code>，打印的结果肯定是 <code>undefined</code>，然而 <code>Babel</code> 很聪明，它编译成了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> _value = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br></pre></td></tr></table></figure><p>我们再写个直观的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">value = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> _value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">value = <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>本质是一样的，就是改变量名，使内外层的变量名称不一样。</p><p>那像 <code>const</code> 的修改值时报错，以及重复声明报错怎么实现的呢？</p><p>其实就是在编译的时候直接给你报错……</p><p>那循环中的 <code>let</code> 声明呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  funcs[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">funcs[<span class="number">0</span>](); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p><code>Babel</code> 巧妙的编译成了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> funcs = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _loop = <span class="function"><span class="keyword">function</span> <span class="title">_loop</span>(<span class="params">i</span>) </span>&#123;</span><br><span class="line">  funcs[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  _loop(i);</span><br><span class="line">&#125;</span><br><span class="line">funcs[<span class="number">0</span>](); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p>在我们开发的时候，可能认为应该默认使用 <code>let</code> 而不是 <code>var</code>，这种情况下，对于需要写保护的变量要使用 <code>const</code>。然而另一种做法日益普及：默认使用 <code>const</code>，只有当确实需要改变变量的值的时候才使用 <code>let</code>。这是因为大部分的变量的值在初始化后不应再改变，而预料之外的变量之的改变是很多 <code>bug</code> 的源头。</p>]]></content>
      
      
      <categories>
          
          <category> FE Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数组方法 forEach、filter、every、some、map、reduce 实现等相关记录</title>
      <link href="386.html"/>
      <url>386.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>总结至 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcv">MDN<i class="fa fa-external-link-alt"></i></span></p></blockquote><h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p><code>forEach()</code> 方法按升序为数组中含有效值的每一项执行一次 <code>callback</code> 函数，那些已删除或者未初始化的项将被跳过。</p><h3 id="forEach-语法"><a href="#forEach-语法" class="headerlink" title="forEach 语法"></a>forEach 语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(callback(currentValue [, index [, array]])[, thisArg]);</span><br></pre></td></tr></table></figure><h3 id="forEach-参数"><a href="#forEach-参数" class="headerlink" title="forEach 参数"></a>forEach 参数</h3><ul><li><code>callback</code>: 为数组中每个元素执行的函数，该函数接收三个参数</li><li><code>currentValue</code>: 数组中正在处理的当前元素</li><li><code>index</code>(可选): 数组中正在处理的当前元素的索引</li><li><code>array</code>(可选): <code>forEach()</code> 方法正在操作的数组</li><li><code>thisArg</code>(可选): 当执行回调函数 <code>callback</code> 时，用作 <code>this</code> 的值</li></ul><h3 id="forEach-返回值"><a href="#forEach-返回值" class="headerlink" title="forEach 返回值"></a>forEach 返回值</h3><p><code>undefined</code></p><h3 id="forEach-Polyfill"><a href="#forEach-Polyfill" class="headerlink" title="forEach Polyfill"></a>forEach Polyfill</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.forEach) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.forEach = <span class="function"><span class="keyword">function</span> (<span class="params">callback, thisArg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> T, k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27; this is null or not defined&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> O = <span class="built_in">Object</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> len = O.length &gt;&gt;&gt; <span class="number">0</span>; <span class="comment">//头部补零的右移运算符,表示将一个数的二进制值向右移动指定的位数.此处的目的是将任意值转化为Number，且不会出现NaN</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">&#x27; is not a function&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      T = thisArg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">      <span class="keyword">var</span> kValue;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">        kValue = O[k];</span><br><span class="line">        callback.call(T, kValue, k, O);</span><br><span class="line">      &#125;</span><br><span class="line">      k++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><h3 id="filter-描述"><a href="#filter-描述" class="headerlink" title="filter 描述"></a>filter 描述</h3><p><code>filter</code> 为数组中的每个元素调用一次 <code>callback</code> 函数，并利用所有使得 <code>callback</code> 返回 <code>true</code> 或等价于 <code>true</code> 的值的元素创建一个新数组。</p><p><code>callback</code> 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 <code>callback</code> 测试的元素会被跳过，不会被包含在新数组中。</p><p><code>filter</code> 不会改变原数组，它返回过滤后的新数组。</p><p><code>filter</code> 遍历的元素范围在第一次调用 <code>callback</code> 之前就已经确定了。在调用 <code>filter</code> 之后被添加到数组中的元素不会被 <code>filter</code> 遍历到。</p><h3 id="filter-语法"><a href="#filter-语法" class="headerlink" title="filter 语法"></a>filter 语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArray = arr.filter(callback(element[, index[, array]])[, thisArg])</span><br></pre></td></tr></table></figure><h3 id="filter-参数"><a href="#filter-参数" class="headerlink" title="filter 参数"></a>filter 参数</h3><ul><li><code>callback</code>: 用来测试数组的每个元素的函数。返回 true 表示该元素通过测试，保留该元素，false 则不保留。</li><li><code>element</code>: 数组中正在处理的当前元素</li><li><code>index</code>(可选): 数组中正在处理的当前元素的索引</li><li><code>array</code>(可选): 调用了 <code>filter</code> 的数组本身</li><li><code>thisArg</code>(可选): 当执行回调函数 <code>callback</code> 时，用作 <code>this</code> 的值</li></ul><h3 id="filter-返回值"><a href="#filter-返回值" class="headerlink" title="filter 返回值"></a>filter 返回值</h3><p>一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。</p><h3 id="filter-Polyfill"><a href="#filter-Polyfill" class="headerlink" title="filter Polyfill"></a>filter Polyfill</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.filter) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.filter = <span class="function"><span class="keyword">function</span> (<span class="params">func, thisArg</span>) </span>&#123;</span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (!((<span class="keyword">typeof</span> func === <span class="string">&#x27;Function&#x27;</span> || <span class="keyword">typeof</span> func === <span class="string">&#x27;function&#x27;</span>) &amp;&amp; <span class="built_in">this</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> len = <span class="built_in">this</span>.length &gt;&gt;&gt; <span class="number">0</span>,</span><br><span class="line">      res = <span class="keyword">new</span> <span class="built_in">Array</span>(len),</span><br><span class="line">      t = <span class="built_in">this</span>,</span><br><span class="line">      c = <span class="number">0</span>,</span><br><span class="line">      i = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      T = thisArg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (++i !== len) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i <span class="keyword">in</span> <span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (func.call(T, t[i], i, t)) &#123;</span><br><span class="line">          res[c++] = t[i];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res.length = c;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="every"><a href="#every" class="headerlink" title="every"></a>every</h2><h3 id="every-描述"><a href="#every-描述" class="headerlink" title="every 描述"></a>every 描述</h3><p><code>every</code> 方法为数组中的每个元素执行一次 <code>callback</code> 函数，直到它找到一个会使 <code>callback</code> 返回 <code>falsy</code> 的元素。如果发现了一个这样的元素，<code>every</code> 方法将会立即返回 <code>false</code>。否则，<code>callback</code> 为每一个元素返回 <code>true</code>，<code>every</code> 就会返回 <code>true</code>。</p><p><code>every</code> 遍历的元素范围在第一次调用 <code>callback</code> 之前就已确定了。在调用 <code>every</code> 之后添加到数组中的元素不会被 <code>callback</code> 访问到。如果数组中存在的元素被更改，则他们传入 <code>callback</code> 的值是 <code>every</code> 访问到他们那一刻的值。那些被删除的元素或从来未被赋值的元素将不会被访问到。</p><p><code>every</code> 不会改变原数组。</p><p>若收到一个空数组，此方法在一切情况下都会返回 <code>true</code>。</p><h3 id="every-语法"><a href="#every-语法" class="headerlink" title="every 语法"></a>every 语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.every(callback(element [, index [, array]])[, thisArg])</span><br></pre></td></tr></table></figure><h3 id="every-参数"><a href="#every-参数" class="headerlink" title="every 参数"></a>every 参数</h3><ul><li><code>callback</code>: 用来测试每个元素的函数，它可以接收三个参数</li><li><code>element</code>: 用于测试的当前值</li><li><code>index</code>(可选): 用于测试的当前值的索引</li><li><code>array</code>(可选): 调用 <code>every</code> 的当前数组</li><li><code>thisArg</code>(可选): 当执行回调函数 <code>callback</code> 时，用作 <code>this</code> 的值</li></ul><h3 id="every-返回值"><a href="#every-返回值" class="headerlink" title="every 返回值"></a>every 返回值</h3><p>如果回调函数的每一次返回都为 <code>truthy</code> 值，返回 <code>true</code> ，否则返回 <code>false</code>。</p><h3 id="every-Polyfill"><a href="#every-Polyfill" class="headerlink" title="every Polyfill"></a>every Polyfill</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.every) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.every = <span class="function"><span class="keyword">function</span> (<span class="params">callbackfn, thisArg</span>) </span>&#123;</span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> T, k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;this is null or not defined&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> O = <span class="built_in">Object</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> len = O.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callbackfn !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      T = thisArg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">      <span class="keyword">var</span> kValue;</span><br><span class="line">      <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">        kValue = O[k];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> testResult = callbackfn.call(T, kValue, k, O);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!testResult) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="some"><a href="#some" class="headerlink" title="some"></a>some</h2><h3 id="some-描述"><a href="#some-描述" class="headerlink" title="some 描述"></a>some 描述</h3><p><code>some()</code> 为数组中的每一个元素执行一次 <code>callback</code> 函数，直到找到一个使得 <code>callback</code> 返回一个“真值”（即可转换为布尔值 <code>true</code> 的值）。如果找到了这样一个值，<code>some()</code> 将会立即返回 <code>true</code>。否则，<code>some()</code> 返回 <code>false</code>。</p><p><code>some()</code> 被调用时不会改变数组。</p><p><code>some()</code> 遍历的元素的范围在第一次调用 <code>callback</code>. 前就已经确定了。在调用 <code>some()</code> 后被添加到数组中的值不会被 <code>callback</code> 访问到。如果数组中存在且还未被访问到的元素被 <code>callback</code> 改变了，则其传递给 <code>callback</code> 的值是 <code>some()</code> 访问到它那一刻的值。已经被删除的元素不会被访问到。</p><h3 id="some-语法"><a href="#some-语法" class="headerlink" title="some 语法"></a>some 语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.some(callback(element[, index[, array]])[, thisArg])</span><br></pre></td></tr></table></figure><h3 id="some-参数"><a href="#some-参数" class="headerlink" title="some 参数"></a>some 参数</h3><ul><li><code>callback</code>: 用来测试每个元素的函数，接受三个参数</li><li><code>element</code>: 数组中正在处理的元素</li><li><code>index</code>(可选): 数组中正在处理的元素的索引值</li><li><code>array</code>(可选): <code>some()</code> 被调用的数组</li><li><code>thisArg</code>(可选): 执行 <code>callback</code> 时使用的 <code>this</code> 值</li></ul><h3 id="some-返回值"><a href="#some-返回值" class="headerlink" title="some 返回值"></a>some 返回值</h3><p>数组中有至少一个元素通过回调函数的测试就会返回 <code>true</code>, 所有元素都没有通过回调函数的测试返回值才会为 <code>false</code>。</p><h3 id="some-Polyfill"><a href="#some-Polyfill" class="headerlink" title="some Polyfill"></a>some Polyfill</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.some) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.some = <span class="function"><span class="keyword">function</span> (<span class="params">fun, thisArg</span>) </span>&#123;</span><br><span class="line"><span class="meta">    &#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Array.prototype.some called on null or undefined&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fun !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> t = <span class="built_in">Object</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">var</span> len = t.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> thisArg = <span class="built_in">arguments</span>.length &gt;= <span class="number">2</span> ? <span class="built_in">arguments</span>[<span class="number">1</span>] : <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (i <span class="keyword">in</span> t &amp;&amp; fun.call(thisArg, t[i], i, t)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h3 id="map-描述"><a href="#map-描述" class="headerlink" title="map 描述"></a>map 描述</h3><p><code>map</code> 方法会给原数组中的每个元素都按顺序调用一次 <code>callback</code> 函数。<code>callback</code> 每次执行后的返回值（包括 <code>undefined</code>）组合起来形成一个新数组。 <code>callback</code> 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 <code>delete</code> 删除的索引则不会被调用。</p><p>因为 <code>map</code> 生成一个新数组，当你不打算使用<strong>返回的新数组</strong>却使用 <code>map</code> 是违背设计初衷的，请用 <code>forEach</code> 或者 <code>for-of</code> 替代。</p><p><code>map</code> 不修改调用它的原数组本身（当然可以在 <code>callback</code> 执行时改变原数组）。</p><p><code>map</code> 方法处理数组元素的范围是在 <code>callback</code> 方法第一次调用之前就已经确定了。调用 map 方法之后追加的数组元素不会被 <code>callback</code> 访问。如果存在的数组元素改变了，那么传给 <code>callback</code> 的值是 <code>map</code> 访问该元素时的值。</p><h3 id="map-语法"><a href="#map-语法" class="headerlink" title="map 语法"></a>map 语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArray = arr.map(callback(currentValue[, index[, array]])[, thisArg])</span><br></pre></td></tr></table></figure><h3 id="map-参数"><a href="#map-参数" class="headerlink" title="map 参数"></a>map 参数</h3><ul><li><code>callback</code>: 生成新数组元素的函数，接受三个参数</li><li><code>currentValue</code>: <code>callback</code> 数组中正在处理的当前元素</li><li><code>index</code>(可选): <code>callback</code> 数组中正在处理的当前元素的索引</li><li><code>array</code>(可选): <code>map</code> 方法调用的数组</li><li><code>thisArg</code>(可选): 执行 <code>callback</code> 时使用的 <code>this</code> 值</li></ul><h3 id="map-返回值"><a href="#map-返回值" class="headerlink" title="map 返回值"></a>map 返回值</h3><p>返回一个新数组，回调函数的结果组成了新数组的每一个元素。</p><h3 id="map-Polyfill"><a href="#map-Polyfill" class="headerlink" title="map Polyfill"></a>map Polyfill</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.map) &#123;</span><br><span class="line">  <span class="built_in">Array</span>.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">callback, thisArg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> T, A, k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;this is null or not defined&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> O = <span class="built_in">Object</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> len = O.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">&#x27; is not a function&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      T = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    A = <span class="keyword">new</span> <span class="built_in">Array</span>(len);</span><br><span class="line"></span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">      <span class="keyword">var</span> kValue, mappedValue;</span><br><span class="line">      <span class="keyword">if</span> (k <span class="keyword">in</span> O) &#123;</span><br><span class="line">        kValue = O[k];</span><br><span class="line">        mappedValue = callback.call(T, kValue, k, O);</span><br><span class="line">        A[k] = mappedValue;</span><br><span class="line">      &#125;</span><br><span class="line">      k++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> A;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><h3 id="reduce-描述"><a href="#reduce-描述" class="headerlink" title="reduce 描述"></a>reduce 描述</h3><p><code>reduce</code> 为数组中的每一个元素依次执行 <code>callback</code> 函数，不包括数组中被删除或从未被赋值的元素。</p><p><code>callback</code> 第一次执行时，如果提供了 <code>initialValue</code>，<code>accumulator</code> 取值为 <code>initialValue</code>，<code>currentValue</code> 取数组中的第一个值，<code>reduce</code> 会从索引 0 的地方开始执行 <code>callback</code> 方法；如果没有提供 <code>initialValue</code>，那么 <code>accumulator</code> 取数组中的第一个值，<code>currentValue</code> 取数组中的第二个值，<code>reduce</code> 会从索引 1 的地方开始执行 <code>callback</code> 方法。</p><p>如果数组仅有一个元素（无论位置如何）并且没有提供 <code>initialValue</code>， 或者有提供 <code>initialValue</code> 但是数组为空，那么此唯一值将被返回并且 <code>callback</code> 不会被执行。</p><h3 id="reduce-语法"><a href="#reduce-语法" class="headerlink" title="reduce 语法"></a>reduce 语法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</span><br></pre></td></tr></table></figure><h3 id="reduce-参数"><a href="#reduce-参数" class="headerlink" title="reduce 参数"></a>reduce 参数</h3><ul><li><code>callback</code>: 执行数组中每个值 (如果没有提供 <code>initialValue</code> 则第一个值除外)的函数，包含四个参数</li><li><code>accumulator</code>: 累计器累计回调的返回值; 它是上一次调用回调时返回的累积值，或 <code>initialValue</code></li><li><code>currentValue</code>: <code>callback</code> 数组中正在处理的当前元素</li><li><code>index</code>(可选): 数组中正在处理的当前元素的索引。 如果提供了 <code>initialValue</code>，则起始索引号为 0，否则从索引 1 起始。</li><li><code>array</code>(可选): 调用 <code>reduce()</code> 的数组</li><li><code>initialValue</code>(可选): 作为第一次调用 <code>callback</code> 函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 在没有初始值的空数组上调用 <code>reduce</code> 将报错。</li></ul><h3 id="reduce-返回值"><a href="#reduce-返回值" class="headerlink" title="reduce 返回值"></a>reduce 返回值</h3><p>函数累计处理的结果</p><h3 id="reduce-Polyfill"><a href="#reduce-Polyfill" class="headerlink" title="reduce Polyfill"></a>reduce Polyfill</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Array</span>.prototype.reduce) &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">Array</span>.prototype, <span class="string">&#x27;reduce&#x27;</span>, &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span> (<span class="params">callback, initialValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Array.prototype.reduce &#x27;</span> + <span class="string">&#x27;called on null or undefined&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(callback + <span class="string">&#x27; is not a function&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> o = <span class="built_in">Object</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> len = o.length &gt;&gt;&gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> k = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">var</span> value;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        value = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; len &amp;&amp; !(k <span class="keyword">in</span> o)) &#123;</span><br><span class="line">          k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &gt;= len) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Reduce of empty array &#x27;</span> + <span class="string">&#x27;with no initial value&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        value = o[k++];</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (k &lt; len) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k <span class="keyword">in</span> o) &#123;</span><br><span class="line">          value = callback(value, o[k], k, o);</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p><code>flat</code>？</p><p>即将多维数组拍平（flatten）为一维数组。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrap</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">flat</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">of</span> a) &#123;</span><br><span class="line">      <span class="keyword">if</span> (item.constructor === <span class="built_in">Array</span>) &#123;</span><br><span class="line">        ret.concat(flat(item));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret.push(item);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(wrap()(arr));</span><br></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flatten = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (arr.some(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">    arr = [].concat(...arr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(flatten(arr));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FE Code </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（十四）：webpack 优化</title>
      <link href="385.html"/>
      <url>385.html</url>
      
        <content type="html"><![CDATA[<p>前面一至十一章，介绍了在 <code>development</code> 的模式下，整个完整了构建主流程。在了解构建流程的基础上，本章整理一些与 <code>webpack</code> 优化相关的知识点。</p><h2 id="production-模式"><a href="#production-模式" class="headerlink" title="production 模式"></a>production 模式</h2><p>我们参考 <code>production</code> 模式里，里面已经做了大部分的优化，如压缩，<code>Scope Hoisting</code>， <code>tree-shaking</code> 等都给予了我们启发，接下来具体分析各个点。</p><h3 id="production-模式启用的插件"><a href="#production-模式启用的插件" class="headerlink" title="production 模式启用的插件"></a>production 模式启用的插件</h3><ul><li><code>FlagDependencyUsagePlugin</code><ul><li>触发时机：<code>compilation.hooks.optimizeDependencies</code></li><li>功能：标记模块导出中被使用的导出，存在 <code>module.usedExports</code> 里。用于 <code>Tree shaking</code>。</li><li>对应配置项：<code>optimization.usedExports:true</code></li></ul></li><li><code>FlagIncludedChunksPlugin</code><ul><li>触发时机：<code>compilation.hooks.optimizeChunkId</code></li><li>功能：给每个 <code>chunk</code> 添加了 <code>ids</code>，用于判断避免加载不必要的 <code>chunk</code></li></ul></li><li><code>ModuleConcatenationPlugin</code><ul><li>触发时机：<code>compilation.hooks.optimizeChunkModules</code></li><li>功能：使用 <code>esm</code> 语法可以作用域提升(<code>Scope Hoisting</code>)或预编译所有模块到一个闭包中，提升代码在浏览器中的执行速度</li><li>对应配置项：<code>optimization.concatenateModules:true</code></li></ul></li><li><code>NoEmitOnErrorsPlugin</code><ul><li>触发时机：<code>compiler.hooks.shouldEmit</code>，<code>compilation.hooks.shouldRecord</code></li><li>功能：如果在 <code>compilation</code> 编译时有 <code>error</code>，则不执行 <code>Record</code> 相关的钩子，并且抛错和不编译资源</li></ul></li><li><code>OccurrenceOrderModuleIdsPlugin</code>，<code>OccurrenceOrderChunkIdsPlugin</code><ul><li>注意不是<span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL21vZGUvI3Jvb3Q=">文档<i class="fa fa-external-link-alt"></i></span>写的 <code>OccurrenceOrderPlugin</code>，这个没用</li><li>触发时机：<code>compilation.hooks.optimizeModuleOrder</code>，<code>compilation.hooks.optimizeChunkOrder</code></li><li>功能：根据模块初始调用次数或者总调用次数排序（<span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmRvY3NjaGluYS5vcmcvY29uZmlndXJhdGlvbi9vcHRpbWl6YXRpb24vI29wdGltaXphdGlvbi1tb2R1bGVpZHM=">配置<i class="fa fa-external-link-alt"></i></span>），这样在后面分配 <code>ID</code> 的时候常被调用 <code>ID</code> 就靠前，除此之外，还可以让 <code>id</code> 为路径，<code>hash</code> 等。</li><li>对应配置项：<code>optimization.occurrenceOrder</code>，<code>optimization.chunkIds</code>，<code>optimization.moduleIds</code></li></ul></li><li><code>SideEffectsFlagPlugin</code><ul><li>触发时机：<code>normalModuleFactory.hooks.module</code>，<code>compilation.hooks.optimizeDependencies</code></li><li>功能：<ul><li><code>normalModuleFactory.hooks.module</code> 钩子里读取 <code>package.json</code> 里的 <code>sideEffects</code> 字段和读取 <code>module.rule</code> 里的 <code>sideEffects</code> 赋给 <code>module.factoryMeta</code>（纯的 <code>ES2015</code> 模块)；</li><li><code>compilation.hooks.optimizeDependencies</code> 钩子里根据 <code>sideEffects</code> 配置，删除未用到的 <code>export</code> 导出</li></ul></li><li>对应配置项：<code>optimization.sideEffects:true</code>（默认）</li></ul></li><li><code>TerserPlugin</code><ul><li>触发时机：<code>template.hooks.hashForChunk</code>，<code>compilation.hooks.optimizeChunkAssets</code></li><li>功能：<ul><li>在 <code>template.hooks.hashForChunk</code> 钩子即在 <code>chunks</code> 生成 <code>hash</code> 阶段会把压缩相关的信息也打入到里面</li><li>在 <code>compilation.hooks.optimizeChunkAssets</code> 钩子触发资源压缩事件</li></ul></li><li>对应配置项：<ul><li><code>optimization.minimize</code> 是否开启压缩</li><li><code>optimization.minimizer</code> 定制 <code>Terser</code>，默认开启多进程压缩和缓存</li></ul></li></ul></li></ul><p>另：<code>development</code> 模式单独启用的插件：</p><ul><li><code>NamedChunksPlugin</code><ul><li>触发时机：<code>compilation.hooks.beforeChunkIds</code></li><li>功能：以名称固化 <code>chunk id</code></li><li>对应配置项：<code>optimization.chunkIds</code></li></ul></li><li><code>NamedModulesPlugin</code><ul><li>触发时机：<code>compilation.hooks.beforeModuleIds</code></li><li>功能：以名称固化 <code>module id</code></li><li>对应配置项：<code>optimization.moduleIds</code></li></ul></li></ul><h2 id="持久化缓存"><a href="#持久化缓存" class="headerlink" title="持久化缓存"></a>持久化缓存</h2><blockquote><p>在更新部署页面资源时，无论是先部署页面，还是先部署其他静态资源，都会因为新老资源替换后的缓存原因，或者部署间隔原因，都会导致资源不对应而引起页面错误。</p></blockquote><p>持久化缓存方案就是在各静态资源的名字后面加唯一的 <code>hash</code> 值，这样在每次修改文件后生成的不同的 <code>hash</code> 值，然后在增量式发布文件时，就可以避免覆盖掉之前旧的文件。获取到新文件的用户就可以访问新的资源，而浏览器有缓存等情况的用户则继续访问老资源，保证新老资源同时存在且互不影响不出错。</p><ul><li>对于 <code>html</code>：不开启缓存，把 <code>html</code> 放到单独的服务器上并关闭服务器的缓存，需要保证每次的 <code>html</code> 都为最新</li><li>对于 <code>js</code>，<code>css</code>，<code>img</code> 等其他静态资源：开启缓存，将静态资源上传到 <code>cdn</code>，对资源开启长期缓存，因为有唯一 <code>hash</code> 的缘故所以不会导致资源被覆盖，用户在初次访问可以将这些长效缓存下载到本地，然后在后续的访问可以直接从缓存里读，节约网络资源。</li></ul><h3 id="webpack-中的持久化缓存"><a href="#webpack-中的持久化缓存" class="headerlink" title="webpack 中的持久化缓存"></a>webpack 中的持久化缓存</h3><ul><li>对 <code>js</code> 使用 <code>chunkhash</code> ，对 <code>css</code> 应用 <code>mini-css-extract-plugin</code> 插件并使用 <code>contenthash</code></li><li>通过 <code>optimization.moduleIds</code> 属性设置 <code>module id</code><ul><li>开发环境 <code>moduleIds</code> 设为 <code>named</code> 即使用 <code>NamedModulesPlugin</code> （相对路径为 <code>key</code>）来固化 <code>module id</code>，</li><li>生产环境 <code>moduleIds</code> 设为 <code>hashed</code> 即使用 <code>HashedModuleIdsPlugin</code> （将路径转换为 <code>hash</code> 为 <code>key</code>）来固化 <code>module id</code>，保证在某一模块增删后，不会影响其他模块的 <code>module id</code></li></ul></li><li>通过 <code>optimization.chunkIds</code> 属性设置为 <code>named</code> 或 <code>optimization.namedChunks</code> 属性设置为 <code>true</code> （通过将 <code>chunk name</code> 复制到 <code>chunk id</code>）固化 <code>chunk id</code>，该属性会启用 <code>NamedChunksPlugin</code><ul><li><code>NamedChunksPlugin</code> 插件里可以自定义 <code>nameResolver</code> 设置 <code>name</code></li><li><code>splitChunks.cacheGroups[].name</code> 也可以设置 <code>chunk name</code></li><li><span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9hcGkvbW9kdWxlLW1ldGhvZHMvI21hZ2ljLWNvbW1lbnRz">魔法注释<i class="fa fa-external-link-alt"></i></span>也可以设置：<code>import(/* webpackChunkName: &quot;my-chunk-name&quot; */ &#39;module&#39;)</code></li></ul></li><li>通过 <code>optimization.splitChunks</code> 属性抽离库 <code>vendor</code>，业务公共代码 <code>common</code></li><li>通过 <code>optimization.runtimeChunk</code> 属性抽离运行时 <code>runtime</code>，其中 <code>runtime</code> 也可以通过 <code>script-ext-html-webpack-plugin</code> 插件嵌入到 <code>html</code></li></ul><h2 id="Tree-Sharing"><a href="#Tree-Sharing" class="headerlink" title="Tree Sharing"></a>Tree Sharing</h2><p><code>Tree Sharing</code> 是一个术语，通常用于描述移除 <code>JavaScript</code> 上下文中的未引用代码(<code>dead-code</code>)。由 <span class="exturl" data-url="aHR0cHM6Ly9yb2xsdXBqcy5vcmcvZ3VpZGUvZW4v">rollup<i class="fa fa-external-link-alt"></i></span> 普及，在 <code>webpack</code> 里由 <code>TerserPlugin</code> 实现。</p><h3 id="tree-sharing-原理"><a href="#tree-sharing-原理" class="headerlink" title="tree-sharing 原理"></a>tree-sharing 原理</h3><ul><li><code>ES6</code> 的模块引入是静态分析的，故而可以在编译时正确判断到底加载了什么代码</li><li>分析程序流，判断哪些变量未被使用、引用，进而删除此代码</li></ul><p>如果我们引入的模块被标记为 <code>sideEffects: false</code>，只要它任意一个导出都没有被其他模块引用到，那么不管它是否真的有副作用，整个模块都会被完整的移除。</p><blockquote><p>“<code>side effect</code>(副作用)” 的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 <code>export</code> 或多个 <code>export</code>。举例说明，例如 <code>polyfill</code>，它影响全局作用域，并且通常不提供 <code>export</code>。</p></blockquote><h3 id="启用-tree-shaking-需要满足"><a href="#启用-tree-shaking-需要满足" class="headerlink" title="启用 tree shaking 需要满足"></a>启用 <code>tree shaking</code> 需要满足</h3><ul><li>使用 <code>ES2015</code> 模块语法（即 <code>import</code> 和 <code>export</code>），目的是为了供程序静态分析</li><li>确保没有 <code>compiler</code> 将 <code>ES2015</code> 模块语法转换为 <code>CommonJS</code> 模块（设置 <code>babel.config.js</code> <code>presets: [[&#39;@babel/env&#39;, &#123; modules: false &#125;]]</code>）</li><li>在 <code>package.json</code> 或者 <code>module.rule</code> 设置 <code>sideEffects : false</code>，告诉 <code>webpack</code> 该项目或者该文件没有副作用</li><li>mode 选项设置为 <code>production</code>，其中会启用 <code>FlagDependencyUsagePlugin</code>，<code>TerserPlugin</code> 完成 <code>tree shaking</code></li></ul><h2 id="Scope-Hoisting"><a href="#Scope-Hoisting" class="headerlink" title="Scope Hoisting"></a>Scope Hoisting</h2><p><code>Scope Hoisting</code> 即 作用域提升，可以让 <code>webpack</code> 打包出来的代码文件更小，运行更快。</p><h3 id="Scope-Hoisting-优点"><a href="#Scope-Hoisting-优点" class="headerlink" title="Scope Hoisting 优点"></a>Scope Hoisting 优点</h3><ul><li>代码体积会变小，因为函数声明语句会产生大量代码</li><li>代码在运行时因为创建的函数作用域减少了，内存开销也随之变小</li></ul><h3 id="Scope-Hoisting-原理"><a href="#Scope-Hoisting-原理" class="headerlink" title="Scope Hoisting 原理"></a>Scope Hoisting 原理</h3><p><code>ES6</code> 的静态模块分析，分析出模块之间的依赖关系，按照引用顺序尽可能地把模块放到同一个函数作用域中，然后适当的重命名一些变量以防止变量名冲突。</p><blockquote><p>异步 <code>import()</code> 不会启用 <code>Scope Hoisting</code></p></blockquote><h3 id="启用-Scope-Hoisting-需要满足"><a href="#启用-Scope-Hoisting-需要满足" class="headerlink" title="启用 Scope Hoisting 需要满足"></a>启用 Scope Hoisting 需要满足</h3><ul><li>使用 <code>ES2015</code> 模块语法（即 <code>import</code> 和 <code>export</code>）</li><li><code>mode</code> 选项设置为 <code>production</code>，其中会启用 <code>ModuleConcatenationPlugin</code> 插件完成 <code>Scope Hoisting</code></li></ul><h2 id="一些插件"><a href="#一些插件" class="headerlink" title="一些插件"></a>一些插件</h2><p>以下列举部分我用过优化相关的插件及 <code>loader</code>：</p><ol><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtaXJlaC9oYXBweXBhY2s=">happypack<i class="fa fa-external-link-alt"></i></span> 多线程编译，加快编译速度 注：已被废弃，使用 <span class="exturl" data-url="aHR0cHM6Ly93d3cud2VicGFja2pzLmNvbS9sb2FkZXJzL3RocmVhZC1sb2FkZXIv">thread-loader<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL251eHQvd2VicGFja2Jhcg==">webpackbar<i class="fa fa-external-link-alt"></i></span> 编译进度条</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9taW5pLWNzcy1leHRyYWN0LXBsdWdpbg==">mini-css-extract-plugin<i class="fa fa-external-link-alt"></i></span> 提取 <code>css</code> 样式到单独文件</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL251bWljYWwvc3R5bGUtZXh0LWh0bWwtd2VicGFjay1wbHVnaW4=">style-ext-html-webpack-plugin<i class="fa fa-external-link-alt"></i></span> 增强 <code>HtmlWebpackPlugin</code>，将 <code>css</code> 内联到 <code>html</code> 里</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL251bWljYWwvc2NyaXB0LWV4dC1odG1sLXdlYnBhY2stcGx1Z2lu">script-ext-html-webpack-plugin<i class="fa fa-external-link-alt"></i></span> 增强 <code>HtmlWebpackPlugin</code>，将 <code>js</code> 内联到 <code>html</code> 里</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL05NRlIvb3B0aW1pemUtY3NzLWFzc2V0cy13ZWJwYWNrLXBsdWdpbg==">optimize-css-assets-webpack-plugin<i class="fa fa-external-link-alt"></i></span> 使用<span class="exturl" data-url="aHR0cDovL2dpdGh1Yi5jb20vYmVuLWViL2Nzc25hbm8=">cssnano<i class="fa fa-external-link-alt"></i></span>压缩优化 <code>css</code></li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi93ZWJwYWNrLWJ1bmRsZS1hbmFseXplcg==">webpack-bundle-analyzer<i class="fa fa-external-link-alt"></i></span> 模块分析</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi91cmwtbG9hZGVy">url-loader<i class="fa fa-external-link-alt"></i></span> 将文件转换为 <code>DataURL</code>，减少请求数</li><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3N0ZXBoZW5jb29rZGV2L3NwZWVkLW1lYXN1cmUtd2VicGFjay1wbHVnaW4=">speed-measure-webpack-plugin<i class="fa fa-external-link-alt"></i></span> 构建耗时分析</li></ol><p>各插件随着时间推移，有的可能废弃，有的可能被更好的所替代，已社区流行为准。</p><h2 id="一些其他优化点"><a href="#一些其他优化点" class="headerlink" title="一些其他优化点"></a>一些其他优化点</h2><ol><li>缓存二次构建，如 <code>babel-loader</code>，<code>terser-webpack-plugin</code> 开启缓存，使用 <code>cache-loader</code>，使用 <code>hard-source-webpack-plugin</code>(已被 <code>webpack5</code> 内置) 等</li><li>分包构建，如 <code>DLLPlugin+DllRefrencePlugin</code> 等</li><li>缩小构建范围，如 <code>module.rules</code> 里 <code>include/exclude</code>，配置 <code>resolve.modules/resolve.mainFields/resolve.extensions</code> ,配置 <code>noParse</code>，配置 <code>externals</code>， 配置 <code>IgnorePlugin</code> 等</li></ol><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>从 <code>webpack</code> 源码开始，到后面打包结果分析、<code>watch</code>、<code>webpack</code> 优化总结等，前前后后花了一个月的时间，但收获也颇多。由于对 webpack 主流程的执行有了大概的认知，在遇到一些配置需要深入了解专研的时候，能快速定位在流程的哪个环节；在开发一个 loader 或者 plugin 也能有很清晰的思路；最重要的是通过对源码分析，大型工程的组织架构，扩展性，健壮性等给人带来一些新的思路和启发。</p><p>本系列到此结束，后续会不断的更新优化。对 <code>webpack</code> 的主流程分析解除了我心中很多的构建相关的疑惑，解开了心中的结。人生短短数十载，精力、时间都很有限，选择做让自己开发的事情，方为上策。</p><p><code>webpack5.0</code> 已到，后续有时间会分析与 <code>webpack 4.x</code> 不同的源码差异。</p><p>如有错误，请联系笔者。分析码字不易，转载请表明出处，谢谢！</p>]]></content>
      
      
      <categories>
          
          <category> FE Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（十三）：watch</title>
      <link href="384.html"/>
      <url>384.html</url>
      
        <content type="html"><![CDATA[<p>前面分析了 <code>webpack</code> 的普通主流程构建，另外，通过设置 <code>watch</code> 模式，<code>webpack</code> 可以监听文件变化，当它们修改后会重新编译。<span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL3dhdGNoLyNyb290">文档<i class="fa fa-external-link-alt"></i></span></p><blockquote><p><code>webpack-dev-server</code> 和 <code>webpack-dev-middleware</code> 里 <code>Watch</code> 模式默认开启。</p></blockquote><p>接下来设置 <code>cli</code> 命令加上 <code>--watch</code> 之后 对 <code>watch</code> 模式下的主流程进行分析（<code>mode = development</code>）。</p><h2 id="初次构建"><a href="#初次构建" class="headerlink" title="初次构建"></a>初次构建</h2><h3 id="资源构建"><a href="#资源构建" class="headerlink" title="资源构建"></a>资源构建</h3><p>代码执行后，跟主流程类似，执行到之前文章介绍到的 <code>编译前的准备 -&gt; 回到 cli.js</code> 里，读取到 <code>options.watchOptions</code> 等 <code>watch</code> 配置后，走 <code>compiler.watch</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">compiler.watch(watchOptions, compilerCallback);</span><br></pre></td></tr></table></figure><p>该方法初始化一些属性后，<code>new</code> 一个 <code>Watching</code> 实例并返回。</p><p>在 <code>Watching</code> 实例化的过程中（文件 <code>webpack/lib/Watching.js</code>），先对 <code>watchOptions</code> 进行了处理后，在 <code>compiler.readRecords</code> 的回调里执行 <code>_go</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Watching.js</span></span><br><span class="line"><span class="built_in">this</span>.compiler.readRecords(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">this</span>._go();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>_go</code> 与 <code>Compiler</code> 里的 <code>run</code> 很类似。 在 <code>_go</code> 里，触发 <code>compiler.hooks</code>:<code>watchRun</code>，执行插件 <code>CachePlugin</code> 设置 <code>this.watching = true</code>。与 <code>webpack</code> 普通构建一致，在钩子 <code>watchRun</code> 回调里执行 <code>compiler.compile</code> 开始构建，在资源构建结束后执行 <code>onCompiled</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Watching.js</span></span><br><span class="line"><span class="function"><span class="title">_go</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">this</span>.compiler.hooks.watchRun.callAsync(<span class="built_in">this</span>.compiler, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">const</span> onCompiled = <span class="function">(<span class="params">err, compilation</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="built_in">this</span>.compiler.compile(onCompiled);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>onCompiled</code> 方法与 <code>compiler.run</code> 里的 <code>onCompiled</code> 大致一致，不同点是所有回调由 <code>finalCallback</code> 改为 <code>_done</code>，并且将 <code>stats</code> 统计信息相关处理也放到了 <code>_done</code> 里：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//... Watching.js</span></span><br><span class="line"><span class="function"><span class="title">_done</span>(<span class="params">err, compilation</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">this</span>.compiler.hooks.done.callAsync(stats, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.handler(<span class="literal">null</span>, stats); <span class="comment">// 同compilerCallback</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.closed) &#123;</span><br><span class="line">      <span class="built_in">this</span>.watch(</span><br><span class="line">        <span class="built_in">Array</span>.from(compilation.fileDependencies),</span><br><span class="line">        <span class="built_in">Array</span>.from(compilation.contextDependencies),</span><br><span class="line">        <span class="built_in">Array</span>.from(compilation.missingDependencies));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> cb <span class="keyword">of</span> <span class="built_in">this</span>.callbacks) cb();</span><br><span class="line">    <span class="built_in">this</span>.callbacks.length = <span class="number">0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在该方法里对 <code>stats</code> 设置后，<code>compiler.hooks</code>: <code>done</code> 的回调里执行 <code>this.handler</code>（实际与 <code>finalCallback</code> 功能一致） 即 <code>compilerCallback</code>，在 <code>cli</code> 里打印出构建相关的信息。到此，初始化构建完毕。</p><h3 id="添加监听"><a href="#添加监听" class="headerlink" title="添加监听"></a>添加监听</h3><p>接着执行 <code>this.watch</code> 并传入 <code>fileDependencies, contextDependencies, missingDependencies</code>（<code>compilation.seal</code> 里 <code>this.summarizeDependencies</code> 生成） 这些需要监听的文件和目录。</p><p><code>this.watch</code> 即执行 <code>this.compiler.watchFileSystem.watch</code> 即 <code>NodeWatchFileSystem</code> 的实例 <code>watch</code> 方法（ 文件 <code>webpack/lib/node/NodeWatchFileSystem.js</code>，<code>NodeEnvironmentPlugin</code> 里所设置），方法里先对参数进行了格式判断后，<strong>实例化了 Watchpack</strong>。<code>Watchpack</code> 继承了 <code>events</code> 模块的 <code>EventEmitter</code>，然后在 <code>this.watcher</code>（<code>Watchpack</code> 实例） 上注册了 <code>change，aggregated</code> 事件后，执行 <code>watchpack</code> 的实例方法 <code>watch</code>，该方法里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//watchpack.js</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="built_in">this</span>.fileWatchers = files.map(<span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>._fileWatcher(file, watcherManager.watchFile(file, <span class="built_in">this</span>.watcherOptions, startTime));</span><br><span class="line">&#125;, <span class="built_in">this</span>);</span><br><span class="line"><span class="built_in">this</span>.dirWatchers = directories.map(<span class="function"><span class="keyword">function</span> (<span class="params">dir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>._dirWatcher(dir, watcherManager.watchDirectory(dir, <span class="built_in">this</span>.watcherOptions, startTime));</span><br><span class="line">&#125;, <span class="built_in">this</span>);</span><br></pre></td></tr></table></figure><p>这里<strong>循环</strong>对每一个 <code>file</code> 进行执行 <code>this._fileWatcher</code>。</p><blockquote><p>一般情况的监听只会涉及 <code>this._fileWatchers</code>，目录类的 <code>this._dirWatchers</code> 会在 <code>require.context</code> 的情况下被监听。</p></blockquote><p>其中 <code>watcherManager.watchFile</code> 里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//watcherManager.js</span></span><br><span class="line"><span class="keyword">var</span> directory = path.dirname(p);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.getDirectoryWatcher(directory, options).watch(p, startTime);</span><br></pre></td></tr></table></figure><p>其中 <code>getDirectoryWatcher</code> 根据文件对应<strong>目录路径</strong> <code>directory</code>，实例化不同的 <code>DirectoryWatcher</code> 并执行 <code>watch</code> 方法。</p><p><code>DirectoryWatcher</code> 与 <code>Watchpack</code> 一样也继承了 <code>events</code> 模块的 <code>EventEmitter</code>，在实例化的过程中执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DirectoryWatcher.js</span></span><br><span class="line"><span class="built_in">this</span>.watcher = chokidar.watch(directoryPath, &#123;</span><br><span class="line">  ignoreInitial: <span class="literal">true</span>,</span><br><span class="line">  persistent: <span class="literal">true</span>,</span><br><span class="line">  followSymlinks: <span class="literal">false</span>,</span><br><span class="line">  depth: <span class="number">0</span>,</span><br><span class="line">  atomic: <span class="literal">false</span>,</span><br><span class="line">  alwaysStat: <span class="literal">true</span>,</span><br><span class="line">  ignorePermissionErrors: <span class="literal">true</span>,</span><br><span class="line">  ignored: options.ignored,</span><br><span class="line">  usePolling: options.poll ? <span class="literal">true</span> : <span class="literal">undefined</span>,</span><br><span class="line">  interval: interval, <span class="comment">// 即 options.poll 文件系统轮询的时间间隔，越大性能越好</span></span><br><span class="line">  binaryInterval: interval,</span><br><span class="line">  disableGlobbing: <span class="literal">true</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>webpack</code> 采用 <code>npm</code> 包 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BhdWxtaWxsci9jaG9raWRhcg==">chokidar<i class="fa fa-external-link-alt"></i></span> 来进行<strong>文件夹的监听</strong>，然后根据不同操作（增加，删除，修改等）绑定事件后，执行 <code>this.doInitialScan</code> 读取该 <code>path</code>（文件对应的文件夹路径 <code>directory</code>）下的所有文件及文件夹，如果是文件则执行 <code>this.setFileTime</code> 根据是否是首次 <code>watch</code> 来收集该文件的修改时间；如果是文件夹则执行 <code>this.setDirectory</code> 记录所有子路径。</p><p>因为 <code>fs.readdir</code> 为异步，先回到 <code>this.getDirectoryWatcher(directory, options).watch(p, startTime)</code> 中执行 <code>watch</code>，方法里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...DirectoryWatcher.js</span></span><br><span class="line"><span class="keyword">var</span> watcher = <span class="keyword">new</span> Watcher(<span class="built_in">this</span>, filePath, startTime);</span><br></pre></td></tr></table></figure><p><strong>类 <code>Watcher</code> 依旧继承了 <code>events</code> 模块的 <code>EventEmitter</code>。</strong> 这里实例化了一个 <code>Watcher</code>，然后订阅了他的 <code>close</code> 方法后，将该 <code>watcher</code> <code>push</code> 到 <code>this.watchers</code>，然后返回一个 <code>watcher</code> 实例。</p><p>然后回到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//watchpack.js</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>._fileWatcher(file, watcherManager.watchFile(file, <span class="built_in">this</span>.watcherOptions, startTime)); <span class="comment">// watcherManager.watchFile 返回一个 watcher 实例</span></span><br></pre></td></tr></table></figure><p>执行 <code>this._fileWatcher</code> 给对应的 <code>watcher</code> 订阅了 <code>change</code> 和 <code>remove</code> 事件。最终 <code>this.fileWatchers</code> 得到一个 <code>watcher</code> 数组。</p><p>然后回到 <code>_done</code> 里，这一轮代码执行结束。</p><p>然后转而执行之前在 <code>doInitialScan</code> 里的 <code>fs.readdir</code> 的异步回调，收集文件修改时间，到此 <code>webpack watch</code> 的初次构建结束，文件正在被监听。</p><h2 id="修改文件触发监听"><a href="#修改文件触发监听" class="headerlink" title="修改文件触发监听"></a>修改文件触发监听</h2><p>修改文件后，触发 <code>chokidar</code> 的 <code>change</code> 事件，即 <code>this.onChange</code>，在方法里对 <code>path</code> 进行验证后，执行 <code>this.setFileTime</code>。在方法里更新 <code>this.files[filePath]</code> 里对应的最新修改时间后，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DirectoryWatcher.js</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.watchers[withoutCase(filePath)]) &#123;</span><br><span class="line">  <span class="built_in">this</span>.watchers[withoutCase(filePath)].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">w</span>) </span>&#123;</span><br><span class="line">    w.emit(<span class="string">&#x27;change&#x27;</span>, mtime, type);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断该文件是否在 <code>this.watchers</code> 即在被监听之列后，对该文件的每一个 <code>watcher</code> 触发其 <code>change</code>，即执行在 <code>_fileWatcher</code> 里注册的事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//watchpack.js</span></span><br><span class="line"><span class="built_in">this</span>._onChange(file, mtime, file, type);</span><br></pre></td></tr></table></figure><p>方法里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//watchpack.js</span></span><br><span class="line"><span class="built_in">this</span>.emit(<span class="string">&#x27;change&#x27;</span>, file, mtime); <span class="comment">// 触发 `this.compiler.watchFileSystem.watch` 里的回调：this.compiler.hooks.invalid.call(fileName, changeTime)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.aggregateTimeout) <span class="built_in">clearTimeout</span>(<span class="built_in">this</span>.aggregateTimeout);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.aggregatedChanges.indexOf(item) &lt; <span class="number">0</span>) <span class="built_in">this</span>.aggregatedChanges.push(item);</span><br><span class="line"><span class="built_in">this</span>.aggregateTimeout = <span class="built_in">setTimeout</span>(<span class="built_in">this</span>._onTimeout, <span class="built_in">this</span>.options.aggregateTimeout);</span><br></pre></td></tr></table></figure><p><a href="https://blog.flqin.com/325.html">函数防抖(debounce)</a>，通过设置配置项 <code>options.aggregateTimeout</code> 可以设置间隔时间，间隔时间越长，性能越好。</p><p>执行 <code>this._onTimeout</code> 里触发 <code>aggregated</code> 事件 (<code>NodeWatchFileSystem</code> 里注册)，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NodeWatchFileSystem.js</span></span><br><span class="line"><span class="keyword">const</span> times = objectToMap(<span class="built_in">this</span>.watcher.getTimes());</span><br></pre></td></tr></table></figure><p>得到 <code>times</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...map结构</span></span><br><span class="line">  <span class="attr">&quot;0&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;/Users/github/webpack-demo/src/a.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;1578382937093&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;1&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;/Users/github/webpack-demo/src/a.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;1578382937093&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;2&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;/Users/github/webpack-demo/src/a.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;1578382937093&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;3&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;/Users/github/webpack-demo/src/a.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;1578382937093&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;4&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;/Users/github/webpack-demo/src/a.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;1578382937093&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;5&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;key&quot;</span>: <span class="string">&quot;/Users/github/webpack-demo/src/a.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;1578382937093&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到每个文件的最新修改时间后，执行回调 <code>callback</code>，即 <code>Watching.js</code> 的 <code>this.compiler.watchFileSystem.watch</code> 方法的倒数第二个参数方法，在方法里将 <code>fileTimestamps</code> 即 <code>times</code> 赋给 <code>this.compiler.fileTimestamps</code> 后，执行 <code>this._invalidate</code> 即执行 <code>this._go</code> 开启新一轮的构建。</p><h2 id="watch-优化"><a href="#watch-优化" class="headerlink" title="watch 优化"></a>watch 优化</h2><p>在构建过程中，依旧从入口开始构建，但在 <code>moduleFactory.create</code> 的回调里（包括依赖构建 <code>addModuleDependencies</code> 里的 <code>factory.create</code>），执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addModuleResult = <span class="built_in">this</span>.addModule(<span class="built_in">module</span>);</span><br></pre></td></tr></table></figure><p>该方法除了判断 <code>module</code> 已加载之外，还判断了如果在 <code>compilation</code> 的 <code>this.cache</code> 存在该模块的话，则执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> rebuild = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.fileTimestamps &amp;&amp; <span class="built_in">this</span>.contextTimestamps) &#123;</span><br><span class="line">  rebuild = cacheModule.needRebuild(<span class="built_in">this</span>.fileTimestamps, <span class="built_in">this</span>.contextTimestamps);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在方法 <code>needRebuild</code> 里判断模块修改时间 <code>fileTimestamps.get(file)</code> 与 模块构建时间 <code>this.buildTimestamp</code>（在 <code>module.build</code> 时取得）的先后来决定是否需要重新构建模块，若修改时间大于构建时间，则需要 <code>rebuild</code>，否则跳过 <code>build</code> 这步直接执行 <code>afterBuild</code> 即递归解析构建依赖。这样在监听时只 <code>rebuild</code> 修改过的 <code>module</code> 可大大提升编译过程。</p>]]></content>
      
      
      <categories>
          
          <category> FE Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（十二）：打包后文件解析</title>
      <link href="383.html"/>
      <url>383.html</url>
      
        <content type="html"><![CDATA[<p>以 <code>前言及总流程概览</code> 里的 <code>demo</code> 为例， 前十一张章分析了打包过程，现在来分析它打包后的文件。</p><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&#x27;Src/b&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./c.js&#x27;</span>).then(<span class="function">(<span class="params">m</span>) =&gt;</span> m.sub(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">add(<span class="number">3</span>, <span class="number">2</span> + a);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; mul &#125; <span class="keyword">from</span> <span class="string">&#x27;@fe_korey/test-loader?number=20!Src/e&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + mul(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addddd</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/c.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; mul &#125; <span class="keyword">from</span> <span class="string">&#x27;Src/d&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./b.js&#x27;</span>).then(<span class="function">(<span class="params">m</span>) =&gt;</span> m.add(<span class="number">200</span>, <span class="number">100</span>)); <span class="comment">//require.ensure() 是 webpack 特有的，已经被 import() 取代。</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b + mul(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/d.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> d = <span class="number">10000</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b + d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    bundle: <span class="string">&#x27;./src/a.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="string">&#x27;/dist&#x27;</span>,</span><br><span class="line">    filename: <span class="string">&#x27;[name].[chunkhash:4].js&#x27;</span>,</span><br><span class="line">    chunkFilename: <span class="string">&#x27;[name].[chunkhash:8].js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      Src: path.resolve(__dirname, <span class="string">&#x27;src/&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//babel.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [<span class="string">&#x27;@babel/env&#x27;</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>@fe_korey/test-loader</code> 是一个测试 <code>loader</code>，该 <code>loader</code> 作用为代码里的字符串 <code>10000</code> 替换为传入的 <code>number</code>。</p><h2 id="打包结果文件"><a href="#打包结果文件" class="headerlink" title="打包结果文件"></a>打包结果文件</h2><p>根据项目配置及同步异步的关系，打包后一共生成两个文件：</p><ul><li><code>bundle.xxxx.js</code></li></ul><p>总代码：见 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3poYW9reS93ZWJwYWNrLWRlbW8vdHJlZS9tYXN0ZXIvZGlzdA==">github<i class="fa fa-external-link-alt"></i></span></p><p>入口文件，该文件名根据配置：<code>entry</code> 及 <code>output.filename</code> 生成，里面包含 <code>webpack runtime</code> 代码和同步模块代码。</p><p>如若配置了 <code>html-webpack-plugin</code>，那么在生成的 <code>html</code> 里将只会引入此 <code>js</code> 文件。</p><ul><li><code>0.xxxxxxxx.js</code></li></ul><p>总代码：见 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3poYW9reS93ZWJwYWNrLWRlbW8vdHJlZS9tYXN0ZXIvZGlzdA==">github<i class="fa fa-external-link-alt"></i></span></p><p>非入口文件，本例为异步 <code>chunk</code> 文件，该文件名根据配置： <code>output.chunkFilename</code>生成，里面包含异步模块代码。</p><h2 id="代码执行流程"><a href="#代码执行流程" class="headerlink" title="代码执行流程"></a>代码执行流程</h2><p>根据代码执行顺序来分析，<code>html</code> 文件只需引入了 <code>bundle.xxxx.js</code> 文件，则从该文件开始执行，如果有其他 <code>import</code> 后，会先跳到对应的 <code>module</code> 进行处理，即<strong>先序深度优先</strong>遍历算法递归该依赖树。</p><h3 id="bundle-主体结构"><a href="#bundle-主体结构" class="headerlink" title="bundle 主体结构"></a>bundle 主体结构</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//runtime代码</span></span><br><span class="line">&#125;)(&#123;</span><br><span class="line">  <span class="string">&#x27;./node_modules/@fe_korey/test-loader/loader.js?number=20!./src/d.js&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...模块代码d</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;./src/a.js&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...模块代码a</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;./src/b.js&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...模块代码b</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>主体结构为一个自执行函数，函数体为 <code>runtime</code> 函数，参数为 <code>modules</code> 对象，各模块以 <code>key-value</code> 的形式一起存在该 <code>modules</code> 对象里。当前 <code>key</code> 为模块的路径，<code>value</code> 为包裹模块代码的一个函数。</p><h3 id="runtime-函数"><a href="#runtime-函数" class="headerlink" title="runtime 函数"></a>runtime 函数</h3><p><code>runtime</code> 指的是 <code>webpack</code> 的运行环境(具体作用就是模块解析, 加载) 和 模块信息清单（表现在 <code>jsonpScriptSrc</code> 方法里）。</p><p>配置项 <code>optimization.runtimeChunk</code> 可以设置 <code>webpack</code> 将 <code>runtime</code> 这部分代码单独打包。</p><h4 id="runtime-函数主体结构"><a href="#runtime-函数主体结构" class="headerlink" title="runtime 函数主体结构"></a>runtime 函数主体结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">modules</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">webpackJsonpCallback</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置 script src  __webpack_require__.p 即为 output.publicPath 配置</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">jsonpScriptSrc</span>(<span class="params">chunkId</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> __webpack_require__.p + <span class="string">&quot;&quot;</span> + (&#123;&#125;[chunkId]||chunkId) + <span class="string">&quot;.&quot;</span> + &#123;<span class="string">&quot;0&quot;</span>:<span class="string">&quot;d680ffbe&quot;</span>&#125;[chunkId] + <span class="string">&quot;.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> installedModules = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> installedChunks = &#123;<span class="string">&quot;bundle&quot;</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一堆挂载在__webpack_require__上的属性</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// jsonp 初始化</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> __webpack_require__(__webpack_require__.s = <span class="string">&quot;./src/a.js&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="开始执行"><a href="#开始执行" class="headerlink" title="开始执行"></a>开始执行</h3><p>代码开始执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> installedModules = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>初始化 <code>installedModules</code>，保存所有创建过的 <code>module</code>，用于缓存判断。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// undefined：chunk未加载, null: chunk通过prefetch/preload提前获取过</span></span><br><span class="line"><span class="comment">// Promise：chunk正在加载, 0：chunk加载完毕</span></span><br><span class="line"><span class="comment">// 数组: 结构为 [resolve Function, reject Function, Promise] 的数组, 代表 chunk 在处于加载中</span></span><br><span class="line"><span class="keyword">var</span> installedChunks = &#123;</span><br><span class="line">  bundle: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>installedChunks</code> 以 <code>key-value</code> 的形式，用于收集保存所有的 <code>chunk</code>，这里 <code>bundle</code> 就是指的当前 <code>chunk</code>，自然是已经加载好了的。</p><h3 id="webpack-require-属性"><a href="#webpack-require-属性" class="headerlink" title="__webpack_require__ 属性"></a><code>__webpack_require__</code> 属性</h3><p>然后定义了一堆 <code>__webpack_require__</code> 的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步处理</span></span><br><span class="line">__webpack_require__.e = <span class="function"><span class="keyword">function</span> <span class="title">requireEnsure</span>(<span class="params">chunkId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//后文单独分析</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即为传入的modules：各模块组成的对象</span></span><br><span class="line">__webpack_require__.m = modules;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即为installedModules：已经缓存的对象</span></span><br><span class="line">__webpack_require__.c = installedModules;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在exports对象上添加属性，即 增加导出</span></span><br><span class="line">__webpack_require__.d = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, name, getter</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!__webpack_require__.o(<span class="built_in">exports</span>, name)) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, name, &#123; <span class="attr">enumerable</span>: <span class="literal">true</span>, <span class="attr">get</span>: getter &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在exports对象上添加 __esModule 属性，用于标识 es6 模块</span></span><br><span class="line">__webpack_require__.r = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Symbol</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; <span class="built_in">Symbol</span>.toStringTag) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="built_in">Symbol</span>.toStringTag, &#123; <span class="attr">value</span>: <span class="string">&#x27;Module&#x27;</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&#x27;__esModule&#x27;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个伪命名空间对象</span></span><br><span class="line">__webpack_require__.t = <span class="function"><span class="keyword">function</span> (<span class="params">value, mode</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//没用上，解释暂时略过</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到 getDefaultExport，即通过 __esModule 属性判断是否是 es6 来确定对应的默认导出方法</span></span><br><span class="line">__webpack_require__.n = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> getter =</span><br><span class="line">    <span class="built_in">module</span> &amp;&amp; <span class="built_in">module</span>.__esModule</span><br><span class="line">      ? <span class="function"><span class="keyword">function</span> <span class="title">getDefault</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">module</span>[<span class="string">&#x27;default&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      : <span class="function"><span class="keyword">function</span> <span class="title">getModuleExports</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">module</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">  __webpack_require__.d(getter, <span class="string">&#x27;a&#x27;</span>, getter);</span><br><span class="line">  <span class="keyword">return</span> getter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 hasOwnProperty，即判断对象上是否有某一属性</span></span><br><span class="line">__webpack_require__.o = <span class="function"><span class="keyword">function</span> (<span class="params">object, property</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.hasOwnProperty.call(object, property);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 即为 publicPath，在output.publicPath配置而来</span></span><br><span class="line">__webpack_require__.p = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误处理</span></span><br><span class="line">__webpack_require__.oe = <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(err);</span><br><span class="line">  <span class="keyword">throw</span> err;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个属性的作用已经写在注释上面。</p><h3 id="jsonp-初始化"><a href="#jsonp-初始化" class="headerlink" title="jsonp 初始化"></a><code>jsonp</code> 初始化</h3><p>然后执行 <code>jsonp</code> 初始化:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonpArray = (<span class="built_in">window</span>[<span class="string">&#x27;webpackJsonp&#x27;</span>] = <span class="built_in">window</span>[<span class="string">&#x27;webpackJsonp&#x27;</span>] || []); <span class="comment">//初始化 window[&#x27;webpackJsonp&#x27;]对象</span></span><br><span class="line"><span class="keyword">var</span> oldJsonpFunction = jsonpArray.push.bind(jsonpArray); <span class="comment">// 暂存 push 方法</span></span><br><span class="line">jsonpArray.push = webpackJsonpCallback; <span class="comment">//重写 jsonpArray 的 push 方法为 webpackJsonpCallback</span></span><br><span class="line">jsonpArray = jsonpArray.slice(); <span class="comment">//拷贝 jsonpArray（不带 push 方法）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]); <span class="comment">//若入口文件加载前，chunks文件先加载了，遍历 jsonpArray 用 webpackJsonpCallback 执行</span></span><br><span class="line"><span class="keyword">var</span> parentJsonpFunction = oldJsonpFunction; <span class="comment">//旧的 push 方法存入 parentJsonpFunction</span></span><br></pre></td></tr></table></figure><p><code>jsonp</code> 初始化的主要作用就是给 <code>window[&#39;webpackJsonp&#39;]</code> 重写了 <code>push</code> 方法为 <code>webpackJsonpCallback</code> 。接着执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> __webpack_require__((__webpack_require__.s = <span class="string">&#x27;./src/a.js&#x27;</span>));</span><br></pre></td></tr></table></figure><p>由入口文件 <code>a</code> 开始，传入 <code>moduleID : &quot;./src/a.js&quot;</code>，执行方法 <code>__webpack_require__</code>。</p><h3 id="webpack-require"><a href="#webpack-require" class="headerlink" title="__webpack_require__"></a><code>__webpack_require__</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">__webpack_require__</span>(<span class="params">moduleId</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断该module是否已经被缓存到installedModules，如果有，则直接返回它的导出exports</span></span><br><span class="line">  <span class="keyword">if</span> (installedModules[moduleId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> installedModules[moduleId].exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义module并缓存</span></span><br><span class="line">  <span class="keyword">var</span> <span class="built_in">module</span> = (installedModules[moduleId] = &#123;</span><br><span class="line">    i: moduleId,</span><br><span class="line">    l: <span class="literal">false</span>,</span><br><span class="line">    <span class="built_in">exports</span>: &#123;&#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 执行module代码</span></span><br><span class="line">  modules[moduleId].call(<span class="built_in">module</span>.exports, <span class="built_in">module</span>, <span class="built_in">module</span>.exports, __webpack_require__);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 标志module已经读取完成</span></span><br><span class="line">  <span class="built_in">module</span>.l = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">module</span>.exports;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__webpack_require__</code> 方法的主要作用就是创建缓存 <code>module</code> 后，执行该 <code>module</code> 的代码。其中 <code>modules</code> 即为上文所解释的各模块组成的对象。</p><h3 id="执行各同步模块代码"><a href="#执行各同步模块代码" class="headerlink" title="执行各同步模块代码"></a>执行各同步模块代码</h3><p><code>modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</code> 执行模块 <code>a</code> 的代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模块 a</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line">__webpack_require__.r(__webpack_exports__);</span><br><span class="line"><span class="keyword">var</span> Src_b__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="string">&#x27;./src/b.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line">__webpack_require__</span><br><span class="line">  .e(<span class="number">0</span>)</span><br><span class="line">  .then(__webpack_require__.bind(<span class="literal">null</span>, <span class="string">&#x27;./src/c.js&#x27;</span>))</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.sub(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Object</span>(Src_b__WEBPACK_IMPORTED_MODULE_0__[<span class="string">&#x27;add&#x27;</span>])(<span class="number">3</span>, <span class="number">2</span> + a);</span><br></pre></td></tr></table></figure><p>代码里 <code>__webpack_require__(&#39;./src/b.js&#39;)</code> 会去执行模块 <code>b</code> 的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模块 b</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line">__webpack_require__.r(__webpack_exports__);</span><br><span class="line">__webpack_require__.d(__webpack_exports__, <span class="string">&#x27;add&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> add;</span><br><span class="line">&#125;);</span><br><span class="line">__webpack_require__.d(__webpack_exports__, <span class="string">&#x27;addddd&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> addddd;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> _fe_korey_test_loader_number_20_Src_d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="string">&#x27;./node_modules/@fe_korey/test-loader/loader.js?number=20!./src/d.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + <span class="built_in">Object</span>(_fe_korey_test_loader_number_20_Src_d__WEBPACK_IMPORTED_MODULE_0__[<span class="string">&#x27;mul&#x27;</span>])(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addddd</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里在导出了两个方法后，去执行模块 <code>d</code> 的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模块 d</span></span><br><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line">__webpack_require__.r(__webpack_exports__);</span><br><span class="line">__webpack_require__.d(__webpack_exports__, <span class="string">&#x27;mul&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mul;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b + d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模块 <code>d</code> 代码导出了 <code>mul</code>。</p><h3 id="import-的处理"><a href="#import-的处理" class="headerlink" title="import() 的处理"></a>import() 的处理</h3><p>各自模块执行完后，回到模块 <code>a</code> 里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__webpack_require__</span><br><span class="line">  .e(<span class="number">0</span>)</span><br><span class="line">  .then(__webpack_require__.bind(<span class="literal">null</span>, <span class="string">&#x27;./src/c.js&#x27;</span>))</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.sub(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>该打包后的代码为<strong>异步动态加载</strong>，源代码为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./c.js&#x27;</span>).then(<span class="function">(<span class="params">m</span>) =&gt;</span> m.sub(<span class="number">2</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><h4 id="webpack-require-e"><a href="#webpack-require-e" class="headerlink" title="__webpack_require__.e"></a><code>__webpack_require__.e</code></h4><p><code>__webpack_require__.e</code> 实现异步加载模块，方法为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise队列，等待多个异步 chunk都加载完成才执行回调</span></span><br><span class="line"><span class="keyword">var</span> promises = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先判断是否加载过该 chunk</span></span><br><span class="line"><span class="keyword">var</span> installedChunkData = installedChunks[chunkId];</span><br><span class="line"><span class="keyword">if</span> (installedChunkData !== <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 0 means &quot;already installed&quot;.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// a Promise means &quot;currently loading&quot;. 目标 chunk 正在加载，则将 promise push到 promises 数组</span></span><br><span class="line">  <span class="keyword">if</span> (installedChunkData) &#123;</span><br><span class="line">    promises.push(installedChunkData[<span class="number">2</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 新建一个Promise去异步加载目标chunk</span></span><br><span class="line">    <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      installedChunkData = installedChunks[chunkId] = [resolve, reject]; <span class="comment">//这里设置 installedChunks[chunkId]</span></span><br><span class="line">    &#125;);</span><br><span class="line">    promises.push((installedChunkData[<span class="number">2</span>] = promise)); <span class="comment">// installedChunks[chunkId]  = [resolve, reject, promise]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> onScriptComplete;</span><br><span class="line"></span><br><span class="line">    script.charset = <span class="string">&#x27;utf-8&#x27;</span>;</span><br><span class="line">    script.timeout = <span class="number">120</span>;</span><br><span class="line">    <span class="keyword">if</span> (__webpack_require__.nc) &#123;</span><br><span class="line">      script.setAttribute(<span class="string">&#x27;nonce&#x27;</span>, __webpack_require__.nc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置src</span></span><br><span class="line">    script.src = jsonpScriptSrc(chunkId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    <span class="comment">// 设置加载完成或错误的回调</span></span><br><span class="line">    onScriptComplete = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// avoid mem leaks in IE.</span></span><br><span class="line">      script.onerror = script.onload = <span class="literal">null</span>;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">      <span class="keyword">var</span> chunk = installedChunks[chunkId];</span><br><span class="line">      <span class="keyword">if</span> (chunk !== <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chunk) &#123;</span><br><span class="line">          <span class="keyword">var</span> errorType = event &amp;&amp; (event.type === <span class="string">&#x27;load&#x27;</span> ? <span class="string">&#x27;missing&#x27;</span> : event.type);</span><br><span class="line">          <span class="keyword">var</span> realSrc = event &amp;&amp; event.target &amp;&amp; event.target.src;</span><br><span class="line">          error.message = <span class="string">&#x27;Loading chunk &#x27;</span> + chunkId + <span class="string">&#x27; failed.\n(&#x27;</span> + errorType + <span class="string">&#x27;: &#x27;</span> + realSrc + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">          error.name = <span class="string">&#x27;ChunkLoadError&#x27;</span>;</span><br><span class="line">          error.type = errorType;</span><br><span class="line">          error.request = realSrc;</span><br><span class="line">          chunk[<span class="number">1</span>](error);</span><br><span class="line">        &#125;</span><br><span class="line">        installedChunks[chunkId] = <span class="literal">undefined</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 设置超时处理</span></span><br><span class="line">    <span class="keyword">var</span> timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      onScriptComplete(&#123; <span class="attr">type</span>: <span class="string">&#x27;timeout&#x27;</span>, <span class="attr">target</span>: script &#125;);</span><br><span class="line">    &#125;, <span class="number">120000</span>);</span><br><span class="line">    <span class="comment">//script标签的onload事件都是在外部js文件被加载完成并执行完成后（异步不算）才被触发</span></span><br><span class="line">    script.onerror = script.onload = onScriptComplete;</span><br><span class="line">    <span class="comment">// script标签加入文档</span></span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises);</span><br></pre></td></tr></table></figure><p>参数 <code>0</code> 为 <code>chunkId</code>，在方法 <code>__webpack_require__.e</code> 里，主要功能就是模拟 <code>jsonp</code> 去异步加载目标 <code>chunk</code> 文件 <code>0</code>，返回一个 <code>promise</code> 对象。</p><p>然后加载异步文件 <code>0.e3296d88.js</code> 并执行。</p><h3 id="加载非入口文件0-e3296d88-js"><a href="#加载非入口文件0-e3296d88-js" class="headerlink" title="加载非入口文件0.e3296d88.js"></a>加载非入口文件<code>0.e3296d88.js</code></h3><h4 id="非入口文件主体结构"><a href="#非入口文件主体结构" class="headerlink" title="非入口文件主体结构"></a>非入口文件主体结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">window</span>[<span class="string">&#x27;webpackJsonp&#x27;</span>] = <span class="built_in">window</span>[<span class="string">&#x27;webpackJsonp&#x27;</span>] || []).push([</span><br><span class="line">  [<span class="number">0</span>],</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&#x27;./src/c.js&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line">      <span class="comment">//模块 c</span></span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;./src/d.js&#x27;</span>: <span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line">      <span class="comment">//模块 d</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>在模块加载后，就会立即执行的 <code>window[&#39;webpackJsonp&#39;].push()</code> 。由 <code>jsonp</code> 初始化可知， 即执行 <code>bundle</code> 文件里的 <code>webpackJsonpCallback</code> 方法。</p><h4 id="webpackJsonpCallback"><a href="#webpackJsonpCallback" class="headerlink" title="webpackJsonpCallback"></a>webpackJsonpCallback</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">webpackJsonpCallback</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> chunkIds = data[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> moreModules = data[<span class="number">1</span>]; <span class="comment">//异步 chunk 的各模块组成的对象</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> moduleId,</span><br><span class="line">    chunkId,</span><br><span class="line">    i = <span class="number">0</span>,</span><br><span class="line">    resolves = [];</span><br><span class="line">  <span class="comment">// 这里收集 resolve 并将所有 chunkIds 标记为已加载</span></span><br><span class="line">  <span class="keyword">for</span> (; i &lt; chunkIds.length; i++) &#123;</span><br><span class="line">    chunkId = chunkIds[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(installedChunks, chunkId) &amp;&amp; installedChunks[chunkId]) &#123;</span><br><span class="line">      resolves.push(installedChunks[chunkId][<span class="number">0</span>]); <span class="comment">//将 resolve push 到 resolves 数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">    installedChunks[chunkId] = <span class="number">0</span>; <span class="comment">//标记为已加载</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历各模块组成的对象，将每个模块都加到 modules</span></span><br><span class="line">  <span class="keyword">for</span> (moduleId <span class="keyword">in</span> moreModules) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class="line">      modules[moduleId] = moreModules[moduleId];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行保存的旧 push 方法，可能是 array.push (即 push 到 window.webpackJsonp)，也可能是前一个并行执行了 runtime 的 bundle 的 webpackJsonpCallback，即递归执行 webpackJsonpCallback，如多入口同时 import 同一个 module 的情况。</span></span><br><span class="line">  <span class="keyword">if</span> (parentJsonpFunction) parentJsonpFunction(data);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//循环触发 resolve 回调</span></span><br><span class="line">  <span class="keyword">while</span> (resolves.length) &#123;</span><br><span class="line">    resolves.shift()();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>webpackJsonpCallback</code> 方法主要将异步的 <code>chunk</code> 里的所有模块都加到 <code>modules</code> 后，改变 <code>installedChunks[chunkId]</code> 的状态为 <code>0</code>（即已加载），然后执行之前创建的 <code>promise</code> 的 <code>resolve()</code>。</p><h4 id="执行-resolve-的回调-then-方法"><a href="#执行-resolve-的回调-then-方法" class="headerlink" title="执行 resolve 的回调 then 方法"></a>执行 resolve 的回调 then 方法</h4><p>回到模块 <code>a</code> 根据 <code>promise</code> 的定义，执行 <code>promises</code> 队列里所有的 <code>resolve</code> 后，然后去执行对应的 <code>then</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">then(__webpack_require__.bind(<span class="literal">null</span>, <span class="string">&#x27;./src/c.js&#x27;</span>));</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>即执行模块 <code>c</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line">__webpack_require__.r(__webpack_exports__);</span><br><span class="line">__webpack_require__.d(__webpack_exports__, <span class="string">&#x27;sub&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sub;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> Src_d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="string">&#x27;./src/d.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(__webpack_require__.bind(<span class="literal">null</span>, <span class="string">&#x27;./src/b.js&#x27;</span>))</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.add(<span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b + <span class="built_in">Object</span>(Src_d__WEBPACK_IMPORTED_MODULE_0__[<span class="string">&#x27;mul&#x27;</span>])(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;c&#x27;</span>);</span><br></pre></td></tr></table></figure><p>模块 <code>c</code> 里引入了模块 <code>d</code>，这里的模块 <code>d</code> 与前文的模块 <code>d</code> 虽然是一样的，但由于用的 <code>loader</code> 不一样，所以会认为是两个不同的模块，故会再次加载，互不影响。这里模块 <code>d</code> 不在累述。</p><p>然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(__webpack_require__.bind(<span class="literal">null</span>, <span class="string">&#x27;./src/b.js&#x27;</span>))</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m.add(<span class="number">200</span>, <span class="number">100</span>);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><code>Promise.resolve</code> 方法允许调用时不带参数，直接返回一个<code>resolved</code> 状态的 <code>Promise</code> 对象。即执行 then 方法，即 <code>__webpack_require__.bind(null, &#39;./src/b.js&#39;)</code>。然后在 <code>__webpack_require__</code> 方法里判断缓存有模块 <code>b</code>，则直接返回模块 <code>b</code> 对应的 <code>exports</code>。到此异步加载完成。</p><p>根据微任务队列的先后顺序，先执行模块 <code>a</code> 的第二个 <code>then</code> 回调，然后执行模块 <code>c</code> 的第二个 <code>then</code> 回调，都执行完成后，执行加载完成回调 <code>onScriptComplete</code>。到此代码运行完成。</p><h2 id="异步加载小结"><a href="#异步加载小结" class="headerlink" title="异步加载小结"></a>异步加载小结</h2><p>再次梳理下异步加载的关键思路：</p><ol><li>通过 <code>__webpack_require__</code> 加载运行入口 <code>module</code></li><li>模块代码里遇到 <code>import()</code> 即执行 <code>__webpack_require__.e</code> 加载异步 <code>chunk</code></li><li><code>__webpack_require__.e</code> 使用模拟 <code>jsonp</code> 的方式及创建 <code>script</code> 标签来加载异步 <code>chunk</code>，并为每个 <code>chunk</code> 创建一个 <code>promise</code></li><li>等到异步 <code>chunk</code> 被加载后，会执行 <code>window[&#39;webpackJsonp&#39;].push</code>，即 <code>webpackJsonpCallback</code> 方法</li><li><code>webpackJsonpCallback</code> 里将异步 <code>chunk</code> 里的 <code>module</code> 加入到 <code>modules</code>， 并触发前面创建 <code>promise</code> 的 <code>resolve</code> 回调，然后执行其 <code>then</code> 方法即 <code>__webpack_require__</code> 去加载新的 <code>module</code>。</li></ol><h2 id="扩展-使用-splitChunks-切割后的文件解析"><a href="#扩展-使用-splitChunks-切割后的文件解析" class="headerlink" title="扩展 使用 splitChunks 切割后的文件解析"></a>扩展 使用 splitChunks 切割后的文件解析</h2><p><code>demo</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; mul &#125; <span class="keyword">from</span> <span class="string">&#x27;./d&#x27;</span>;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; mul &#125; <span class="keyword">from</span> <span class="string">&#x27;./d&#x27;</span>;</span><br><span class="line"><span class="comment">// d.js为普通同步文件</span></span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;entry&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;bundle1&quot;</span>: <span class="string">&quot;./src/e.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;bundle2&quot;</span>: <span class="string">&quot;./src/f.js&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span>: [new HtmlWebpackPlugin()],</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="attr">&quot;optimization&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;splitChunks&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;chunks&quot;</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;minSize&quot;</span>: <span class="number">0</span>, <span class="comment">//当模块小于这个值时，就不拆</span></span><br><span class="line">      <span class="attr">&quot;maxSize&quot;</span>: <span class="number">0</span>, <span class="comment">//当模块大于这个值时，尝试拆分</span></span><br><span class="line">      <span class="attr">&quot;minChunks&quot;</span>: <span class="number">1</span>, <span class="comment">//重复一次就打包</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="literal">true</span>, <span class="comment">//是否以cacheGroups中的filename作为文件名</span></span><br><span class="line">      <span class="attr">&quot;automaticNameDelimiter&quot;</span>: <span class="string">&quot;~&quot;</span>, <span class="comment">//打包的chunk名字连接符</span></span><br><span class="line">      <span class="attr">&quot;cacheGroups&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;default&quot;</span>: &#123;</span><br><span class="line">          <span class="attr">&quot;chunks&quot;</span>: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;minChunks&quot;</span>: <span class="number">2</span>,</span><br><span class="line">          <span class="attr">&quot;priority&quot;</span>: <span class="number">-10</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引入插件 <code>HtmlWebpackPlugin</code> 辅助分析。</p><p>打包后代码见 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3poYW9reS93ZWJwYWNrLWRlbW8vdHJlZS9tYXN0ZXIvZGlzdA==">github<i class="fa fa-external-link-alt"></i></span>，以下只做关键点记录:</p><ul><li><code>html</code> 会引入每个入口 <code>bundle</code> 生成的 <code>js</code> 和公共部分的 <code>js</code>：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;default~bundle1~bundle2.183bf5f4.js&quot;</span>&gt;&lt;<span class="regexp">/script&gt;&lt;script type=&quot;text/</span>javascript<span class="string">&quot; src=&quot;</span>bundle1.10ad.js<span class="string">&quot;&gt;&lt;/script&gt;&lt;script type=&quot;</span>text/javascript<span class="string">&quot; src=&quot;</span>bundle2.c333.js<span class="string">&quot;&gt;&lt;/script&gt;&lt;/body&gt;</span></span><br></pre></td></tr></table></figure><ul><li>在 <code>jsonp</code> 初始化阶段，执行：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);</span><br></pre></td></tr></table></figure><p>和在 <code>webpackJsonpCallback</code> 方法里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (parentJsonpFunction) parentJsonpFunction(data);</span><br></pre></td></tr></table></figure><p>可以保证无论页面先加载入口文件还是非入口文件，都可以将依赖 <code>module</code> 同步到各自的 <code>chunk</code> 里。</p><ul><li>两个入口文件 <code>bundle1.xxxx.js bundle2.xxxx.js</code> 的 <code>runtime</code> 代码里会多出一个新的变量 <code>deferredModules</code>：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deferredModules = [];</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">deferredModules.push([<span class="string">&#x27;./src/e.js&#x27;</span>, <span class="string">&#x27;default~bundle1~bundle2&#x27;</span>]);</span><br><span class="line"><span class="keyword">return</span> checkDeferredModules();</span><br></pre></td></tr></table></figure><p>该变量为一个数组，第一个变量是需要加载的 <code>module</code>，后面的变量就是要加载本 <code>module</code> 所需的其他依赖 <code>module</code>。然后在 <code>runtime</code> 的末尾执行：<code>return checkDeferredModules();</code></p><ul><li><code>checkDeferredModules</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkDeferredModules</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; deferredModules.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> deferredModule = deferredModules[i];</span><br><span class="line">    <span class="keyword">var</span> fulfilled = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt; deferredModule.length; j++) &#123;</span><br><span class="line">      <span class="keyword">var</span> depId = deferredModule[j];</span><br><span class="line">      <span class="keyword">if</span> (installedChunks[depId] !== <span class="number">0</span>) fulfilled = <span class="literal">false</span>; <span class="comment">//判断依赖模块有没有加载过</span></span><br><span class="line">    <span class="keyword">if</span> (fulfilled) &#123;</span><br><span class="line">      deferredModules.splice(i--, <span class="number">1</span>);</span><br><span class="line">      result = __webpack_require__((__webpack_require__.s = deferredModule[<span class="number">0</span>])); <span class="comment">//如果所有依赖模块都加载了（即modules里有依赖模块），则就可以读取目标的module了</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要检查依赖的 <code>module</code> 是否加载过，若都加载了则加载目标 <code>module</code>。</p><ul><li><code>webpackJsonpCallback</code> 格外代码</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">deferredModules.push.apply(deferredModules, executeModules || []);</span><br><span class="line"><span class="keyword">return</span> checkDeferredModules();</span><br></pre></td></tr></table></figure><p>该方法增加了这两句代码，用于在调用 <code>webpackJsonpCallback</code> 时（即 <code>window[&quot;webpackJsonp&quot;].push</code> 或 <code>webpackJsonpCallback(jsonpArray[i])</code>），有其他依赖的时候可以再去调用 <code>checkDeferredModules</code> 进行依赖检查。</p><h2 id="splitChunks-切割后加载小结"><a href="#splitChunks-切割后加载小结" class="headerlink" title="splitChunks 切割后加载小结"></a>splitChunks 切割后加载小结</h2><p>梳理下 <code>splitChunks</code> 切割后的关键思路：</p><ol><li>根据 <code>script</code> 标签先后顺序，<code>html</code> 先加载公共依赖 <code>default~bundle1~bundle2.xx.js</code>，即在 <code>window[&quot;webpackJsonp&quot;]</code> 里 <code>push</code> 了该 <code>module</code>。</li><li><code>html</code> 加载 <code>bundle1.js</code>，在 <code>jsonp</code> 初始化里调用 <code>webpackJsonpCallback(jsonpArray[i])</code> 将公共依赖模块加到 <code>modules</code> 里并改变其状态为已加载后，调用 <code>checkDeferredModules()</code>，但 <code>deferredModules</code> 为空，所以没有任何操作。</li><li>然后回到 <code>runtime</code> 里继续执行，将当前 <code>module</code> 和依赖 <code>module</code> <code>push</code> 到 <code>deferredModules</code> 里，再次调用 <code>checkDeferredModules</code>，此时判断各依赖模块状态均为已加载后，加载当前 <code>module</code>。</li><li><code>html</code> 加载 <code>bundle2</code> 文件，此后逻辑跟 <code>bundle1</code> 一致。</li></ol>]]></content>
      
      
      <categories>
          
          <category> FE Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（十一）：文件的生成</title>
      <link href="382.html"/>
      <url>382.html</url>
      
        <content type="html"><![CDATA[<h2 id="资源写入文件"><a href="#资源写入文件" class="headerlink" title="资源写入文件"></a>资源写入文件</h2><p>回到 <code>seal</code>。执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.summarizeDependencies();</span><br></pre></td></tr></table></figure><p>得到 <code>this.fileDependencies, this.contextDependencies, this.missingDependencies</code> 后，触发了一系列处理资源，优化资源的钩子之后，回到 <code>Compiler.js</code> 的 <code>compile</code> 里的 <code>compilation.seal</code> 回调。</p><p>执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hooks.afterCompile.callAsync(compilation, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> callback(<span class="literal">null</span>, compilation);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>该钩子会触发插件 <code>CachePlugin</code> 相关的事件，给 <code>compiler</code> 的属性 <code>_lastCompilationFileDependencies，_lastCompilationContextDependencies</code> 分别赋值 <code>fileDependencies，contextDependencies</code>。</p><h3 id="创建目标文件夹"><a href="#创建目标文件夹" class="headerlink" title="创建目标文件夹"></a>创建目标文件夹</h3><p>然后执行回调即 <code>onCompiled</code>，方法里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.emitAssets(compilation, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>进入 <code>this.emitAssets</code>，<code>emitAssets</code> 负责的是构建资源输出的过程。在方法里触发了 <code>Compiler.hooks</code>:<code>emit</code>，在回调里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">outputPath = compilation.getPath(<span class="built_in">this</span>.outputPath); <span class="comment">// 获取资源输出的路径</span></span><br><span class="line"><span class="built_in">this</span>.outputFileSystem.mkdirp(outputPath, emitFiles); <span class="comment">// 递归创建输出目录并输出资源</span></span><br></pre></td></tr></table></figure><p><code>outputPath</code> 为配置里的 <code>output.path</code>，然后调用 <code>mkdirp</code> 创建文件夹。</p><h3 id="创建目标文件并写入"><a href="#创建目标文件并写入" class="headerlink" title="创建目标文件并写入"></a>创建目标文件并写入</h3><p>创建目标文件夹后，执行回调 <code>emitFiles</code>，在回调里通过 <code>asyncLib.forEachLimit</code> 并行执行对每个 <code>file</code> 资源文件进行路径拼接后，将每个 <code>source</code> 源码转换为 <code>buffer</code> 后（性能提升），写入真实路径的 <code>file</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">asyncLib.forEachLimit(</span><br><span class="line">  compilation.getAssets(),</span><br><span class="line">  <span class="number">15</span>,</span><br><span class="line">  (&#123; <span class="attr">name</span>: file, source &#125;, callback) =&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">const</span> writeOut = <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="keyword">const</span> targetPath = <span class="built_in">this</span>.outputFileSystem.join(outputPath, targetFile); <span class="comment">// 路径拼接，得到真实路径</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.options.output.futureEmitAssets) &#123;</span><br><span class="line">        <span class="comment">//...判断重写入 及 gc释放内存（this.assets相关重写SizeOnlySource）</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">let</span> content = source.source(); <span class="comment">//source为 CachedSource 实例，content为得到的资源</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!Buffer.isBuffer(content)) &#123;</span><br><span class="line">          content = Buffer.from(content, <span class="string">&#x27;utf8&#x27;</span>); <span class="comment">//buffer转换，在node中提升性能</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...写入文件</span></span><br><span class="line">        <span class="built_in">this</span>.outputFileSystem.writeFile(targetPath, content, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">          <span class="built_in">this</span>.hooks.assetEmitted.callAsync(file, content, callback);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 若目标文件路径包含/或\，先创建文件夹再写入</span></span><br><span class="line">    <span class="keyword">if</span> (targetFile.match(<span class="regexp">/\/|\\/</span>)) &#123;</span><br><span class="line">      <span class="keyword">const</span> dir = path.dirname(targetFile);</span><br><span class="line">      <span class="built_in">this</span>.outputFileSystem.mkdirp(<span class="built_in">this</span>.outputFileSystem.join(outputPath, dir), writeOut);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      writeOut();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 遍历完成的回调函数</span></span><br><span class="line">  (err) =&gt; &#123;</span><br><span class="line">    <span class="comment">//...回调</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> content = source.source();</span><br></pre></td></tr></table></figure><p><code>source</code> 为 <code>CachedSource</code> 实例，<code>source.source</code> 做了缓存判断，执行 <code>this._source.source</code>， <code>this._source</code> 为 <code>ConcatSource</code> 实例，该方法会遍历 <code>children</code>，如果子项不是字符串，则执行其 <code>source</code> 方法。</p><p>对于 <code>ReplaceSource</code> 实例来说，会执行其 <code>_replaceString</code> 方法，该方法里会循环处理替换在之前 <code>资源的构建 -&gt; 生成 chunk 资源 -&gt; chunkTemplate -&gt; 生成主体 chunk 代码 -&gt; 生成每个 module 代码</code> <code>push</code> 进去的 <code>replacements</code>，得到替换后的字符串，合并返回 <code>resultStr</code>。</p><h2 id="设置-stats-并打印构建信息"><a href="#设置-stats-并打印构建信息" class="headerlink" title="设置 stats 并打印构建信息"></a>设置 stats 并打印构建信息</h2><p>所有文件都创建写入完成后，执行回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hooks.afterEmit.callAsync(compilation, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">  <span class="keyword">return</span> callback();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在回调里触发 <code>Compiler.afterEmit</code>:<code>hooks</code>，在回调里执行 <code>callback</code> 即 <code>onCompiled</code> 里的 <code>this.emitAssets</code> 的回调，即执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="built_in">this</span>.emitRecords(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">const</span> stats = <span class="keyword">new</span> Stats(compilation);</span><br><span class="line">  stats.startTime = startTime;</span><br><span class="line">  stats.endTime = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="built_in">this</span>.hooks.done.callAsync(stats, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> finalCallback(err);</span><br><span class="line">    <span class="keyword">return</span> finalCallback(<span class="literal">null</span>, stats);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>执行 <code>this.emitRecords</code>，然后在其回调里设置相关 <code>stats</code>，然后在 <code>Compiler.done</code>:<code>hooks</code> 的回调里执行 <code>finalCallback</code>，即执行文件 <code>webpack-cli/bin/cli.js</code> 里的 <code>compiler.run</code> 的回调，即 <code>compilerCallback</code>。</p><p>方法里清除缓存之后，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> statsString = stats.toString(outputOptions);</span><br><span class="line"><span class="keyword">const</span> delimiter = outputOptions.buildDelimiter ? <span class="string">`<span class="subst">$&#123;outputOptions.buildDelimiter&#125;</span>\n`</span> : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span> (statsString) stdout.write(<span class="string">`<span class="subst">$&#123;statsString&#125;</span>\n<span class="subst">$&#123;delimiter&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><p>在 <code>cli</code> 里打印出构建相关的信息。至此，构建全部结束，下一章分析打包后的文件！</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>创建目标文件夹及文件并将资源写入；</li><li>写入的时候，会循环处理 <code>source</code> 中的 <code>ReplaceSource</code> 实例中的 <code>replacements</code>，将其替换为真实字符串；</li><li>设置 <code>stats</code> 并打印构建信息。</li></ol>]]></content>
      
      
      <categories>
          
          <category> FE Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（十）：资源的构建</title>
      <link href="381.html"/>
      <url>381.html</url>
      
        <content type="html"><![CDATA[<h2 id="生成-module-资源"><a href="#生成-module-资源" class="headerlink" title="生成 module 资源"></a>生成 module 资源</h2><p>接上文，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hooks.beforeModuleAssets.call();</span><br><span class="line"><span class="built_in">this</span>.createModuleAssets();</span><br></pre></td></tr></table></figure><p>这一步用于生成 <code>module</code> 资源。</p><p>在 <code>createModuleAssets</code> 里获取每个 <code>module.buildInfo.assets</code>，然后触发 <code>this.emitAsset</code> 生成资源。<code>buildInfo.assets</code> 相关数据可以在 <code>loader</code> 里调用 <code>api</code>: <code>this.emitFile</code> 生成。</p><h2 id="生成-chunk-资源"><a href="#生成-chunk-资源" class="headerlink" title="生成 chunk 资源"></a>生成 chunk 资源</h2><p>这一步用于创建 <code>chunk</code> 资源。</p><h3 id="生成前的准备"><a href="#生成前的准备" class="headerlink" title="生成前的准备"></a>生成前的准备</h3><h4 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h4><p>执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hooks.beforeChunkAssets.call();</span><br><span class="line"><span class="built_in">this</span>.createChunkAssets();</span><br></pre></td></tr></table></figure><p>在 <code>createChunkAssets</code> 里循环对每个 <code>chunk</code> 执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">const</span> template = chunk.hasRuntime() ? <span class="built_in">this</span>.mainTemplate : <span class="built_in">this</span>.chunkTemplate;</span><br><span class="line"><span class="keyword">const</span> manifest = template.getRenderManifest(&#123;</span><br><span class="line">  chunk,</span><br><span class="line">  hash: <span class="built_in">this</span>.hash,</span><br><span class="line">  fullHash: <span class="built_in">this</span>.fullHash,</span><br><span class="line">  outputOptions,</span><br><span class="line">  moduleTemplates: <span class="built_in">this</span>.moduleTemplates,</span><br><span class="line">  dependencyTemplates: <span class="built_in">this</span>.dependencyTemplates,</span><br><span class="line">&#125;); <span class="comment">//得到 `render` 所需要的全部信息：`[&#123; render(), filenameTemplate, pathOptions, identifier, hash &#125;]`</span></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>判断 <code>chunk</code> 是否含有 <code>runtime</code> 代码后即同步异步后，获取到对应的 <code>template</code>。异步 <code>chunk</code> 对应 <code>chunkTemplate</code>，同步及含有 <code>runtime</code> 的 <code>chunk</code> 对应 <code>mainTemplate</code>。</p><p>然后执行对应的 <code>getRenderManifest</code>，触发 <code>template.hooks：renderManifest</code> 执行插件 <code>JavascriptModulesPlugin</code> 相关事件得到 <code>render</code> 所需要的全部信息：<code>[&#123; render(), filenameTemplate, pathOptions, identifier, hash &#125;]</code>。</p><p>如果是 <code>chunkTemplate</code> 还会触发插件 <code>WebAssemblyModulesPlugin</code> 的相关事件处理 <code>WebAssembly</code> 相关。</p><h4 id="pathAndInfo"><a href="#pathAndInfo" class="headerlink" title="pathAndInfo"></a>pathAndInfo</h4><p>然后遍历 <code>manifest</code> 对象执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pathAndInfo = <span class="built_in">this</span>.getPathWithInfo(filenameTemplate, fileManifest.pathOptions);</span><br></pre></td></tr></table></figure><p><code>this.getPathWithInfo</code> 用于得到路径和相关信息。会触发 <code>mainTemplate.hooks</code>:<code>assetPath</code>，去执行插件 <code>TemplatedPathPlugin</code> 相关事件，使用若干 <code>replace</code> 将如 <code>[name].[chunkhash:8].js</code> 替换为 <code>0.e3296d88.js</code>。</p><h3 id="构建资源"><a href="#构建资源" class="headerlink" title="构建资源"></a>构建资源</h3><p>然后判断有无 <code>source</code> 缓存后，若无则执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source = fileManifest.render();</span><br></pre></td></tr></table></figure><p>即执行对应 <code>template</code> 的 <code>render</code>。</p><h3 id="chunkTemplate"><a href="#chunkTemplate" class="headerlink" title="chunkTemplate"></a>chunkTemplate</h3><h4 id="生成主体-chunk-代码"><a href="#生成主体-chunk-代码" class="headerlink" title="生成主体 chunk 代码"></a>生成主体 chunk 代码</h4><p>如果是异步 <code>chunk</code>，<code>render</code> 会执行在文件 <code>JavascriptModulesPlugin.js</code> 里的 <code>renderJavascript</code>。方法里先执行 <code>Template.renderChunkModules</code> 静态方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleSources = Template.renderChunkModules(chunk, <span class="function">(<span class="params">m</span>) =&gt;</span> <span class="keyword">typeof</span> m.source === <span class="string">&#x27;function&#x27;</span>, moduleTemplate, dependencyTemplates);</span><br></pre></td></tr></table></figure><h5 id="生成每个-module-代码"><a href="#生成每个-module-代码" class="headerlink" title="生成每个 module 代码"></a>生成每个 module 代码</h5><p>方法里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> allModules = modules.map(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    id: <span class="built_in">module</span>.id,</span><br><span class="line">    source: moduleTemplate.render(<span class="built_in">module</span>, dependencyTemplates, &#123;</span><br><span class="line">      chunk,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里循环对每一个 <code>module</code> 执行 <code>render</code>，方法里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleSource = <span class="built_in">module</span>.source(dependencyTemplates, <span class="built_in">this</span>.runtimeTemplate, <span class="built_in">this</span>.type);</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p><code>module.source</code>里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = <span class="built_in">this</span>.generator.generate(<span class="built_in">this</span>, dependencyTemplates, runtimeTemplate, type);</span><br></pre></td></tr></table></figure><p>这个 <code>generator</code> 就是在 <code>reslove 流程 -&gt; getGenerator</code> 所获得，即执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.sourceBlock(<span class="built_in">module</span>, <span class="built_in">module</span>, [], dependencyTemplates, source, runtimeTemplate);</span><br></pre></td></tr></table></figure><p>这里循环处理 <code>module</code> 的每个依赖（<code>module.dependencies</code>）：获得依赖所对应的 <code>template</code> 模板类，然后执行该类的 <code>apply</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> template = dependencyTemplates.get(dependency.constructor);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">template.apply(dependency, source, runtimeTemplate, dependencyTemplates);</span><br></pre></td></tr></table></figure><p>这里的 <code>dependencyTemplates</code> 就是在 <code>reslove 流程前的准备 -&gt;Compiler.compile -&gt;实例化 compilation</code> 里添加的依赖模板模块。</p><p>在 <code>apply</code>里，会根据依赖不同做相应的源码转化的处理。但方法里并没有直接执行源码转化的工作，而是将其转化对象 <code>push</code> 到 <code>ReplaceSource.replacements</code> 里，转化对象的格式为：</p><blockquote><p>注：<code>webpack-sources</code> 提供若干类型的 <code>source</code> 类，如 <code>CachedSource, PrefixSource, ConcatSource, ReplaceSource</code> 等。它们可以组合使用，方便对代码进行添加、替换、连接等操作。同时又含有一些 <code>source-map</code> 相关，<code>updateHash</code> 等 <code>api</code> 供 <code>webpack</code> 内部调用.</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Replacement</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;content&quot;</span>: <span class="string">&quot;__webpack_require__.r(__webpack_exports__);\n&quot;</span>, <span class="comment">// 替换的内容</span></span><br><span class="line">  <span class="attr">&quot;end&quot;</span>: <span class="number">-11</span>, <span class="comment">// 替换源码的终止位置</span></span><br><span class="line">  <span class="attr">&quot;insertIndex&quot;</span>: <span class="number">0</span>, <span class="comment">// 优先级</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 名称</span></span><br><span class="line">  <span class="attr">&quot;start&quot;</span>: <span class="number">-10</span> <span class="comment">// 替换源码的起始位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各模板的具体处理转化见 <code>构建 module（下） -&gt; parse 源码 -&gt; 各依赖作用解释</code>。</p><h5 id="包裹代码"><a href="#包裹代码" class="headerlink" title="包裹代码"></a>包裹代码</h5><p>收集完依赖相关的转化对象 <code>Replacement</code> 之后，回到 <code>module.source</code> 进行 <code>cachedSource</code> 缓存包装后，回到 <code>moduleTemplate.render</code> 方法得到 <code>moduleSource</code>。</p><p>然后触发相关 <code>ModuleTemplate.hooks：content，module，render，package</code>，前两个钩子主要是可以让我们完成对 <code>module</code> 源码的再次处理，然后在 <code>render</code> 钩子里执行插件 <code>FunctionModuleTemplatePlugin</code> 的相关事件，主要是给处理后的 <code>module</code> 源码进行包裹，即生成代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***/</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">//CachedSource 即为module源码，里面包含 replacements</span></span><br><span class="line">  <span class="comment">/***/</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h5><p>然后触发 <code>package</code> 钩子执行插件 <code>FunctionModuleTemplatePlugin</code> 的相关事件，主要作用是添加相关注释，即生成代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!***************************************************************!*\</span></span><br><span class="line"><span class="comment">  !*** ./src/c.js ***!</span></span><br><span class="line"><span class="comment">  \***************************************************************/</span></span><br><span class="line"><span class="comment">/*! exports provided: sub */</span></span><br><span class="line"><span class="comment">/***/</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">module</span>, __webpack_exports__, __webpack_require__</span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="comment">//CachedSource 即为module源码，里面包含 replacements</span></span><br><span class="line">  <span class="comment">/***/</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>将所有的 <code>module</code> 都处理完毕后，回到 <code>renderChunkModules</code>，继续处理生成代码，最终将每个 <code>module</code> 生成的代码串起来得到 <code>moduleSources</code> 回到了 <code>renderJavascript</code>里。</p><h4 id="生成异步包裹代码"><a href="#生成异步包裹代码" class="headerlink" title="生成异步包裹代码"></a>生成异步包裹代码</h4><p>方法里先触发 <code>chunkTemplate.hooks : modules</code> 为修改生成的 <code>chunk</code> 代码提供钩子，得到 <code>core</code> 后，触发 <code>chunkTemplate.hooks</code>:<code>render</code> 执行插件 <code>JsonpChunkTemplatePlugin</code> 相关事件，该事件主要是添加 <code>jsonp</code> 异步包裹代码，得到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">window</span>[<span class="string">&#x27;webpackJsonp&#x27;</span>] = <span class="built_in">window</span>[<span class="string">&#x27;webpackJsonp&#x27;</span>] || []).push([</span><br><span class="line">  [<span class="number">0</span>],</span><br><span class="line">  <span class="comment">// 前面生成的 chunk 代码</span></span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p>完成后，最后返回一个 <code>new ConcatSource(source, &quot;;&quot;)</code>。到此普通的异步 <code>chunk</code> 代码 <code>chunkTemplate</code> 的 <code>fileManifest.render</code> 代码构建完成。</p><h3 id="mainTemplate"><a href="#mainTemplate" class="headerlink" title="mainTemplate"></a>mainTemplate</h3><p>如果是同步 <code>chunk</code>，<code>render</code> 会执行在文件 <code>JavascriptModulesPlugin.js</code> 里的 <code>compilation.mainTemplate.render</code> 即文件 <code>MainTemplate.js</code> 里的 <code>render</code>。</p><h4 id="生成-runtime-代码"><a href="#生成-runtime-代码" class="headerlink" title="生成 runtime 代码"></a>生成 runtime 代码</h4><p>方法里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buf = <span class="built_in">this</span>.renderBootstrap(hash, chunk, moduleTemplate, dependencyTemplates);</span><br></pre></td></tr></table></figure><p>该方法得到 <code>webpack runtime bootstrap</code> 代码数组，从中会判断是否有异步 <code>chunk</code>，如果有，则代码里还会包含异步相关的 <code>runtime</code> 代码，如果还有其他什么延迟加载的模块，都会在这里处理为相应是 <code>runtime</code>。</p><h4 id="包裹-runtime-与-chunk-代码"><a href="#包裹-runtime-与-chunk-代码" class="headerlink" title="包裹 runtime 与 chunk 代码"></a>包裹 runtime 与 chunk 代码</h4><p>然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> source = <span class="built_in">this</span>.hooks.render.call(<span class="keyword">new</span> OriginalSource(Template.prefix(buf, <span class="string">&#x27; \t&#x27;</span>) + <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;webpack/bootstrap&#x27;</span>), chunk, hash, moduleTemplate, dependencyTemplates);</span><br></pre></td></tr></table></figure><p>先通过 <code>Template.prefix</code> 合并 <code>runtime</code> 代码字符串，得到 <code>OriginalSource</code> 的实例，然后将其作为参数执行 <code>MainTemplate.hooks</code> : <code>render</code>，该 <code>hook</code> 在 <code>constructor</code> 里已注册，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = <span class="keyword">new</span> ConcatSource();</span><br><span class="line">source.add(<span class="string">&#x27;/******/ (function(modules) &#123; // webpackBootstrap\n&#x27;</span>);</span><br><span class="line">source.add(<span class="keyword">new</span> PrefixSource(<span class="string">&#x27;/******/&#x27;</span>, bootstrapSource));</span><br><span class="line">source.add(<span class="string">&#x27;/******/ &#125;)\n&#x27;</span>);</span><br><span class="line">source.add(<span class="string">&#x27;/************************************************************************/\n&#x27;</span>);</span><br><span class="line">source.add(<span class="string">&#x27;/******/ (&#x27;</span>);</span><br><span class="line">source.add(<span class="built_in">this</span>.hooks.modules.call(<span class="keyword">new</span> RawSource(<span class="string">&#x27;&#x27;</span>), chunk, hash, moduleTemplate, dependencyTemplates));</span><br><span class="line">source.add(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line"><span class="keyword">return</span> source;</span><br></pre></td></tr></table></figure><p>该方法对 <code>runtime bootstrap</code> 代码进行了包装（<code>bootstrapSource</code> 即为前面生成的 <code>runtime</code> 代码），其中触发 <code>MainTemplate.hooks: modules</code> 得到 <code>chunk</code> 的生成代码，即最终返回一个包含了 <code>runtime</code> 代码和 <code>chunk</code> 代码的 <code>ConcatSource</code> 实例。</p><h4 id="生成-chunk-代码"><a href="#生成-chunk-代码" class="headerlink" title="生成 chunk 代码"></a>生成 chunk 代码</h4><p>这里来看 <code>chunk</code> 代码的实现，如上文代码中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hooks.modules.call(<span class="keyword">new</span> RawSource(<span class="string">&#x27;&#x27;</span>), chunk, hash, moduleTemplate, dependencyTemplates);</span><br></pre></td></tr></table></figure><p>这里 <code>mainTemplate.hooks: modules</code> 触发插件 <code>JavascriptModulesPlugin</code> 的相关事件，即执行 <code>Template</code> 类的静态方法 <code>renderChunkModules</code>。与前文 <code>chunkTemplate -&gt; 生成主体 chunk 代码</code> 的实现一致。</p><p>最终经过包裹后得到的代码大致如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;/******/ (function(modules) &#123; // webpackBootstrap</span></span><br><span class="line"><span class="string">// runtime 代码的 PrefixSource 实例</span></span><br><span class="line"><span class="string">/******/ &#125;)</span></span><br><span class="line"><span class="string">/************************************************************************/</span></span><br><span class="line"><span class="string">/******/ (&#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/***/ &quot;</span>../github/test-loader/loader.js?number=<span class="number">20</span>!./src/d.js<span class="string">&quot;:</span></span><br><span class="line"><span class="string">/*!************************************************************!*\</span></span><br><span class="line"><span class="string">  !*** ../github/test-loader/loader.js?number=20!./src/d.js ***!</span></span><br><span class="line"><span class="string">  \************************************************************/</span></span><br><span class="line"><span class="string">/*! exports provided: mul */</span></span><br><span class="line"><span class="string">/***/ (function(module, __webpack_exports__, __webpack_require__) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>use strict<span class="string">&quot;;</span></span><br><span class="line"><span class="string">// module d 的 CachedSource 实例</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/***/ &#125;),</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/***/ &quot;</span>./src/a.js<span class="string">&quot;:</span></span><br><span class="line"><span class="string">/*!******************!*\</span></span><br><span class="line"><span class="string">  !*** ./src/a.js ***!</span></span><br><span class="line"><span class="string">  \******************/</span></span><br><span class="line"><span class="string">/*! no exports provided */</span></span><br><span class="line"><span class="string">/***/ (function(module, __webpack_exports__, __webpack_require__) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>use strict<span class="string">&quot;;</span></span><br><span class="line"><span class="string">// module a 的 CachedSource 实例</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/***/ &#125;),</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/***/ &quot;</span>./src/b.js<span class="string">&quot;:</span></span><br><span class="line"><span class="string">/*!******************!*\</span></span><br><span class="line"><span class="string">  !*** ./src/b.js ***!</span></span><br><span class="line"><span class="string">  \******************/</span></span><br><span class="line"><span class="string">/*! exports provided: add, addddd */</span></span><br><span class="line"><span class="string">/***/ (function(module, __webpack_exports__, __webpack_require__) &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>use strict<span class="string">&quot;;</span></span><br><span class="line"><span class="string">// module b 的 CachedSource 实例</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/***/ &#125;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">/******/ &#125;)&quot;</span></span><br></pre></td></tr></table></figure><p>完成后，最后返回一个 <code>new ConcatSource(source, &quot;;&quot;)</code>。到此普通的同步 <code>chunk</code> 代码 <code>mainTemplate</code> 的 <code>fileManifest.render</code> 代码构建完成。</p><h3 id="文件名映射资源"><a href="#文件名映射资源" class="headerlink" title="文件名映射资源"></a>文件名映射资源</h3><p>无论是同步还是异步，最后都回到 <code>Compilation.js</code> 的 <code>createChunkAssets</code> 里，做了 <code>source</code> 缓存，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.emitAsset(file, source, assetInfo);</span><br></pre></td></tr></table></figure><p>建立起了文件名与对应源码的联系，将该映射对象挂载到 <code>compilation.assets</code> 下。 然后设置了 <code>alreadyWrittenFiles</code> 这个 <code>Map</code> 对象，防止重复构建代码。到此一个 <code>chunk</code> 的资源构建结束。</p><p><code>chunk</code> 遍历结束后，得到 <code>compilation.assets</code> 和 <code>compilation.assetsInfo</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compilation</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="string">&quot;assets&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;0.3e.js&quot;</span>: CachedSource, <span class="comment">// CachedSource 里包含资源</span></span><br><span class="line">    <span class="string">&quot;bundle.bf23.js&quot;</span>: CachedSource</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//...map结构</span></span><br><span class="line">  <span class="string">&quot;assetsInfo&quot;</span>: &#123;</span><br><span class="line">    <span class="number">0</span>: &#123;</span><br><span class="line">      <span class="string">&quot;key&quot;</span>: <span class="string">&#x27;0.3e.js&#x27;</span>,</span><br><span class="line">      <span class="string">&quot;value&quot;</span>: &#123;</span><br><span class="line">        immutable:<span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">1</span>: &#123;</span><br><span class="line">      <span class="string">&quot;key&quot;</span>: <span class="string">&#x27;bundle.bf23.js&#x27;</span>,</span><br><span class="line">      <span class="string">&quot;value&quot;</span>: &#123;</span><br><span class="line">        immutable:<span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>通过 <code>this.emitFile</code> 可生成 <code>module</code> 资源，如果有则直接调用 <code>this.emitAsset</code> 生成资源；</li><li>生成 <code>chunk</code> 资源时，先根据是否含有 <code>runtime</code> 得到不同的 <code>template</code>，包括 <code>chunkTemplate</code> 和 <code>mainTemplate</code>;</li><li>通过不同的 <code>template</code> 得到不同的 <code>manifest</code> 和 <code>pathAndInfo</code>，然后调用不同的 <code>render</code> 渲染代码；</li><li>最后建立文件名与资源之间的映射，最终一起挂载到 <code>compilation.assets</code> 即目标资源。</li></ol>]]></content>
      
      
      <categories>
          
          <category> FE Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（九）：优化 chunk</title>
      <link href="380.html"/>
      <url>380.html</url>
      
        <content type="html"><![CDATA[<h2 id="chunk-的一些优化"><a href="#chunk-的一些优化" class="headerlink" title="chunk 的一些优化"></a>chunk 的一些优化</h2><p>在 <code>chunk</code> 生成后，开始进行 <code>chunk</code> 优化之类的处理。</p><p>在触发钩子 <code>optimize，optimizeModules</code>（<code>module</code> 相关的优化）等之后，忽略掉本次打包未触发插件的钩子，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hooks.optimizeChunksBasic.call(<span class="built_in">this</span>.chunks, <span class="built_in">this</span>.chunkGroups);</span><br></pre></td></tr></table></figure><p>触发插件：</p><ul><li><code>EnsureChunkConditionsPlugin</code> 处理 <code>chunkCondition</code></li><li><code>RemoveEmptyChunksPlugin</code> 移除空 <code>chunk</code></li><li><code>MergeDuplicateChunksPlugin</code> 处理重复 <code>chunk</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hooks.optimizeChunksAdvanced.call(<span class="built_in">this</span>.chunks, <span class="built_in">this</span>.chunkGroups);</span><br></pre></td></tr></table></figure><p>触发插件：</p><ul><li><code>SplitChunksPlugin</code> 优化切割 <code>chunk</code></li><li><code>RemoveEmptyChunksPlugin</code> 再次移除空 <code>chunk</code></li></ul><h2 id="设置-module-id"><a href="#设置-module-id" class="headerlink" title="设置 module.id"></a>设置 module.id</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hooks.reviveModules.call(<span class="built_in">this</span>.modules, <span class="built_in">this</span>.records);</span><br></pre></td></tr></table></figure><p>触发插件 <code>RecordIdsPlugin</code>：设置 <code>module.id</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hooks.beforeModuleIds.call(<span class="built_in">this</span>.modules);</span><br></pre></td></tr></table></figure><p>触发插件 <code>NamedModulesPlugin</code>： 设置 <code>module.id</code> 为 文件相对路径，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.applyModuleIds();</span><br></pre></td></tr></table></figure><p>这一步主要用于设置 <code>module.id</code>（如果 <code>id</code> 在上一步没有设置的话），内部具体算法为：</p><p>先遍历各 <code>module</code>，找出其中最大的 <code>id</code> 以他为最大值（<code>usedIdmax</code>），计算出比他小的所有未使用的正整数和（<code>usedIdmax+1</code>）作为 <code>unusedIds</code> 用于给没有设置 <code>id</code> 的 <code>module</code> 使用，<code>unusedIds</code> 用尽后，则设置 <code>id</code> 为 <code>（usedIdmax+1）++</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.sortItemsWithModuleIds();</span><br></pre></td></tr></table></figure><p>根据 <code>module.id</code> 给 <code>module，chunk，reasons</code> 等排序。</p><h2 id="设置-chunk-id"><a href="#设置-chunk-id" class="headerlink" title="设置 chunk.id"></a>设置 chunk.id</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hooks.reviveChunks.call(<span class="built_in">this</span>.chunks, <span class="built_in">this</span>.records);</span><br></pre></td></tr></table></figure><p>触发插件 <code>RecordIdsPlugin</code>：设置 <code>chunk.id</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hooks.optimizeChunkOrder.call(<span class="built_in">this</span>.chunks);</span><br></pre></td></tr></table></figure><p>触发插件 <code>OccurrenceOrderChunkIdsPlugin</code>：<code>chunks</code> 排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hooks.beforeChunkIds.call(<span class="built_in">this</span>.chunks);</span><br></pre></td></tr></table></figure><p>触发插件 <code>NamedChunksPlugin</code>：设置 <code>chunk.id = chunk.name</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.applyChunkIds();</span><br></pre></td></tr></table></figure><p>这一步主要用于设置 <code>chunk.id</code>，算法与 <code>this.applyModuleIds</code> 一致。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.sortItemsWithChunkIds();</span><br></pre></td></tr></table></figure><p>根据 <code>chunk.id</code> 给 <code>module，chunk，reasons，errors，warnings，children</code> 等排序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldRecord) &#123;</span><br><span class="line">  <span class="built_in">this</span>.hooks.recordModules.call(<span class="built_in">this</span>.modules, <span class="built_in">this</span>.records);</span><br><span class="line">  <span class="built_in">this</span>.hooks.recordChunks.call(<span class="built_in">this</span>.chunks, <span class="built_in">this</span>.records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依旧是对 <code>records</code> 的一些设置。</p><h2 id="创建-hash"><a href="#创建-hash" class="headerlink" title="创建 hash"></a>创建 hash</h2><p>接下来执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hooks.beforeHash.call();</span><br><span class="line"><span class="built_in">this</span>.createHash();</span><br><span class="line"><span class="built_in">this</span>.hooks.afterHash.call();</span><br><span class="line"><span class="keyword">if</span> (shouldRecord) &#123;</span><br><span class="line">  <span class="built_in">this</span>.hooks.recordHash.call(<span class="built_in">this</span>.records);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入 <code>createHash</code>，前文已介绍生成 <code>hash</code> 的方法，此处先初始化一个 <code>hash</code>，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.mainTemplate.updateHash(hash);</span><br><span class="line"><span class="built_in">this</span>.chunkTemplate.updateHash(hash);</span><br></pre></td></tr></table></figure><ul><li><code>mainTemplate</code>: 渲染生成包含 <code>webpack runtime bootstrap</code> 代码的 <code>chunk</code></li><li><code>chunkTemplate</code>: 渲染生成普通 <code>chunk</code></li></ul><p><code>mainTemplate</code> 在 <code>update(&#39;maintemplate&#39;,&#39;3&#39;)</code> 后，触发 <code>MainTemplate.hooks</code>: <code>hash</code>，执行插件 <code>JsonpMainTemplatePlugin</code>，<code>WasmMainTemplatePlugin</code> 内的相关事件，<code>hash.buffer</code> 更新为 <code>maintemplate3jsonp6WasmMainTemplatePlugin2</code>。</p><p><code>chunkTemplate</code> 在 <code>update(&#39;ChunkTemplate&#39;,&#39;2&#39;)</code> 后，触发<code>ChunkTemplate.hooks</code>: <code>hash</code>，执行插件 <code>JsonpChunkTemplatePlugin</code>内的相关事件，<code>hash.buffer</code> 更新为 <code>maintemplate3jsonp6WasmMainTemplatePlugin2ChunkTemplate2JsonpChunkTemplatePlugin4webpackJsonpwindow</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(<span class="built_in">this</span>.moduleTemplates).sort()) &#123;</span><br><span class="line">  <span class="built_in">this</span>.moduleTemplates[key].updateHash(hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下代码为 complation 实例化的时候所定义</span></span><br><span class="line"><span class="built_in">this</span>.moduleTemplates = &#123;</span><br><span class="line">  javascript: <span class="keyword">new</span> ModuleTemplate(<span class="built_in">this</span>.runtimeTemplate, <span class="string">&#x27;javascript&#x27;</span>),</span><br><span class="line">  webassembly: <span class="keyword">new</span> ModuleTemplate(<span class="built_in">this</span>.runtimeTemplate, <span class="string">&#x27;webassembly&#x27;</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将 <code>this.moduleTemplates</code> 的 <code>key</code> 排序后执行各自的 <code>updateHash</code>，<code>hash.buffer</code> 更新为 <code>maintemplate3jsonp6WasmMainTemplatePlugin2ChunkTemplate2JsonpChunkTemplatePlugin4webpackJsonpwindow1FunctionModuleTemplatePlugin21</code></p><p>然后如果有 <code>children,warnings,errors</code> 也把他们的 <code>hash</code> 或者 <code>message</code> <code>update</code> 进去。然后执行：</p><h3 id="创建-module-hash"><a href="#创建-module-hash" class="headerlink" title="创建 module hash"></a>创建 module hash</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; modules.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = modules[i];</span><br><span class="line">  <span class="keyword">const</span> moduleHash = createHash(hashFunction);</span><br><span class="line">  <span class="built_in">module</span>.updateHash(moduleHash);</span><br><span class="line">  <span class="built_in">module</span>.hash = <span class="comment">/** <span class="doctag">@type <span class="type">&#123;string&#125;</span> </span>*/</span> (moduleHash.digest(hashDigest));</span><br><span class="line">  <span class="built_in">module</span>.renderedHash = <span class="built_in">module</span>.hash.substr(<span class="number">0</span>, hashDigestLength);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里循环初始化了每个 <code>module</code> 的 <code>hash</code>，并调用了每个 <code>module</code> 的 <code>updateHash</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.updateHash(moduleHash);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面 module.updateHash 调用</span></span><br><span class="line">hash.update(<span class="built_in">this</span>._buildHash); <span class="comment">//这里加入了 _buildHash</span></span><br><span class="line"><span class="built_in">super</span>.updateHash(hash);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面 super 调用</span></span><br><span class="line">hash.update(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.id&#125;</span>`</span>);</span><br><span class="line">hash.update(<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.usedExports));</span><br><span class="line"><span class="built_in">super</span>.updateHash(hash);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面 super 调用</span></span><br><span class="line"><span class="comment">//调用各自 dependencies，blocks，variables的 updateHash</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> dep <span class="keyword">of</span> <span class="built_in">this</span>.dependencies) dep.updateHash(hash);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> block <span class="keyword">of</span> <span class="built_in">this</span>.blocks) block.updateHash(hash);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> variable <span class="keyword">of</span> <span class="built_in">this</span>.variables) variable.updateHash(hash);</span><br></pre></td></tr></table></figure><p>最终得到 <code>moduleHash.buffer</code> 形如：<code>ac01f98d10f099796d2f3d600c2592d1./src/a.jsnull0,28./src/b.jsnamespace./src/b.js29,57./src/c.jsnamespace./src/c.js58,121../github/test-loader/loader.js?number=20000!./src/e.jsnamespace../github/test-loader/loader.js?number=20000!./src/e.js./src/b.jsnamespace./src/b.jsaddaddnamespacenullnull./src/c.jsnamespace./src/c.jssubsubnamespacenullnull../github/test-loader/loader.js?number=20000!./src/e.jsnamespace../github/test-loader/loader.js?number=20000!./src/e.jsdivdivnamespacenullnull</code></p><p>然后最终生成出 <code>module</code> 各自的 <code>hash</code> 和 <code>renderedHash</code>。</p><h3 id="创建-chunk-hash"><a href="#创建-chunk-hash" class="headerlink" title="创建 chunk hash"></a>创建 chunk hash</h3><p>继续执行，先对 <code>chunks</code> 进行排序，然后遍历 <code>chunks</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; chunks.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> chunk = chunks[i];</span><br><span class="line">  <span class="keyword">const</span> chunkHash = createHash(hashFunction);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (outputOptions.hashSalt) &#123;</span><br><span class="line">      chunkHash.update(outputOptions.hashSalt);</span><br><span class="line">    &#125;</span><br><span class="line">    chunk.updateHash(chunkHash);</span><br><span class="line">    <span class="keyword">const</span> template = chunk.hasRuntime() ? <span class="built_in">this</span>.mainTemplate : <span class="built_in">this</span>.chunkTemplate;</span><br><span class="line">    template.updateHashForChunk(chunkHash, chunk, <span class="built_in">this</span>.moduleTemplates.javascript, <span class="built_in">this</span>.dependencyTemplates);</span><br><span class="line">    <span class="built_in">this</span>.hooks.chunkHash.call(chunk, chunkHash);</span><br><span class="line">    chunk.hash = <span class="comment">/** <span class="doctag">@type <span class="type">&#123;string&#125;</span> </span>*/</span> (chunkHash.digest(hashDigest));</span><br><span class="line">    hash.update(chunk.hash);</span><br><span class="line">    chunk.renderedHash = chunk.hash.substr(<span class="number">0</span>, hashDigestLength);</span><br><span class="line">    <span class="built_in">this</span>.hooks.contentHash.call(chunk);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">this</span>.errors.push(<span class="keyword">new</span> ChunkRenderError(chunk, <span class="string">&#x27;&#x27;</span>, err));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里循环初始化了每个 <code>chunk</code> 的 <code>hash</code>，并调用了每个 <code>chunk</code> 的 <code>updateHash</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chunk.updateHash(chunkHash);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面 chunk.updateHash 调用</span></span><br><span class="line">hash.update(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.id&#125;</span> `</span>);</span><br><span class="line">hash.update(<span class="built_in">this</span>.ids ? <span class="built_in">this</span>.ids.join(<span class="string">&#x27;,&#x27;</span>) : <span class="string">&#x27;&#x27;</span>);</span><br><span class="line">hash.update(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name || <span class="string">&#x27;&#x27;</span>&#125;</span> `</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> m <span class="keyword">of</span> <span class="built_in">this</span>._modules) &#123;</span><br><span class="line">  hash.update(m.hash); <span class="comment">//此处把每个 module 的 hash 一并加入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到 <code>chunkHash.buffer</code> 形如 <code>bundle bundlebundle 99d78a1615d2e348fbf274adb4e0b67c4fa9f69c98e5b41607cb6354e95983c3824bbf3e0b5e82705f88a41a6741b08f2f18bdc137e8a1e8e6cc78ca7ce0caf64b500a96034ab069ecf31c34f944ede6</code>，然后判断 <code>chunk</code> 是否含有 <code>runtime</code> 代码（ <code>template</code> 判断入口 <code>chunk</code> 与运行时 <code>chunk</code> 一致则为 <code>this.mainTemplate</code>，不一致则为 <code>this.chunkTemplate</code> ）。</p><h4 id="chunkTemplate"><a href="#chunkTemplate" class="headerlink" title="chunkTemplate"></a>chunkTemplate</h4><p>如果是 <code>chunkTemplate</code> 的 <code>updateHashForChunk</code>，则执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.updateHash(hash); <span class="comment">//与上文 this.chunkTemplate.updateHash(hash) 执行相同</span></span><br><span class="line"><span class="built_in">this</span>.hooks.hashForChunk.call(hash, chunk);</span><br></pre></td></tr></table></figure><p><code>this.hooks.hashForChunk.call(hash, chunk)</code> 触发插件 <code>JsonpChunkTemplatePlugin</code> 相关事件， <code>update</code> <code>entryModule</code> 和 <code>group.childrenIterable</code>。</p><h4 id="mainTemplate"><a href="#mainTemplate" class="headerlink" title="mainTemplate"></a>mainTemplate</h4><p>如果是 <code>mainTemplate</code> 的 <code>updateHashForChunk</code>，则执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.updateHash(hash); <span class="comment">//与上文 this.mainTemplate.updateHash(hash) 执行相同</span></span><br><span class="line"><span class="built_in">this</span>.hooks.hashForChunk.call(hash, chunk);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> line <span class="keyword">of</span> <span class="built_in">this</span>.renderBootstrap(<span class="string">&#x27;0000&#x27;</span>, chunk, moduleTemplate, dependencyTemplates)) &#123;</span><br><span class="line">  hash.update(line);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this.hooks.hashForChunk.call(hash, chunk)</code> 触发插件 <code>TemplatedPathPlugin</code> 相关事件，根据 <code>chunkFilename</code> 的不同配置，<code>update chunk.getChunkMaps</code> 的不同导出，<code>chunk.getChunkMaps</code> 的实现为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getChunkMaps</span>(<span class="params">realHash</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> chunkHashMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> chunkContentHashMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> chunkNameMap = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> chunk <span class="keyword">of</span> <span class="built_in">this</span>.getAllAsyncChunks()) &#123;</span><br><span class="line">    chunkHashMap[chunk.id] = realHash ? chunk.hash : chunk.renderedHash;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(chunk.contentHash)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!chunkContentHashMap[key]) &#123;</span><br><span class="line">        chunkContentHashMap[key] = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      chunkContentHashMap[key][chunk.id] = chunk.contentHash[key];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (chunk.name) &#123;</span><br><span class="line">      chunkNameMap[chunk.id] = chunk.name;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    hash: chunkHashMap, <span class="comment">// chunkFilename 配置为 chunkhash的导出</span></span><br><span class="line">    contentHash: chunkContentHashMap, <span class="comment">// chunkFilename 配置为 contenthash 的导出</span></span><br><span class="line">    name: chunkNameMap <span class="comment">// chunkFilename 配置为 name 的导出</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见各种类型的 <code>hash</code> 都与其他的 <code>不含runtime模块即异步模块</code> 的 <code>hash</code> 有强关联，所以前面的 <code>chunk</code> 排序也就很重要。</p><p><code>this.renderBootstrap</code> 用于拼接 <code>webpack runtime bootstrap</code> 代码字符串。这里相当于把每一行 <code>runtime</code> 代码循环 <code>update</code> 进去，到此 <code>chunk hash</code> 生成结束。 将 <code>chunk.hash</code> <code>update</code> 到 <code>hash</code> 上。 最终得到 <code>chunk.hash</code> 和 <code>chunk.renderedHash</code>。</p><h3 id="创建-content-hash-amp-fullhash-amp-hash"><a href="#创建-content-hash-amp-fullhash-amp-hash" class="headerlink" title="创建 content hash &amp; fullhash &amp; hash"></a>创建 content hash &amp; fullhash &amp; hash</h3><p>然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hooks.contentHash.call(chunk);</span><br></pre></td></tr></table></figure><p>这里触发 <code>JavascriptModulesPlugin</code> 相关事件，主要作用是创建生成 <code>chunk.contentHash.javascript</code>，也就是 <code>contentHash</code> 生成相关，大体跟生成 <code>chunk hash</code> 一致.</p><p>最后在 <code>createHash</code> 里得到 <code>Compilation.hash</code> 和 <code>Compilation.fullhash</code>，<code>hash</code> 生成到此结束。<code>chunk</code> 相关优化到此结束。</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>本章主要是对 <code>chunk</code> 的一些优化工作，暴露了很多相关的优化钩子；</li><li>设置了 <code>module.id</code> 及 <code>chunk.id</code> 并排序；</li><li>创建了 <code>hash</code>，包括 <code>module hash，chunk hash，content hash，fullhash，hash</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> FE Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（八）：生成 chunk</title>
      <link href="379.html"/>
      <url>379.html</url>
      
        <content type="html"><![CDATA[<p><code>module</code> 构建完成后，回到文件 <code>Compiler.js</code> 的 <code>compile</code> 的 <code>make</code> 钩子的回调里:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hooks.make.callAsync(compilation, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  compilation.finish(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    compilation.seal(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="built_in">this</span>.hooks.afterCompile.callAsync(compilation, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> callback(<span class="literal">null</span>, compilation);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="compilation-finish-amp-compilation-seal"><a href="#compilation-finish-amp-compilation-seal" class="headerlink" title="compilation.finish &amp; compilation.seal"></a>compilation.finish &amp; compilation.seal</h2><p>执行 <code>compilation.finish</code>，触发 <code>compilation.hooks</code>：<code>finishModules</code>，执行插件 <code>FlagDependencyExportsPlugin</code> 注册的事件，作用是遍历所有 <code>module</code> 将 <code>export</code> 出来的变量以数组的形式，单独存储到 <code>module.buildMeta.providedExports</code>变量下。</p><p>然后执行 <code>reportDependencyErrorsAndWarnings</code> 收集生成每一个 <code>module</code> 时暴露出来的 <code>err</code> 和 <code>warning</code>。</p><p>然后走回调执行 <code>compilation.seal</code> 触发了海量 <code>hooks</code>，为我们侵入 <code>webpack</code> 构建流程提供了海量钩子。我们略过本 <code>demo</code> 没有注册方法的钩子，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hooks.seal.call();</span><br></pre></td></tr></table></figure><p>触发插件 <code>WarnCaseSensitiveModulesPlugin</code>：模块文件路径需要区分大小写的警告</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hooks.optimizeDependencies.call(<span class="built_in">this</span>.modules);</span><br></pre></td></tr></table></figure><p><code>production</code> 模式会触发插件：</p><ul><li><code>SideEffectsFlagPlugin</code>：识别 <code>package.json</code> 或者 <code>module.rules</code> 的 <code>sideEffects</code> 标志（纯的 ES2015 模块)，安全地删除未用到的 <code>export</code> 导出</li><li><code>FlagDependencyUsagePlugin</code>：编译时标记依赖 <code>unused harmony export</code> 用于 <code>Tree shaking</code></li></ul><h2 id="chunk-初始化"><a href="#chunk-初始化" class="headerlink" title="chunk 初始化"></a>chunk 初始化</h2><p>在触发 <code>compilation.hooks</code>:<code>beforeChunks</code> 后，开始遍历入口对象 <code>this._preparedEntrypoints</code>，为<strong>每一个入口</strong>生成一个 <code>chunk</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chunk = <span class="built_in">this</span>.addChunk(name);</span><br></pre></td></tr></table></figure><p>该方法里做了缓存判断后执行 <code>new Chunk(name)</code>，并同时添加 <code>chunk</code> 到 <code>Compilation.chunks</code>，继续执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> entrypoint = <span class="keyword">new</span> Entrypoint(name);</span><br></pre></td></tr></table></figure><p><code>Entrypoint</code> 类扩展于 <code>ChunkGroup</code> 类，是 <code>chunks</code> 的集合，主要用来优化 <code>chunk graph</code>。</p><p>继续执行设置了 <code>Compilation.runtimeChunk &amp; Compilation.namedChunkGroups &amp; Compilation.entrypoints &amp; Compilation.chunkGroups</code> 和 <code>ChunkGroup.origins</code>，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GraphHelpers.connectChunkGroupAndChunk(entrypoint, chunk);</span><br><span class="line">GraphHelpers.connectChunkAndModule(chunk, <span class="built_in">module</span>);</span><br></pre></td></tr></table></figure><p>建立了 <code>chunk</code> 与 <code>entrypoint</code>，<code>chunk</code> 与 <code>module</code> 之间的联系，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.assignDepth(<span class="built_in">module</span>);</span><br></pre></td></tr></table></figure><p>根据各个模块依赖的深度（多次依赖取最小值）设置 <code>module.depth</code>，入口模块则为 <code>depth = 0</code>。</p><p>遍历完 <code>this._preparedEntrypoints</code> 后，然后执行：</p><h2 id="生成-chunk-graph"><a href="#生成-chunk-graph" class="headerlink" title="生成 chunk graph"></a>生成 chunk graph</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buildChunkGraph(<span class="built_in">this</span>, <span class="comment">/** <span class="doctag">@type <span class="type">&#123;Entrypoint[]&#125;</span> </span>*/</span> (<span class="built_in">this</span>.chunkGroups.slice()));</span><br></pre></td></tr></table></figure><p><strong><code>buildChunkGraph</code> 用于生成并优化 <code>chunk</code> 依赖图，建立起各模块之前的关系。</strong> 分为三阶段：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PART ONE</span></span><br><span class="line">visitModules(compilation, inputChunkGroups, chunkGroupInfoMap, chunkDependencies, blocksWithNestedBlocks, allCreatedChunkGroups);</span><br><span class="line"><span class="comment">// PART TWO</span></span><br><span class="line">connectChunkGroups(blocksWithNestedBlocks, chunkDependencies, chunkGroupInfoMap);</span><br><span class="line"><span class="comment">// Cleaup work</span></span><br><span class="line">cleanupUnconnectedGroups(compilation, allCreatedChunkGroups);</span><br></pre></td></tr></table></figure><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h3><p>第一阶段主要建立了 <code>chunkGroup,chunk,module</code>（包括同步异步）之间的从属关系。</p><p>先执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> blockInfoMap = extraceBlockInfoMap(compilation);</span><br></pre></td></tr></table></figure><p>得到一个 <code>map</code> 结构： <code>module</code> 与该 <code>module</code> 内导入其他模块的关系，同步存入 <code>modules</code>，异步存入 <code>blocks</code>。以 <code>demo</code> 为例，得到 <code>blockInfoMap</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...map结构</span></span><br><span class="line">  <span class="number">0</span>:&#123;</span><br><span class="line">    key:NormalModule, <span class="comment">//a</span></span><br><span class="line">    value:&#123;</span><br><span class="line">      blocks:[ImportDependenciesBlock],<span class="comment">//异步</span></span><br><span class="line">      modules:[NormalModule] <span class="comment">//b  modules为set结构</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">1</span>:&#123;</span><br><span class="line">    key: ImportDependenciesBlock,</span><br><span class="line">    value:&#123;</span><br><span class="line">      blocks: [],</span><br><span class="line">      modules:[NormalModule] <span class="comment">//c</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">2</span>:&#123;</span><br><span class="line">    key: NormalModule, <span class="comment">//c</span></span><br><span class="line">    value:&#123;</span><br><span class="line">      blocks: [ImportDependenciesBlock],</span><br><span class="line">      modules:[NormalModule] <span class="comment">//d</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续执行，设置了 <code>queue</code> 数组，<code>push</code> 入口 <code>module</code> 和对应的 <code>action</code> 等信息组成的对象，用于 <code>while</code> 循环：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">queue.push(&#123;</span><br><span class="line">  action: ENTER_MODULE,</span><br><span class="line">  block: <span class="built_in">module</span>,</span><br><span class="line">  <span class="built_in">module</span>,</span><br><span class="line">  chunk,</span><br><span class="line">  chunkGroup,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>设置了 <code>chunkGroupInfoMap</code>，他映射了 <code>chunkGroup</code> 和与他相关的信息对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">chunkGroupInfoMap.set(chunkGroup, &#123;</span><br><span class="line">  chunkGroup,</span><br><span class="line">  minAvailableModules: <span class="keyword">new</span> <span class="built_in">Set</span>(),</span><br><span class="line">  minAvailableModulesOwned: <span class="literal">true</span>,</span><br><span class="line">  availableModulesToBeMerged: [],</span><br><span class="line">  skippedItems: [],</span><br><span class="line">  resultingAvailableModules: <span class="literal">undefined</span>,</span><br><span class="line">  children: <span class="literal">undefined</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">while</span> (queue.length) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (chunkGroup !== queueItem.chunkGroup) &#123;</span><br><span class="line">      <span class="comment">// 重置更新chunkGroup</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (queueItem.action) &#123;</span><br><span class="line">      <span class="keyword">case</span> ADD_AND_ENTER_MODULE: &#123;</span><br><span class="line">        <span class="comment">// 如果 queueItem.module 在 minAvailableModules，则将该 queueItem 存入 skippedItems</span></span><br><span class="line">        <span class="comment">// 建立 chunk 和 module 之间的联系，将依赖的 module 存入该 chunk 里</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> ENTER_MODULE: &#123;</span><br><span class="line">        <span class="comment">// 设置 chunkGroup._moduleIndices 和 module.index，然后 queue.push 一个新的该 module 的 queueItem，action 设为 LEAVE_MODULE</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> PROCESS_BLOCK: &#123;</span><br><span class="line">        <span class="comment">// 0. 通过上文 blockInfoMap 映射关系及入口 module，找到入口 module 所依赖的其他同步、异步模块</span></span><br><span class="line">        <span class="comment">// 1. 遍历其同步模块 modules，如果对应 chunk 已有此 module 则跳过；判断此 module 是否在 minAvailableModules，有则将一个新的 queueItem 存入 skippedItems，没有则存入 queue，其中 queueItem.action 都设为 ADD_AND_ENTER_MODULE</span></span><br><span class="line">        <span class="comment">// 2. 遍历 blockInfoMap 里的异步模块 blocks</span></span><br><span class="line">        <span class="comment">// 2.1 创建一个对应异步依赖的 chunkGroup 和 chunk，并建立两者的联系，然后更新了 compilation.chunkGroups 和 compilation.namedChunkGroups，chunkGroupCounters(计数 map)，blockChunkGroups（映射依赖和 ChunkGroup 的关系 map），allCreatedChunkGroups（收集被创建的ChunkGroup set）</span></span><br><span class="line">        <span class="comment">// 2.2 更新 chunkDependencies（map） 建立前一个 ChunkGroup 与新的 ChunkGroup 和 import 依赖的映射</span></span><br><span class="line">        <span class="comment">// 2.3 更新 queueConnect（map） 建立前一个 ChunkGroup 与新的 ChunkGroup 的映射</span></span><br><span class="line">        <span class="comment">// 2.4 更新 queueDelayed，同 queue，注意 module 是前一个的 module，action 为 PROCESS_BLOCK</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> LEAVE_MODULE: &#123;</span><br><span class="line">        <span class="comment">// 设置 chunkGroup._moduleIndices2 和 module.index2</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 上文 while (queue.length) 从 enter module 开始，循环将所有同步依赖都加入到同一个 chunk 里，将 enter module 及它的同步依赖里的异步依赖都各自新建了chunkGroup 和 chunk，并将异步模块存入 queueDelayed，异步依赖中的异步依赖还未处理。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (queueConnect.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 计算可用的模块</span></span><br><span class="line">    <span class="comment">// 1. 在 chunkGroupInfoMap 中设置前一个 ChunkGroup 的信息对象的 resultingAvailableModules, children</span></span><br><span class="line">    <span class="comment">// 2. 在 chunkGroupInfoMap 中初始化新的 ChunkGroup 与他相关的信息对象的映射并设置了 availableModulesToBeMerged</span></span><br><span class="line">    <span class="keyword">if</span> (outdatedChunkGroupInfo.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 合并可用模块</span></span><br><span class="line">      <span class="comment">// 1.获取设置新的 ChunkGroup 信息对象的 minAvailableModules</span></span><br><span class="line">      <span class="comment">// 2.如果新的 ChunkGroup 信息对象的 skippedItems 不为空则 push 到 queue</span></span><br><span class="line">      <span class="comment">// 3.如果新的 ChunkGroup 信息对象的 children 不为空，则更新 queueConnect 递归循环</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 把 queueDelayed 放入 queue 走 while 的最外层循环，目的的所有同步循环处理完后，然后才处理异步 module，如果异步 module 里还有异步 module，将放到下一次的 queue 走 while 的最外层循环</span></span><br><span class="line">  <span class="keyword">if</span> (queue.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> tempQueue = queue; <span class="comment">// ImportDependenciesBlock</span></span><br><span class="line">    queue = queueDelayed.reverse();</span><br><span class="line">    queueDelayed = tempQueue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在内部 <code>while</code> 对 <code>queue.length</code> 循环里（ <code>while+push</code> 防递归爆栈，后序深度优先），从入口 <code>module</code> 开始，解析了所有同步 <code>module</code> 并建立了 <code>module</code> 与 <code>chunk</code> 的联系；解析了所有第一层异步(即非嵌套异步模块)的 <code>module</code>，并为每个不同的异步 <code>mudule</code> 都新建了 <code>chunkGroup</code> 和 <code>chunk</code> 并建立了两者的联系。</li><li>然后在 <code>while</code> 对 <code>queueConnect.size</code> 的循环里，更新了 <code>chunkGroupInfoMap</code> 中前一个 <code>ChunkGroup</code> 的信息对象和初始化了新的 <code>ChunkGroup</code> 的信息对象，并获取了最小可用 <code>module</code>。</li><li>同步 <code>module</code> 循环处理结束后，开始处理异步 <code>module</code>，将 <code>queueDelayed</code> 赋给 <code>queue</code>，走外部 <code>while</code> 对 <code>queue.length</code> 的循环。</li><li>处理异步模块的时候，<code>queue</code> 里的 <code>block</code> 为 <code>ImportDependenciesBlock</code> 依赖，然后更新 <code>chunkGroup</code> 后， <code>switch</code> 走 <code>PROCESS_BLOCK</code> 获得本次异步对应的真正模块，后面的处理数据都将在新的 <code>ChunkGroup</code> 信息对象上。就这样循环处理，最终得到一个 <code>Map</code> 结构的 <code>chunkGroupInfoMap</code>。以本 <code>demo</code> 为例，得到:</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...map结构</span></span><br><span class="line">  <span class="number">0</span>:&#123;</span><br><span class="line">    key:Entrypoint, <span class="comment">//groupDebugId:5000</span></span><br><span class="line">    value:&#123;</span><br><span class="line">      availableModulesToBeMerged:<span class="built_in">Array</span>(<span class="number">0</span>)</span><br><span class="line">      children:<span class="function"><span class="title">Set</span>(<span class="params"><span class="number">1</span></span>)</span> &#123;&#125; <span class="comment">//ChunkGroup 5001</span></span><br><span class="line">      chunkGroup:Entrypoint</span><br><span class="line">      minAvailableModules:<span class="built_in">Set</span>(<span class="number">0</span>)</span><br><span class="line">      minAvailableModulesOwned:<span class="literal">true</span></span><br><span class="line">      resultingAvailableModules:<span class="built_in">Set</span>(<span class="number">3</span>)</span><br><span class="line">      skippedItems:<span class="built_in">Array</span>(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">1</span>:&#123;</span><br><span class="line">    key: ChunkGroup, <span class="comment">//groupDebugId:5001</span></span><br><span class="line">    value:&#123;</span><br><span class="line">      availableModulesToBeMerged:<span class="built_in">Array</span>(<span class="number">0</span>)</span><br><span class="line">      children:<span class="function"><span class="title">Set</span>(<span class="params"><span class="number">1</span></span>)</span> &#123;&#125; <span class="comment">//ChunkGroup 5002</span></span><br><span class="line">      chunkGroup:Entrypoint</span><br><span class="line">      minAvailableModules:<span class="built_in">Set</span>(<span class="number">3</span>)</span><br><span class="line">      minAvailableModulesOwned:<span class="literal">true</span></span><br><span class="line">      resultingAvailableModules:<span class="built_in">Set</span>(<span class="number">5</span>)</span><br><span class="line">      skippedItems:<span class="built_in">Array</span>(<span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">2</span>:&#123;</span><br><span class="line">    key: ChunkGroup, <span class="comment">//groupDebugId:5002</span></span><br><span class="line">    value:&#123;</span><br><span class="line">      availableModulesToBeMerged:<span class="built_in">Array</span>(<span class="number">0</span>)</span><br><span class="line">      children:<span class="literal">undefined</span></span><br><span class="line">      chunkGroup:Entrypoint</span><br><span class="line">      minAvailableModules:<span class="built_in">Set</span>(<span class="number">5</span>)</span><br><span class="line">      minAvailableModulesOwned:<span class="literal">true</span></span><br><span class="line">      resultingAvailableModules:<span class="literal">undefined</span></span><br><span class="line">      skippedItems:<span class="built_in">Array</span>(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h3><p>第二阶段主要根据 <code>ImportDependenciesBlock</code> 建立了不同 <code>chunkGroup</code> 之间的父子关系。</p><p>遍历 <code>chunkDependencies</code>，<code>chunkDependencies</code> 是 <code>Map</code> 结构，保存着前一个 <code>ChunkGroup</code> 与新的 <code>ChunkGroup</code> 和 <code>import</code> 依赖之间的映射：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...map结构</span></span><br><span class="line">  <span class="number">0</span>:&#123;</span><br><span class="line">    key:Entrypoint, <span class="comment">//groupDebugId:5000</span></span><br><span class="line">    value:[</span><br><span class="line">      &#123;</span><br><span class="line">        block:ImportDependenciesBlock,</span><br><span class="line">        chunkGroup:ChunkGroup <span class="comment">//groupDebugId:5001</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="number">1</span>:&#123;</span><br><span class="line">    key:ChunkGroup, <span class="comment">//groupDebugId:5001</span></span><br><span class="line">    value:[</span><br><span class="line">      &#123;</span><br><span class="line">        block:ImportDependenciesBlock,</span><br><span class="line">        chunkGroup:ChunkGroup <span class="comment">//groupDebugId:5002</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在判断如果前一个 <code>ChunkGroup</code> 信息对象的可用模块 <code>resultingAvailableModules</code> 包含后一个 <code>ChunkGroup.chunks[]._modules</code>，则分别建立 <code>import</code> 依赖与对应的 <code>ChunkGroup</code>，前一个 <code>chunkGroup</code> 和后一个 <code>chunkGroup</code> 的关系：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GraphHelpers.connectDependenciesBlockAndChunkGroup(depBlock, depChunkGroup); <span class="comment">// ImportDependenciesBlock与chunkGroup建立联系</span></span><br><span class="line"></span><br><span class="line">GraphHelpers.connectChunkGroupParentAndChild(chunkGroup, depChunkGroup); <span class="comment">// chunkGroup之间建立联系：_children和_parents</span></span><br></pre></td></tr></table></figure><h3 id="第三阶段"><a href="#第三阶段" class="headerlink" title="第三阶段"></a>第三阶段</h3><p>第三阶段主要清理了无用 <code>chunk</code> 并清理相关的联系。</p><p>遍历 <code>allCreatedChunkGroups</code>，<code>allCreatedChunkGroups</code> 即为异步被创建的 <code>ChunkGroup</code>，判断 <code>chunkGroup</code> 有没有父的 <code>chunkGroup</code>（<code>_parents</code>）,如果没有执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> chunk <span class="keyword">of</span> chunkGroup.chunks) &#123;</span><br><span class="line">  <span class="keyword">const</span> idx = compilation.chunks.indexOf(chunk);</span><br><span class="line">  <span class="keyword">if</span> (idx &gt;= <span class="number">0</span>) compilation.chunks.splice(idx, <span class="number">1</span>);</span><br><span class="line">  chunk.remove(<span class="string">&#x27;unconnected&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">chunkGroup.remove(<span class="string">&#x27;unconnected&#x27;</span>);</span><br></pre></td></tr></table></figure><p>即解除 <code>module，chunkGroup，chunk</code> 三者之间的联系。</p><p>最终每个 <code>module</code> 与每个 <code>chunk</code>，每个 <code>chunkGroup</code> 和他们之间都建立了联系，优化形成了 <code>chunk Graph</code>。</p><hr><p><code>seal</code> 里继续执行，先将 <code>compilation.modules</code> 按 <code>index</code> 属性大小排序，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hooks.afterChunks.call(<span class="built_in">this</span>.chunks);</span><br></pre></td></tr></table></figure><p>触发插件 <code>WebAssemblyModulesPlugin</code>：设置与 <code>webassembly</code> 相关的报错信息，到此 <code>chunk</code> 生成结束。</p><h2 id="module-chunk-ChunkGroup-区别"><a href="#module-chunk-ChunkGroup-区别" class="headerlink" title="module chunk ChunkGroup 区别"></a>module chunk ChunkGroup 区别</h2><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><p><code>module</code> 即每一个资源文件的模块对应，如 <code>js / css / 图片</code> 等。由 <code>NormalModule</code> 实例化而来，存于 <code>compilation.modules</code>。</p><ul><li><code>module.blocks</code>: 异步模块的依赖</li><li><code>module.dependencies</code> 存同步模块的依赖</li><li><code>module._chunks</code> 保存 <code>module</code> 所属 <code>chunk</code> 列表</li></ul><h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p><code>chunk</code> 即每一个输出文件的对应，包括入口文件，异步加载文件，优化切割后的文件等等，存于 <code>compilation.chunks</code>。</p><ul><li><code>chunk._groups</code>: 保存 <code>chunk</code> 所属 <code>ChunkGroup</code> 列表</li><li><code>chunk._modules</code>: 由哪些 <code>module</code> 组成</li></ul><h3 id="ChunkGroup"><a href="#ChunkGroup" class="headerlink" title="ChunkGroup"></a>ChunkGroup</h3><p><code>ChunkGroup</code> 一般包含一个 <code>chunk</code>（入口 <code>chunk</code> 或异步模块的 <code>chunk</code>）。<code>entrypoint</code> 就是一个 <code>ChunkGroup</code>，里包含入口 <code>chunk</code>。存于 <code>compilation.chunkGroups</code>。</p><ul><li><code>ChunkGroup.chunks</code>: 由哪些 <code>chunk</code> 组成</li><li><code>ChunkGroup._blocks</code>: 保存异步依赖 <code>ImportDependenciesBlock</code></li><li><code>ChunkGroup._children</code>: 保存子 <code>ChunkGroup</code></li><li><code>ChunkGroup._parent</code>: 保存父 <code>ChunkGroup</code></li></ul><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>在 <code>finish</code> 回调中执行的 <code>seal</code> 方法里，包含了海量钩子用于我们侵入 <code>webpack</code> 的封包阶段；</li><li>在遍历入口文件实例化生成 <code>chunk</code> 时，同时实例化了 <code>Entrypoint</code> 等，并建立了入口 <code>module</code> 和 <code>chunk</code>，<code>Entrypoint</code> 之间的联系；</li><li>通过 <code>buildChunkGraph</code> 的三个阶段，让所有的 <code>module、chunk、chunkGroup</code> 之间都建立了联系，形成了 <code>chunk Graph</code>。</li><li>最后触发钩子 <code>afterChunks</code> 标志这 <code>chunk</code> 生成结束。</li></ol>]]></content>
      
      
      <categories>
          
          <category> FE Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（七）：构建 module（下）</title>
      <link href="378.html"/>
      <url>378.html</url>
      
        <content type="html"><![CDATA[<h2 id="通过-ast-分析依赖关系"><a href="#通过-ast-分析依赖关系" class="headerlink" title="通过 ast 分析依赖关系"></a>通过 ast 分析依赖关系</h2><p><code>runLoaders</code> 运行结束后，回调里得到经 <code>loader</code> 编译后的模块代码字符串 <code>result</code> 和对应的 <code>resourceBuffer</code>。</p><p>在回调里执行了 <code>createSource</code> 后，判断 <code>loader</code> 的 <code>result</code> 是否有第三个参数对象并且里面存在 <code>webpackAST</code> 属性，如果有则为 <code>ast</code> 赋值到 <code>_ast</code> 上。<strong>这里作为 webpack 性能优化点：可以直接从 loader 返回 AST，从而避免 parse</strong></p><p>然后回到 <code>this.doBuild</code> 执行回调，在根据项目配置项判断是否需要 <code>parse</code> 后，若需要解析则执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="built_in">this</span>.parser.parse(</span><br><span class="line">  <span class="built_in">this</span>._ast || <span class="built_in">this</span>._source.source(),</span><br><span class="line">  &#123;</span><br><span class="line">    current: <span class="built_in">this</span>,</span><br><span class="line">    <span class="built_in">module</span>: <span class="built_in">this</span>,</span><br><span class="line">    compilation: compilation,</span><br><span class="line">    options: options,</span><br><span class="line">  &#125;,</span><br><span class="line">  (err, result) =&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (result !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="comment">// parse is sync</span></span><br><span class="line">  handleParseResult(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this.parser</code> 即是在 <code>reslove 流程</code> 里的组合对象里得到的 <code>parser</code>。</p><p>在 <code>this.parser.parse</code> 里如果 <code>this._ast</code> 不存在则传 <code>this._source._value</code> 即代码字符串。 然后进入文件 <code>node_modules/webpack/lib/Parser.js</code> 执行 <code>Parser.parse</code>。</p><h3 id="析出-ast"><a href="#析出-ast" class="headerlink" title="析出 ast"></a>析出 ast</h3><p>方法里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ast = Parser.parse(source, &#123;</span><br><span class="line">  sourceType: <span class="built_in">this</span>.sourceType,</span><br><span class="line">  onComment: comments,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>Parser.parse</code> 即为 <code>Parser</code> 静态方法，该方法里主要执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ast = acornParser.parse(code, parserOptions); <span class="comment">//即 acorn.Parser</span></span><br></pre></td></tr></table></figure><p><code>webpack</code> 通过 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Fjb3JuanMvYWNvcm4=">acorn<i class="fa fa-external-link-alt"></i></span> 得到源码字符串对应的 <code>ast</code>。<code>ast</code> 相关资料：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VzdHJlZS9lc3RyZWUvYmxvYi9tYXN0ZXIvZXMyMDE1Lm1k">estree<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzhkM2M0OGYyNjVkYTJkODc2M2JkYWY=">ast 类型查阅<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9hc3RleHBsb3Jlci5uZXQv">在线测试<i class="fa fa-external-link-alt"></i></span></li></ul><h3 id="遍历-ast-收集依赖"><a href="#遍历-ast-收集依赖" class="headerlink" title="遍历 ast 收集依赖"></a>遍历 ast 收集依赖</h3><p>回到 <code>Parser.parse</code> ，对 <code>ast</code> 进行遍历，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.hooks.program.call(ast, comments) === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="built_in">this</span>.detectStrictMode(ast.body);</span><br><span class="line">  <span class="built_in">this</span>.prewalkStatements(ast.body);</span><br><span class="line">  <span class="built_in">this</span>.blockPrewalkStatements(ast.body);</span><br><span class="line">  <span class="built_in">this</span>.walkStatements(ast.body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>this.hooks.program.call(ast, comments)</code></p><p>触发回调 <code>plugin</code>(<code>HarmonyDetectionParserPlugin</code> 和 <code>UseStrictPlugin</code>) 根据是否有 <code>import/export</code> 和 <code>use strict</code> 增加依赖：<code>HarmonyCompatibilityDependency</code>, <code>HarmonyInitDependency</code>，<code>ConstDependency</code></p></li><li><p><code>this.detectStrictMode(ast.body)</code></p><p>检测当前执行块是否有 <code>use strict</code>，并设置 <code>this.scope.isStrict = true</code></p></li><li><p><code>this.prewalkStatements(ast.body)</code></p><ul><li>处理 <code>import</code> 进来的变量，是 <code>import</code> 就增加依赖 <code>HarmonyImportSideEffectDependency</code>，<code>HarmonyImportSpecifierDependency</code>;</li><li>处理 <code>export</code> 出去的变量，是 <code>export</code> 增加依赖 <code>HarmonyExportHeaderDependency</code>，<code>HarmonyExportSpecifierDependency</code></li><li>还会处理其他相关导入导出的变量</li></ul></li><li><p><code>this.blockPrewalkStatements(ast.body)</code></p><p>处理块遍历</p></li><li><p><code>this.walkStatements(ast.body)</code></p><p>用于深入函数内部（方法在 <code>walkFunctionDeclaration</code> 进行递归），然后递归继续查找 <code>ast</code> 上的依赖，异步此处深入会增加依赖 <code>ImportDependenciesBlock</code>;</p></li></ul><p>上述执行结束后，会根据 <code>import/export</code> 的不同情况即模块间的相互依赖关系，在对应的 <code>module.dependencies</code> 上增加相应的依赖。</p><h3 id="各依赖作用解释"><a href="#各依赖作用解释" class="headerlink" title="各依赖作用解释"></a>各依赖作用解释</h3><p>在后面 <code>generate</code> 即 <code>render</code> 阶段，调用这些依赖（<code>Dependency</code>）对应的 <code>template.apply</code> 来渲染生成代码资源。</p><p>以 <code>demo</code> 入口文件 <code>a.js</code> 和 <code>c.js</code> 为例，则依赖为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js module</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;HarmonyCompatibilityDependency&quot;</span>, <span class="comment">//对应模板 `HarmonyExportDependencyTemplate` 会在源码里最前面添加如：`__webpack_require__.r(__webpack_exports__);` 的代码，用于定义 exports:__esModule</span></span><br><span class="line">    <span class="string">&quot;HarmonyInitDependency&quot;</span>, <span class="comment">// 对应模板 `HarmonyInitDependencyTemplate`, 下文单独说明其作用</span></span><br><span class="line">    <span class="string">&quot;ConstDependency&quot;</span>, <span class="comment">// 对应模板 `ConstDependencyTemplate` 操作会在源码里将同步 import 语句删掉</span></span><br><span class="line">    <span class="string">&quot;HarmonyImportSideEffectDependency&quot;</span>, <span class="comment">//对应模板 `HarmonyImportSideEffectDependencyTemplate`，执行 apply 调用父类 HarmonyImportDependencyTemplate 的 apply，即为空。</span></span><br><span class="line">    <span class="string">&quot;HarmonyImportSpecifierDependency&quot;</span> <span class="comment">//对应模板 `HarmonyImportSpecifierDependencyTemplate`，会在源码里将引入的变量替换为 webpack 对应的包装变量</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;blocks&quot;</span>: [<span class="string">&quot;ImportDependenciesBlock&quot;</span>] <span class="comment">//异步模块  对应模板 `ImportDependencyTemplate`， 会在源码里将本 demo 中的 `import(&#x27;./c.js&#x27;)`替换为 `Promise.resolve(/*! import() */).then(__webpack_require__.bind(null, /*! ./c.js */ &quot;./src/c.js&quot;))`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//d.js module</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;HarmonyCompatibilityDependency&quot;</span>,</span><br><span class="line">    <span class="string">&quot;HarmonyInitDependency&quot;</span>,</span><br><span class="line">    <span class="string">&quot;HarmonyExportHeaderDependency&quot;</span>, <span class="comment">// 对应模板 `HarmonyExportDependencyTemplate` 会在源码里将关键字 export 删掉</span></span><br><span class="line">    <span class="string">&quot;HarmonyExportSpecifierDependency&quot;</span> <span class="comment">//对应模板 `HarmonyExportSpecifierDependencyTemplate` 执行 apply 为空</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">&quot;blocks&quot;</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HarmonyInitDependency"><a href="#HarmonyInitDependency" class="headerlink" title="HarmonyInitDependency"></a>HarmonyInitDependency</h4><p>执行其对应 <code>template.apply</code>（文件 <code>HarmonyInitDependency.js</code>）中，先遍历 <code>module.dependencies</code>，判断各依赖对应的 <code>template</code> 是否包含 <code>harmonyInit</code> 和 <code>getHarmonyInitOrder</code> 函数（用于导入的 <code>import</code> 排序），若都存在，则执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> order = template.getHarmonyInitOrder(dependency);</span><br></pre></td></tr></table></figure><p>执行对应的 <code>template.getHarmonyInitOrder</code> 用于获取排序的 <code>order</code>，在不同的依赖里根据需要可能会返回 <code>NaN</code>（如 <code>HarmonyImportSideEffectDependencyTemplate</code> 里判断无副作用（<code>sideEffects</code>）就会返回 <code>NaN</code>），最终筛选出不是 <code>NaN</code> 的依赖组成数组 <code>list</code>，即为含有 <code>import</code> 和 <code>export</code> 的依赖，按 <code>order</code> 排序后，<br>执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> list) &#123;</span><br><span class="line">  item.template.harmonyInit(item.dependency, source, runtime, dependencyTemplates);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行对应的 <code>template.harmonyInit</code> ，对应模板在源码前加入以下代码:</p><ul><li><code>export</code> 相关（<code>HarmonyExportSpecifierDependency</code>）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* harmony export (binding) */</span></span><br><span class="line"></span><br><span class="line">__webpack_require__.d(__webpack_exports__, <span class="string">&#x27;mul&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mul;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>import</code> 相关（<code>HarmonyImportSideEffectDependency</code>，<code>HarmonyImportSpecifierDependency</code>）</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* harmony import */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Src_b__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(<span class="comment">/*! Src/b */</span> <span class="string">&#x27;./src/b.js&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="生成-buildHash"><a href="#生成-buildHash" class="headerlink" title="生成 buildHash"></a>生成 buildHash</h2><p><code>parse</code> 结束后，得到 <code>result</code>， 其中 <code>module、current</code> 的 <code>dependencies</code> 属性里已添加对应的依赖。然后在 <code>handleParseResult</code> 里执行 <code>this._initBuildHash(compilation)</code> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">_initBuildHash</span>(<span class="params">compilation</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> hash = createHash(compilation.outputOptions.hashFunction); <span class="comment">// compilation.outputOptions.hashFunction : md4</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>._source) &#123;</span><br><span class="line">        hash.update(<span class="string">&quot;source&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>._source.updateHash(hash); <span class="comment">// this._value</span></span><br><span class="line">    &#125;</span><br><span class="line">    hash.update(<span class="string">&quot;meta&quot;</span>);</span><br><span class="line">    hash.update(<span class="built_in">JSON</span>.stringify(<span class="built_in">this</span>.buildMeta));</span><br><span class="line">    <span class="built_in">this</span>._buildHash = <span class="comment">/** <span class="doctag">@type <span class="type">&#123;string&#125;</span> </span>*/</span> (hash.digest(<span class="string">&quot;hex&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>webpack</code> 采用 <code>nodejs</code> 提供的加密模块 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2FwaS9jcnlwdG8uaHRtbA==">crypto<i class="fa fa-external-link-alt"></i></span> 进行 <code>hash</code> 加密。</p><ul><li><code>createHash()</code>： 即执行 <code>new BulkUpdateDecorator(require(&quot;crypto&quot;).createHash(algorithm))</code></li><li><code>hash.update()</code>： 更新 <code>hash</code> 内容</li><li><code>hash.digest(&quot;hex&quot;)</code>：得到 <code>hash</code> 值</li></ul><p>先初始化了 <code>hash</code>， 然后分别 <code>update</code> 了 <code>source</code>，<code>this._value</code>（ <code>this._source.updateHash(hash)</code> 获得，为文件源码），<code>meta</code>，<code>this.buildMeta</code>，最后计算出结果挂载到 <code>module._buildHash</code> 上。</p><p>然后回到文件 <code>Compilation.js</code> 的 <code>module.build</code> 的回调。对 <code>error</code> 和 <code>warning</code> 的处理后，对 <code>module.dependencies</code> 按照代码在文件中出现的先后顺序进行排序，然后触发 <code>Compilation.hooks</code>: <code>succeedModule</code>，标志该 <code>module</code> 构建完毕。</p><h2 id="递归解析依赖"><a href="#递归解析依赖" class="headerlink" title="递归解析依赖"></a>递归解析依赖</h2><p>然后执行回调回到 <code>this.buildModule</code> 的回调里执行 <code>afterBuild</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> afterBuild = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (addModuleResult.dependencies) &#123;</span><br><span class="line">    <span class="built_in">this</span>.processModuleDependencies(<span class="built_in">module</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">      callback(<span class="literal">null</span>, <span class="built_in">module</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> callback(<span class="literal">null</span>, <span class="built_in">module</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>即判断如果该模块是首次解析则执行 <code>processModuleDependencies</code>。</p><p>一旦某个模块被解析创建后，在 <code>this.addModule(module)</code>（上文已提到）里会设置 <code>addModuleResult.dependencies</code> 为 <code>false</code> 即可以避免该模块重复解析创建依赖。</p><p>在 <code>processModuleDependencies</code> 里，对 <code>mudule</code> 的 <code>dependencies</code>, <code>blocks</code>（懒加载 <code>import xx</code> 会存入）, <code>variables</code>（内部变量 <code>__resourceQuery</code> ）分别处理，其中对 <code>blocks</code> 的处理会递归调用。整理过滤没有标识 <code>Identifier</code> 的 <code>module</code>（即找出仅有模块依赖关系的依赖），得到 <code>sortedDependencies</code>（以 <code>module a</code> 为例）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sortedDependencies = [</span><br><span class="line">  &#123;</span><br><span class="line">    factory: NormalModuleFactory,</span><br><span class="line">    dependencies: [HarmonyImportSideEffectDependency, HarmonyImportSpecifierDependency],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    factory: NormalModuleFactory,</span><br><span class="line">    dependencies: [ImportDependency],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>然后调用 <code>this.addModuleDependencies</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">addModuleDependencies</span>(<span class="params"><span class="built_in">module</span>, dependencies, bail, cacheGroup, recursive, callback</span>)</span> &#123;</span><br><span class="line"><span class="comment">// dependencies 即为上文中的 sortedDependencies</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  asyncLib.forEach(</span><br><span class="line">      dependencies,</span><br><span class="line">      (item, callback) =&gt; &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">const</span> semaphore = <span class="built_in">this</span>.semaphore;</span><br><span class="line">        semaphore.acquire(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> factory = item.factory;</span><br><span class="line">          factory.create(</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;,<span class="function">(<span class="params">err, dependentModule</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="comment">// 回调内容</span></span><br><span class="line">            &#125;</span><br><span class="line">          );</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      err =&gt; &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> process.nextTick(callback);</span><br><span class="line">      &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <span class="exturl" data-url="aHR0cHM6Ly9jYW9sYW4uZ2l0aHViLmlvL2FzeW5jL3YzL2RvY3MuaHRtbCNlYWNo">asyncLib.forEach<i class="fa fa-external-link-alt"></i></span> <code>forEach</code> 会将回调传给 <code>iterator</code>，在出现 <code>err</code> 或 <code>iterator</code> 全部执行后执行回调。</p><p>批量调用每个依赖的 <code>NormalModuleFactory.create</code>，即与前文<code>moduleFactory.create</code> 功能一致。所以重复开始走 <code>reslove 流程</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NormalModuleFactory.create -&gt; resolve流程 -&gt; 初始化<span class="built_in">module</span> -&gt; <span class="built_in">module</span> build -&gt; afterBuild -&gt; processModuleDependencies ...</span><br></pre></td></tr></table></figure><p>就这样，从入口 <code>module</code> 开始，根据 <code>module</code> 间的依赖关系，递归调用将所有的 <code>module</code> 都转换编译。</p><h2 id="入口-module-生成"><a href="#入口-module-生成" class="headerlink" title="入口 module 生成"></a>入口 module 生成</h2><p>在依赖转换完成后，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> process.nextTick(callback);</span><br></pre></td></tr></table></figure><p>将在 <code>nodejs</code> 下一次事件循环时调用 <code>callback</code> 即执行 <code>this.processModuleDependencies</code> 的回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.processModuleDependencies(<span class="built_in">module</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">  callback(<span class="literal">null</span>, <span class="built_in">module</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此时返回一个入口 <code>module</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;module&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//同步模块</span></span><br><span class="line">    <span class="attr">&quot;dependencies&quot;</span>: [<span class="string">&quot;HarmonyImportSideEffectDependency&quot;</span>, <span class="string">&quot;HarmonyImportSpecifierDependency&quot;</span>],</span><br><span class="line">    <span class="comment">//异步模块</span></span><br><span class="line">    <span class="attr">&quot;blocks&quot;</span>: [<span class="string">&quot;ImportDependenciesBlock&quot;</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>this._addModuleChain</code> 的回调，触发 <code>compilation.hooks</code>:<code>succeedEntry</code>, 标志着 <code>addEntry</code> 方法执行结束。到此入口 <code>mudule</code> 全部生成结束，<code>module</code> 所依赖的其他同步异步 <code>module</code> 将分别保存在 <code>dependencies</code> 与 <code>blocks</code> 里。</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>调用 <code>parser</code> 将前面 <code>runloaders</code> 的编译结果通过 <code>acorn</code> 转换为 <code>ast</code>；</li><li>遍历 <code>ast</code> 根据导入导出及异步的情况触发相关钩子插件收集依赖，这些依赖用于解析递归依赖和模板操作；</li><li>根据每个 <code>module</code> 的相关信息生成各自唯一的 <code>buildHash</code>；</li><li>根据 <code>module</code> 间的相互依赖关系，递归解析所有依赖 <code>module</code>，最终返回一个入口 <code>module</code>，<code>module</code> 所依赖的其他同步异步 <code>module</code> 将分别保存在 <code>dependencies</code> 与 <code>blocks</code> 里。</li></ol>]]></content>
      
      
      <categories>
          
          <category> FE Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（六）：构建 module（上）</title>
      <link href="377.html"/>
      <url>377.html</url>
      
        <content type="html"><![CDATA[<h2 id="初始化-module"><a href="#初始化-module" class="headerlink" title="初始化 module"></a>初始化 module</h2><p>接上文，在 <code>resolver</code> 函数回调里，触发 <code>normalModuleFactory.hooks</code>:<code>afterResolve</code> 之后，回调里执行:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createdModule = <span class="built_in">this</span>.hooks.createModule.call(result); <span class="comment">// result 即为 resolver 返回的组合对象 data</span></span><br><span class="line"><span class="keyword">if</span> (!createdModule) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!result.request) &#123;</span><br><span class="line">    <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Empty dependency (no request)&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createdModule = <span class="keyword">new</span> NormalModule(result);</span><br><span class="line">&#125;</span><br><span class="line">createdModule = <span class="built_in">this</span>.hooks.module.call(createdModule, result);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> callback(<span class="literal">null</span>, createdModule);</span><br></pre></td></tr></table></figure><p>这里触发 <code>normalModuleFactory.hooks</code>:<code>createModule</code>，如果钩子里没有项目配置的自定义 <code>module</code>，则使用 <code>webpack</code> 生成的 <code>module</code>。</p><p>得到 <code>module</code> 实例，接着触发 <code>normalModuleFactory.hooks</code>:<code>module</code> 之后，跳出 <code>factory</code> 函数，执行 <code>factory</code> 函数回调进行依赖缓存后，跳出 <code>create</code> 函数执行 <code>moduleFactory.create</code> 的回调。回调里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addModuleResult = <span class="built_in">this</span>.addModule(<span class="built_in">module</span>); <span class="comment">// 将这个 `module` 保存到全局的 `Compilation.modules` 数组中和 `_modules` 对象中，判断`_modules`是否有该 module 来设置是否已加载的标识</span></span><br><span class="line"><span class="built_in">module</span> = addModuleResult.module;</span><br><span class="line"></span><br><span class="line">onModule(<span class="built_in">module</span>); <span class="comment">// 如果是入口文件还会将 modules 保存到 `Compilation.entries`</span></span><br><span class="line"></span><br><span class="line">dependency.module = <span class="built_in">module</span>;</span><br><span class="line"><span class="built_in">module</span>.addReason(<span class="literal">null</span>, dependency); <span class="comment">// 添加该 `module` 被哪些模块依赖</span></span><br></pre></td></tr></table></figure><p>然后调用 <code>this.buildModule</code> 进入 <code>build</code> 阶段。该方法做了回调缓存后，触发 <code>compilation.hooks</code>:<code>buildModule</code>，然后执行 <code>module.build()</code>。</p><h2 id="构建-module"><a href="#构建-module" class="headerlink" title="构建 module"></a>构建 module</h2><p>在 <code>/node_modules/webpack/lib/NormalModule.js</code> 文件里执行 <code>module.build</code>, 设置一些属性后，直接调用了 <code>this.doBuild</code>。</p><p>该方法里先执行了 <code>this.createLoaderContext</code> 得到<code>loaderContext</code>，为所有的 <code>loader</code> 提供上下文环境并共享，然后调用了 <code>runLoaders</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">runLoaders(</span><br><span class="line">  &#123;</span><br><span class="line">    resource: <span class="built_in">this</span>.resource,</span><br><span class="line">    loaders: <span class="built_in">this</span>.loaders,</span><br><span class="line">    context: loaderContext,</span><br><span class="line">    readResource: fs.readFile.bind(fs),</span><br><span class="line">  &#125;,</span><br><span class="line">  (err, result) =&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="loader-runner"><a href="#loader-runner" class="headerlink" title="loader-runner"></a>loader-runner</h2><p>该方法来自 <code>loader-runner</code>，通过各种 <code>loader</code> 处理源码后，得到一个处理后的 <code>string</code> 或 <code>buffer</code>（可能还有个 <code>sourcemap</code>）。</p><p>还可以解析自定义 <code>loader</code> <span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmRvY3NjaGluYS5vcmcvY29udHJpYnV0ZS93cml0aW5nLWEtbG9hZGVy">编写一个 loader<i class="fa fa-external-link-alt"></i></span>。</p><p>主要流程为：</p><p><code>runLoaders</code> -&gt; <code>iteratePitchingLoaders（按正序 require 每个 loader）</code> -&gt; <code>loadLoader（对应的 loader 导出的函数赋值到 loaderContext.loader[].normal、pitch函数赋值到loaderContext.loader[].pitch，然后执行pitch函数（如果有的话））</code> -&gt; <code>processResource（转换 buffer 和设置 loaderIndex）</code> -&gt; <code>iterateNormalLoaders（倒序执行所有 loader）</code>-&gt; <code>runSyncOrAsync（同步或者异步执行 loader）</code></p><h3 id="pitch-函数"><a href="#pitch-函数" class="headerlink" title="pitch 函数"></a>pitch 函数</h3><ul><li><p>每个 <code>loader</code> 可以挂载一个 <code>pitch</code> 函数，该函数主要是用于利用 <code>module</code> 的 <code>request</code>，来提前做一些拦截处理的工作，并不实际处理 <code>module</code> 内容<span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9hcGkvbG9hZGVycy8jcGl0Y2hpbmctbG9hZGVy">文档<i class="fa fa-external-link-alt"></i></span>。</p></li><li><p>正序 <code>require</code> <code>loader</code> 并执行其 <code>pitch</code> 方法（ <code>loadLoader</code> 里），在执行后的回调里，如果有除了 <code>err</code> 的参数还有其他参数，则执行 <code>iterateNormalLoaders</code> 越过剩下的未 <code>require</code> 的 <code>loader</code> 直接进入到执行 <code>loader</code> 的步骤。如果想没有其他参数，则执行 <code>iteratePitchingLoaders</code> 进行下个 <code>loader</code> 的 <code>require</code>。如代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  loaderContext.loaderIndex--;</span><br><span class="line">  iterateNormalLoaders(options, loaderContext, args, callback);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  iteratePitchingLoaders(options, loaderContext, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>倒序执行每个 <code>loader</code> 的 <code>normal</code> 方法 。</p></li></ul><h3 id="核心代码解析"><a href="#核心代码解析" class="headerlink" title="核心代码解析"></a>核心代码解析</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法按正序 require 每个 loader</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iteratePitchingLoaders</span>(<span class="params">options, loaderContext, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// abort after last loader 读取所有 loader 后，执行 processResource 方法</span></span><br><span class="line">  <span class="keyword">if</span> (loaderContext.loaderIndex &gt;= loaderContext.loaders.length) <span class="keyword">return</span> processResource(options, loaderContext, callback);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> currentLoaderObject = loaderContext.loaders[loaderContext.loaderIndex]; <span class="comment">//选择第一个  loader</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// iterate 增序后递归读取下一个 loader</span></span><br><span class="line">  <span class="keyword">if</span> (currentLoaderObject.pitchExecuted) &#123;</span><br><span class="line">    loaderContext.loaderIndex++;</span><br><span class="line">    <span class="keyword">return</span> iteratePitchingLoaders(options, loaderContext, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// load loader module 加载该 loader 模块</span></span><br><span class="line">  <span class="comment">// 对应的 loader 导出的函数赋值到 loaderContext.loader[].normal</span></span><br><span class="line">  loadLoader(currentLoaderObject, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      loaderContext.cacheable(<span class="literal">false</span>);</span><br><span class="line">      <span class="keyword">return</span> callback(err);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> fn = currentLoaderObject.pitch; <span class="comment">//loadLoader 里会把 module 赋值到 loader.normal, pitch 赋值到 loader.pitch</span></span><br><span class="line">    currentLoaderObject.pitchExecuted = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!fn) <span class="keyword">return</span> iteratePitchingLoaders(options, loaderContext, callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有的话，开始执行 pitch 函数，根据参数情况决定是否继续读取剩下的loader</span></span><br><span class="line">    runSyncOrAsync(fn, loaderContext, [loaderContext.remainingRequest, loaderContext.previousRequest, (currentLoaderObject.data = &#123;&#125;)], <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">      <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        loaderContext.loaderIndex--;</span><br><span class="line">        iterateNormalLoaders(options, loaderContext, args, callback);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        iteratePitchingLoaders(options, loaderContext, callback);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换 buffer 和设置 loaderIndex</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processResource</span>(<span class="params">options, loaderContext, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// set loader index to last loader 获取最后一个 loader 的 index</span></span><br><span class="line">  loaderContext.loaderIndex = loaderContext.loaders.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> resourcePath = loaderContext.resourcePath;</span><br><span class="line">  <span class="keyword">if</span> (resourcePath) &#123;</span><br><span class="line">    loaderContext.addDependency(resourcePath);</span><br><span class="line">    <span class="comment">// 转换为 buffer</span></span><br><span class="line">    options.readResource(resourcePath, <span class="function"><span class="keyword">function</span> (<span class="params">err, buffer</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line">      options.resourceBuffer = buffer; <span class="comment">//得到buffer</span></span><br><span class="line">      iterateNormalLoaders(options, loaderContext, [buffer], callback);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    iterateNormalLoaders(options, loaderContext, [<span class="literal">null</span>], callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//倒序执行所有 loader</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iterateNormalLoaders</span>(<span class="params">options, loaderContext, args, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (loaderContext.loaderIndex &lt; <span class="number">0</span>) <span class="keyword">return</span> callback(<span class="literal">null</span>, args); <span class="comment">//执行完所有 loader 后退出，去执行 iteratePitchingLoaders 回调即 runLoaders 的回调</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> currentLoaderObject = loaderContext.loaders[loaderContext.loaderIndex]; <span class="comment">//获取对应 loader</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// iterate 减序后递归执行下一个 loader</span></span><br><span class="line">  <span class="keyword">if</span> (currentLoaderObject.normalExecuted) &#123;</span><br><span class="line">    loaderContext.loaderIndex--;</span><br><span class="line">    <span class="keyword">return</span> iterateNormalLoaders(options, loaderContext, args, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fn = currentLoaderObject.normal;</span><br><span class="line">  currentLoaderObject.normalExecuted = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">    <span class="keyword">return</span> iterateNormalLoaders(options, loaderContext, args, callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  convertArgs(args, currentLoaderObject.raw);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//执行 loader 函数</span></span><br><span class="line">  runSyncOrAsync(fn, loaderContext, args, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//loader 执行结果的回调</span></span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> callback(err);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>); <span class="comment">// arg:[] 为 loader 转换结果（字符串或者buffer+可能有的sourcemap）</span></span><br><span class="line">    iterateNormalLoaders(options, loaderContext, args, callback); <span class="comment">//递归，并将转换结果一并传入</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步或者异步执行 pitch/loader 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runSyncOrAsync</span>(<span class="params">fn, context, args, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> isSync = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">var</span> isDone = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> isError = <span class="literal">false</span>; <span class="comment">// internal error</span></span><br><span class="line">  <span class="keyword">var</span> reportedError = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">//异步处理</span></span><br><span class="line">  context.async = <span class="function"><span class="keyword">function</span> <span class="title">async</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDone) &#123;</span><br><span class="line">      <span class="keyword">if</span> (reportedError) <span class="keyword">return</span>; <span class="comment">// ignore</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;async(): The callback was already called.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    isSync = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> innerCallback;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 异步后会执行此方法，loader 的结果会作为参数传导出来</span></span><br><span class="line">  <span class="keyword">var</span> innerCallback = (context.callback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isDone) &#123;</span><br><span class="line">      <span class="keyword">if</span> (reportedError) <span class="keyword">return</span>; <span class="comment">// ignore</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;callback(): The callback was already called.&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    isDone = <span class="literal">true</span>;</span><br><span class="line">    isSync = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      callback.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>); <span class="comment">// arguments 为 loader 结果，第一个值为 null 第二个为字符串或者 buffer，第三个为 SourceMap</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result = (<span class="function"><span class="keyword">function</span> <span class="title">LOADER_EXECUTION</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(context, args); <span class="comment">//*** 入口：执行 loader 函数，参数传递前一个 loader 的执行结果  ***</span></span><br><span class="line">    &#125;)();</span><br><span class="line">    <span class="keyword">if</span> (isSync) &#123;</span><br><span class="line">      isDone = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">if</span> (result === <span class="literal">undefined</span>) <span class="keyword">return</span> callback();</span><br><span class="line">      <span class="keyword">if</span> (result &amp;&amp; <span class="keyword">typeof</span> result === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> result.then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result.then(<span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">          callback(<span class="literal">null</span>, r);</span><br><span class="line">        &#125;, callback);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> callback(<span class="literal">null</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>实例化 <code>NormalModule</code> 得到初始化的 <code>module</code>（方法链：<code>moduleFactory.create 回调里-&gt;buildModule-&gt;module.build-&gt;module.doBuild-&gt;runLoaders</code>），然后在 <code>build</code> 过程中先 <code>run loader</code> 处理源码，得到一个编译后的字符串或 <code>buffer</code>。</li><li>在 <code>run loader</code> 的过程中，先正序执行了每个 <code>loader</code> 的 <code>pitch</code> ，然后倒序执行了每个 <code>loader</code> 的 <code>normal</code>。</li></ol>]]></content>
      
      
      <categories>
          
          <category> FE Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（五）：reslove 流程</title>
      <link href="376.html"/>
      <url>376.html</url>
      
        <content type="html"><![CDATA[<h2 id="触发-NormalModuleFactory-hooks-factory-和-resolver"><a href="#触发-NormalModuleFactory-hooks-factory-和-resolver" class="headerlink" title="触发 NormalModuleFactory.hooks:factory 和 resolver"></a>触发 <code>NormalModuleFactory.hooks</code>:<code>factory</code> 和 <code>resolver</code></h2><p>接上文，开始 <code>module</code> 构建前的 <code>reslove</code> 流程。目的是为了获取个 <code>module</code> 的相关信息及各依赖的 <code>loader</code> 的绝对路径。</p><p>来到 <code>NormalModuleFactory.js</code> 文件，该 <code>create</code> 方法先触发了 <code>normalModuleFactory.hooks:beforeResolve</code>，然后在回调里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> factory = <span class="built_in">this</span>.hooks.factory.call(<span class="literal">null</span>);</span><br><span class="line">factory(result, <span class="function">(<span class="params">err, <span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>触发 <code>NormalModuleFactory.hooks:factory</code>，该事件返回了一个 <code>factory</code> 函数。接着执行该 <code>factory</code> 函数:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> resolver = <span class="built_in">this</span>.hooks.resolver.call(<span class="literal">null</span>);</span><br><span class="line">resolver(result, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//... 创建一个 `normalModule` 实例</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>触发 <code>NormalModuleFactory.hooks:resolver</code> 该事件返回了一个 <code>resolver</code> 函数。接着执行 <code>resolver</code> 函数，该函数作用为解析构建所有 <code>module</code> 所需要的 <code>loaders</code> 的绝对路径及这个 <code>module</code> 的相关构建信息(例如获取 <code>module</code> 的 <code>packge.json</code> 等。</p><p>在函数里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderResolver = <span class="built_in">this</span>.getResolver(<span class="string">&#x27;loader&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> normalResolver = <span class="built_in">this</span>.getResolver(<span class="string">&#x27;normal&#x27;</span>, data.resolveOptions);</span><br></pre></td></tr></table></figure><ul><li><code>loaderResolver</code> 为用于解析 <code>loader</code> 的绝对路径</li><li><code>normalResolver</code> 用于解析 <code>文件</code> 和 <code>module</code> 的绝对路径</li></ul><h2 id="getResolver"><a href="#getResolver" class="headerlink" title="getResolver"></a>getResolver</h2><p><code>this.getResolver</code> 会执行 <code>webpack/lib/ResolverFactory.js</code> 里的 <code>this.resolverFactory.get</code>。方法里判断缓存后，执行 <code>_create</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resolveOptions = <span class="built_in">this</span>.hooks.resolveOptions.for(type).call(resolveOptions);</span><br><span class="line"><span class="keyword">const</span> resolver = Factory.createResolver(resolveOptions);</span><br></pre></td></tr></table></figure><p>此时触发的 <code>ResolverFactory.hooks: resolveOptions for (type)</code> 即在 <code>编译前的准备 - 注册 resolverFactory.hooks 阶段</code> 所注册。</p><p>在该钩子里通过 <code>cachedCleverMerge</code> 判断缓存及融合配置（如果是 <code>loaderResolver</code> 则为 <strong>配置项: options.resolveLoader</strong>，如果是 <code>normalResolver</code> 则为 <strong>配置项: options.resolve</strong>），并添加了属性 <code>fileSystem: compiler.inputFileSystem</code>，返回一个 <code>resolveOptions</code> 对象，作为<code>Factory.createResolver</code> 执行的参数。</p><p><code>Factory</code> 为 <code>require(&quot;enhanced-resolve&quot;).ResolverFactory</code>，所以此处进入到<code>enhanced-resolve</code> 包的阶段。</p><h3 id="enhanced-resolve"><a href="#enhanced-resolve" class="headerlink" title="enhanced-resolve"></a>enhanced-resolve</h3><p><code>enhanced-resolve</code> 是 <code>webpack</code> 开发的一个用于解析路径的包。进入文件 <code>node_modules/enhanced-resolve/lib/ResolverFactory.js</code>，先融合处理了项目配置 <code>resolve</code> 与默认配置 <code>resolve/resolveLoader</code>，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!resolver) &#123;</span><br><span class="line">  resolver = <span class="keyword">new</span> Resolver(useSyncFileSystemCalls ? <span class="keyword">new</span> SyncAsyncFileSystemDecorator(fileSystem) : fileSystem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有传入项目的 <code>resolver</code>，那么就自己 <code>new</code> 一个。接着定义了 <code>Resolver</code> 的生命周期钩子和根据配置 <code>push</code> 了一大堆的 <code>plugins</code>，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins.forEach(<span class="function">(<span class="params">plugin</span>) =&gt;</span> &#123;</span><br><span class="line">  plugin.apply(resolver);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对每一个插件执行 <code>apply</code>，主要作用是获取到 <code>hooks</code> 后，在 <code>Resolver</code> 的不同生命周期钩子上注册了一些事件，然后在事件末尾执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取hooks</span></span><br><span class="line"><span class="keyword">const</span> target = resolver.ensureHook(<span class="built_in">this</span>.target);</span><br><span class="line"><span class="comment">// 触发插件后的回调里，执行：</span></span><br><span class="line"> resolver.doResolve(target, obj, ...);</span><br></pre></td></tr></table></figure><p><code>target</code> 为事件钩子 <code>hook</code>，在触发完当前插件后，最后通过 <code>doResolve</code> 将 <code>hook</code> 带入到下一个插件中，实现了递归串联调用一系列的插件。包括：<code>UnsafeCachePlugin，ParsePlugin，DescriptionFilePlugin，NextPlugin，AliasPlugin，AliasFieldPlugin，ModuleKindPlugin，SymlinkPlugin</code> 等等，完成各自的插件操作。</p><p>注册事件完成后，最后得到返回 <code>resolver</code> 对象回到 <code>_create</code> 触发 <code>ResolverFactory.hooks: resolver for (type)</code>，此处可以对 <code>resolver</code> 进行篡改。然后返回对应的 <code>resolver</code> 回到 <code>NormalModuleFactory.hooks</code>: <code>resolver</code> 的钩子函数里继续执行。</p><p><code>resolver</code> 对象暴露 <code>resolve</code> 方法，用于解析路径。</p><h2 id="解析-inline-loader-和-resource"><a href="#解析-inline-loader-和-resource" class="headerlink" title="解析 inline loader 和 resource"></a>解析 inline loader 和 resource</h2><p>继续执行，先进行 <code>inline loader</code> 和对应资源文件 <code>resource</code> 的解析:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> elements = requestWithoutMatchResource.replace(<span class="regexp">/^-?!+/</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="regexp">/!!+/g</span>, <span class="string">&#x27;!&#x27;</span>).split(<span class="string">&#x27;!&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> resource = elements.pop();</span><br><span class="line">elements = elements.map(identToLoaderRequest);</span><br></pre></td></tr></table></figure><p>如<code>&#39;import Styles from style-loader!css-loader?modules!./styles.css&#39;</code>，会得到：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;resource&quot;</span>: <span class="string">&quot;./styles.css&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;elements&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;loader&quot;</span>: <span class="string">&quot;style-loader&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;loader&quot;</span>: <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;options&quot;</span>: <span class="string">&quot;modules&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">asyncLib.parallel(</span><br><span class="line">  [</span><br><span class="line">    callback =&gt; <span class="built_in">this</span>.resolveRequestArray(contextInfo, context, elements, loaderResolver, callback), <span class="comment">// 解析`elements`(`inline loader`)</span></span><br><span class="line">    callback =&gt; &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      normalResolver.resolve(contextInfo, context, resource, &#123;&#125;, <span class="function">(<span class="params">err, resource, resourceResolveData</span>) =&gt;</span> &#123;...&#125;); <span class="comment">// //解析对应的 `module` 的绝对路径等信息</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  (err, results) =&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>asyncLib</code> 来自 <code>neo-async</code> 包<span class="exturl" data-url="aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvbmVvLWFzeW5j">npm<i class="fa fa-external-link-alt"></i></span>， <code>asyncLib.parallel</code> <span class="exturl" data-url="aHR0cDovL3N1Z3VydTAzLmdpdGh1Yi5pby9uZW8tYXN5bmMvZG9jL2FzeW5jLnBhcmFsbGVsLmh0bWw=">API 文档<i class="fa fa-external-link-alt"></i></span> 会并行处理参数数组各任务，任务都完成之后，返回一个 <code>results</code> 列表，列表顺序为参数数组顺序，与执行顺序无关。</p><p><code>this.resolveRequestArray</code> 内部采用 <code>asyncLib.map</code> 循环调用 <code>resolver.resolve</code>。</p><p>得到 <code>results</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;results&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;loader&quot;</span>: <span class="string">&quot;loader的绝对路径1&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;options&quot;</span>: <span class="string">&quot;loader参数1&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">&quot;loader&quot;</span>: <span class="string">&quot;loader的绝对路径2&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;options&quot;</span>: <span class="string">&quot;loader参数2&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;resource&quot;</span>: <span class="string">&quot;模块绝对路径&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;resourceResolveData&quot;</span>: <span class="string">&quot;模块基本信息（即enhanced-resolve执行结果）&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解析配置文件里的-loader"><a href="#解析配置文件里的-loader" class="headerlink" title="解析配置文件里的 loader"></a>解析配置文件里的 loader</h2><p>在回调里执行:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="built_in">this</span>.ruleSet.exec(&#123;</span><br><span class="line">  resource: resourcePath,</span><br><span class="line">  realResource: matchResource !== <span class="literal">undefined</span> ? resource.replace(<span class="regexp">/\?.*/</span>, <span class="string">&#x27;&#x27;</span>) : resourcePath,</span><br><span class="line">  resourceQuery, <span class="comment">// module 路径上所带的 query 参数</span></span><br><span class="line">  issuer: contextInfo.issuer, <span class="comment">// 所解析的 module 的发布者</span></span><br><span class="line">  compiler: contextInfo.compiler,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>exec</code>（上一章已经介绍过）过滤 <code>webpack.config.js</code> 中得到 <code>module</code> 所需要的 <code>loader</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;result&quot;</span>: [</span><br><span class="line">    &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;type&quot;</span>, <span class="attr">&quot;value&quot;</span>: <span class="string">&quot;javascript/auto&quot;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;resolve&quot;</span>, <span class="attr">&quot;value&quot;</span>: &#123;&#125; &#125;,</span><br><span class="line">    &#123; <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;use&quot;</span>, <span class="attr">&quot;value&quot;</span>: &#123; <span class="attr">&quot;loader&quot;</span>: <span class="string">&quot;babel-loader&quot;</span> &#125; &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并，排序-loader"><a href="#合并，排序-loader" class="headerlink" title="合并，排序 loader"></a>合并，排序 loader</h2><p>接着处理了 <code>inline loader</code> 如果带有前缀<code>!</code>,<code>!!</code>,<code>-!</code>（注意，这部分的 <code>API</code> 在中文文档上没有写，要在官方原版文档里才有<span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25jZXB0cy9sb2FkZXJzLyNpbmxpbmU=">链接<i class="fa fa-external-link-alt"></i></span>）和 <code>result</code> 项带有 <code>enforce</code> 参数的情况，用来对 <code>loader</code>的禁用和排序。</p><p>最后得到 <code>useLoadersPost</code>, <code>useLoadersPre</code>, <code>useLoaders</code>, <code>settings:&#123;type: &quot;javascript/auto&quot;, resolve: &#123;&#125;&#125;</code>，并通过 <code>asyncLib.parallel</code> 与 <code>this.resolveRequestArray</code> 并行处理 <code>useLoadersPost</code>, <code>useLoadersPre</code>, <code>useLoaders</code> 得到对应的 <code>resolve</code> 结果即路径信息，在回调里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (matchResource === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  loaders = results[<span class="number">0</span>].concat(loaders, results[<span class="number">1</span>], results[<span class="number">2</span>]); <span class="comment">//参数 loaders 为inline loader</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  loaders = results[<span class="number">0</span>].concat(results[<span class="number">1</span>], loaders, results[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>排序、合并 <code>loader</code>，即 <code>loaders</code> 顺序为 <code>postLoader，inlineLoader，loader（normal config loader），preLoader</code>。因为 <code>loader</code> 是从右至左执行，即执行顺序为 <code>preLoader，loader（normal config loader），inlineLoader，postLoader</code>。</p><h2 id="得到-data"><a href="#得到-data" class="headerlink" title="得到 data"></a>得到 data</h2><p>最后通过 <code>process.nextTick</code>（微任务）异步输出以下组合对象:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">callback(<span class="literal">null</span>, &#123;</span><br><span class="line">  context: context,</span><br><span class="line">  request: loaders.map(loaderToIdent).concat([resource]).join(<span class="string">&#x27;!&#x27;</span>),</span><br><span class="line">  dependencies: data.dependencies,</span><br><span class="line">  userRequest,</span><br><span class="line">  rawRequest: request,</span><br><span class="line">  loaders,</span><br><span class="line">  resource,</span><br><span class="line">  matchResource,</span><br><span class="line">  resourceResolveData,</span><br><span class="line">  settings,</span><br><span class="line">  type,</span><br><span class="line">  parser: <span class="built_in">this</span>.getParser(type, settings.parser),</span><br><span class="line">  generator: <span class="built_in">this</span>.getGenerator(type, settings.generator),</span><br><span class="line">  resolveOptions,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其中：</p><h3 id="getParser"><a href="#getParser" class="headerlink" title="getParser"></a>getParser</h3><p>主要作用是为该 <code>module</code> 提供 <code>parser</code>，用于解析模块为 <code>ast</code>。</p><p><code>this.getParser(type, settings.parser)</code> 创建 <code>parser</code> 并缓存。</p><p>执行 <code>createParser</code>，方法里触发 <code>NormalModuleFactory.hooks:createParser for (type)</code>，该事件注册在 <code>JavascriptModulesPlugin</code> 插件，根据 <code>type</code> 不同返回不同的 <code>parser</code> 实例。</p><p>实例化之后，触发 <code>NormalModuleFactory.hooks:parser for (type)</code>，会去注册一些在 <code>parser</code> 阶段（遍历解析 <code>ast</code> 的时候）被触发的 <code>hooks</code>。</p><h3 id="getGenerator"><a href="#getGenerator" class="headerlink" title="getGenerator"></a>getGenerator</h3><p>主要作用是为该 <code>module</code> 提供 <code>generator</code>，用于模版生成时提供方法。</p><p>与 <code>parser</code> 类似，<code>this.getGenerator(type, settings.generator)</code> 创建 <code>generator</code> 并缓存。</p><p>执行 <code>createGenerator</code>，方法里触发 <code>NormalModuleFactory.hooks:createGenerator for (type)</code>,该事件注册在 <code>JavascriptModulesPlugin</code> 插件，根据 <code>type</code> 不同返回不同的 <code>generator</code> 实例（目前代码里都是返的一致的 <code>new JavascriptGenerator()</code> ）。</p><p>实例化之后，触发 <code>NormalModuleFactory.hooks:generator for (type)</code>。</p><p>得到这个组合对象 <code>data</code> 后，跳出 <code>resolver</code> 函数，执行 <code>resolver</code> 函数回调，到此 <code>resolve</code> 流程结束，开启创建 <code>module</code> 流程！</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li><code>resolve</code> 流程用于获得各 <code>loader</code> 和模块的绝对路径等信息。</li><li>在 <code>resolver</code> 里，先通过 <code>enhanced-resolve</code> 获取 <code>resolver</code>，提供 <code>resolve</code> 方法。</li><li>解析 <code>inline loader</code> 和 <code>resource</code> 和项目配置的 <code>loader</code>，然后根据配置对其进行合并，排序。</li><li>调用 <code>getParser</code> 和 <code>getGenerator</code> 得到 <code>module</code> 对应的 <code>parser</code> 和 <code>generator</code>，用于后面的 <code>ast</code> 解析及模板生成。</li><li>最后输出一个组合对象 <code>data</code>， 该对象为创建 <code>module</code> 提供各种必备的环境条件。</li></ol>]]></content>
      
      
      <categories>
          
          <category> FE Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（四）：reslove 前的准备</title>
      <link href="375.html"/>
      <url>375.html</url>
      
        <content type="html"><![CDATA[<h2 id="compiler-run"><a href="#compiler-run" class="headerlink" title="compiler.run"></a>compiler.run</h2><p><code>compiler.run</code>是整个编译过程启动的入口，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hooks.beforeRun.callAsync(<span class="built_in">this</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="built_in">this</span>.hooks.run.callAsync(<span class="built_in">this</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// recordsInputPath是webpack配置中指定的读取上一组records的文件路径</span></span><br><span class="line">    <span class="built_in">this</span>.readRecords(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">      <span class="built_in">this</span>.compile(onCompiled);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在方法中先触发 <code>compiler.hooks</code>: <code>beforeRun</code>，执行之前注册的 <code>NodeEnvironmentPlugin</code>（该插件此时判断 <code>inputFileSystem</code> 是否被配置，如未配置则执行 <code>purge</code> 清理方法），然后在回调里触发 <code>compiler.hooks</code>: <code>run</code>，然后回调里 <code>this.readRecords</code> 是用于读取之前的 <code>records</code> 的方法，再在它的回调里执行 <code>this.compile(onCompiled)</code>。</p><p><code>onCompiled</code> 在 <code>compile</code> 过程后调用，主要用于输出构建资源。</p><h2 id="compiler-compile"><a href="#compiler-compile" class="headerlink" title="compiler.compile"></a>compiler.compile</h2><p><code>compile</code> 是真正进行编译的过程，最终会把所有原始资源编译为目标资源。实例化了一个 <code>compilation</code>，并将 <code>compilation</code> 传给 <code>make</code> 钩子上的方法，注册在这些钩子上的方法会调用 <code>compilation</code> 上的 <code>addEntry</code>，执行构建。</p><h3 id="获取-compilation-所需-params"><a href="#获取-compilation-所需-params" class="headerlink" title="获取 compilation 所需 params"></a>获取 compilation 所需 params</h3><p><code>this.compile</code> 先执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> params = <span class="built_in">this</span>.newCompilationParams();</span><br></pre></td></tr></table></figure><p>即：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">newCompilationParams</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> params = &#123;</span><br><span class="line">        normalModuleFactory: <span class="built_in">this</span>.createNormalModuleFactory(),</span><br><span class="line">        contextModuleFactory: <span class="built_in">this</span>.createContextModuleFactory(),</span><br><span class="line">        compilationDependencies: <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法先实例化了 <code>NormalModuleFactory</code> 类和 <code>ContextModuleFactory</code> 类，两个类均扩展于 <code>tapable</code>。<code>ContextModuleFactory</code> 类除了兼容老版本之外的代码，没有什么特别需要注意的。接下来具体说明 <code>NormalModuleFactory</code>。</p><h3 id="实例化-NormalModuleFactory"><a href="#实例化-NormalModuleFactory" class="headerlink" title="实例化 NormalModuleFactory"></a>实例化 NormalModuleFactory</h3><p><code>NormalModuleFactory</code> 类用于创建一个 <code>normalModule</code> 实例。</p><h4 id="实例化-RuleSet"><a href="#实例化-RuleSet" class="headerlink" title="实例化 RuleSet"></a>实例化 RuleSet</h4><p>在实例化 <code>NormalModuleFactory</code> 执行 <code>constructor</code> 的过程中，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.ruleSet = <span class="keyword">new</span> RuleSet(options.defaultRules.concat(options.rules));</span><br></pre></td></tr></table></figure><ul><li><code>options.defaultRules</code> 是在之前文件 <code>WebpackOptionsDefaulter.js</code> 中被初始化，然后与项目配置的 <code>module.rules</code> 合并；</li><li>每个<span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmRvY3NjaGluYS5vcmcvY29uZmlndXJhdGlvbi9tb2R1bGUvI3J1bGU=">规则<i class="fa fa-external-link-alt"></i></span>可以分为三部分 - 条件 <code>condition</code> (如 <code>test, include, exclude</code>)，结果 <code>result</code> (如应用的 <code>loader，parse</code> 选项) 和嵌套规则 <code>nested rule</code>（如 <code>rules</code>）；</li><li><span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmRvY3NjaGluYS5vcmcvY29uZmlndXJhdGlvbi9tb2R1bGUvIyVFNiU5RCVBMSVFNCVCQiVCNg==">条件<i class="fa fa-external-link-alt"></i></span>可接受 正则表达式，字符串，函数等。</li><li><code>new RuleSet</code> 实例化过程中，会对每一项 <code>rule</code> 进行进行处理，递归调用静态方法 <code>normalizeCondition</code> 处理 <code>condition</code> 相关，最终每一个 <code>condition</code> 都处理为一个 <code>newRule.resource</code> 函数；递归调用 <code>normalizeUse</code> 处理 <code>result</code> 相关，最终每一个 <code>result</code> 都处理为一个 <code>use</code> 数组，数组的每一项包含 <code>loader</code> 和 <code>options</code>；</li><li>调用 <code>ruleSet</code> 的实例 <code>exec</code> 时，传入目标路径和相关信息后，在内部 <code>_run</code> 里，进行递归过滤匹配出对应的 <code>loader</code>，最终得到 <code>result</code> 数组，数组每一项包含 <code>type，value（loader 和 options）</code> 等；</li></ul><h4 id="注册-normalModuleFactory-hooks-factory"><a href="#注册-normalModuleFactory-hooks-factory" class="headerlink" title="注册 normalModuleFactory.hooks:factory"></a>注册 <code>normalModuleFactory.hooks</code>:<code>factory</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hooks.factory.tap(<span class="string">&#x27;NormalModuleFactory&#x27;</span>, <span class="function">() =&gt;</span> <span class="function">(<span class="params">result, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> resolver = <span class="built_in">this</span>.hooks.resolver.call(<span class="literal">null</span>);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  resolver(result, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此时注册了 <code>normalModuleFactory.hooks</code>:<code>factory</code>，当后面触发该 <code>hooks</code> 时，该回调返回一个函数。函数内的运行须先触发 <code>normalModuleFactory.hooks</code>:<code>resolver</code>，然后执行其回调结果。</p><h4 id="注册-normalModuleFactory-hooks-resolver"><a href="#注册-normalModuleFactory-hooks-resolver" class="headerlink" title="注册 normalModuleFactory.hooks:resolver"></a>注册 <code>normalModuleFactory.hooks</code>:<code>resolver</code></h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.hooks.resolver.tap(<span class="string">&#x27;NormalModuleFactory&#x27;</span>, <span class="function">() =&gt;</span> <span class="function">(<span class="params">data, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此时注册了 <code>normalModuleFactory.hooks</code>:<code>resolver</code>，跟<code>normalModuleFactory.hooks</code>:<code>factory</code> 相同，当后面触发该 <code>hooks</code> 时，该回调返回一个函数。</p><p>在这两个类实例化完成后，分别触发 <code>compiler.hooks</code>: <code>normalModuleFactory</code> ，<code>contextModuleFactory</code>。</p><h3 id="实例化-compilation"><a href="#实例化-compilation" class="headerlink" title="实例化 compilation"></a>实例化 compilation</h3><p><code>this.compile</code> 继续执行,先后触发 <code>compiler.hooks</code>: <code>beforeCompile</code>，<code>compile</code>, 这两个钩子都会传入上文 <code>params</code> 作为参数，可用于修改 <code>normalModuleFactory，contextModuleFactory</code> 等。然后在回调中执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compilation = <span class="built_in">this</span>.newCompilation(params);</span><br></pre></td></tr></table></figure><p>该方法实例化了一个 <code>Compilation</code>，也是扩展于 <code>tapable</code>。<strong>一个 <code>compilation</code> 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息，代表了一次资源的构建</strong>。</p><p>在实例化的过程中，除了初始化一些自身资源属性，并实例化了 <code>MainTemplate</code>, <code>ChunkTemplate</code>, <code>HotUpdateChunkTemplate</code>, <code>RuntimeTemplate</code>, <code>ModuleTemplate</code>。用于提供不同的编译模板。</p><p>回到 <code>compiler.js</code>，在添加了一些属性后，触发<code>compiler.hooks</code> : <code>thisCompilation</code>, <code>compilation</code>。回忆在 <code>编译前的准备 - 注册plugins阶段 - WebpackOptionsApply.js</code> 的文件里注册了大量该 <code>hooks</code> 的事件，在此时拿到 <code>compilation</code> 对象后，开始执行这一系列事件。</p><ul><li><code>compiler.hooks</code>:<code>thisCompilation</code> 会在 <code>compilation</code> 对象的 <code>hooks</code> 里注册一些新的事件；</li><li><code>compiler.hooks</code>:<code>compilation</code> 会在 <code>compilation</code>、<code>normalModuleFactory</code> 对象的 <code>hooks</code> 里注册一些新的事件，同时还会往 <code>compilation.dependencyFactories</code>（工厂类），<code>compilation.dependencyTemplates</code>（模板类） 增加依赖模块。</li></ul><blockquote><p>为什么这里需要 <code>thisCompilation，compilation</code> 两个钩子？原因是跟子编译器有关。在 <code>Compiler</code> 的 <code>createChildCompiler</code> 方法里创建子编译器，其中 <code>thisCompilation</code> 钩子不会被复制，而 <code>compilation</code> 会被复制。<br>子编译器拥有完整的 <code>module</code> 和 <code>chunk</code> 生成，通过子编译器可以独立于父编译器执行一个核心构建流程，额外生成一些需要的 <code>module</code> 和 <code>chunk</code>。</p></blockquote><h2 id="开始构建"><a href="#开始构建" class="headerlink" title="开始构建"></a>开始构建</h2><p><code>this.compile</code> 继续执行，触发 <code>compiler.hooks</code> : <code>make</code> ,执行之前在 <code>SingleEntryPlugin | MultiEntryPlugin</code> 注册的的 <code>make</code> 事件，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compilation.addEntry(context, dep, name, callback); <span class="comment">//其中 dep 为 SingleEntryDependency 实例</span></span><br></pre></td></tr></table></figure><h3 id="compilation-addEntry"><a href="#compilation-addEntry" class="headerlink" title="compilation.addEntry"></a>compilation.addEntry</h3><p>来到 <code>Compilation.js</code> 文件，<code>addEntry</code> 触发了 <code>compilation.hooks</code>:<code>addEntry</code> 后，定义了入口对象 <code>_preparedEntrypoints</code>，然后直接执行了 <code>this._addModuleChain</code>。</p><p>在该方法里，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">const</span> Dep = <span class="comment">/** <span class="doctag">@type <span class="type">&#123;DepConstructor&#125;</span> </span>*/</span> (dependency.constructor);</span><br><span class="line"><span class="keyword">const</span> moduleFactory = <span class="built_in">this</span>.dependencyFactories.get(Dep);</span><br></pre></td></tr></table></figure><p>因 <code>dependency = SingleEntryPlugin.createDependency(entry, name)</code> 即 <code>new SingleEntryDependency(entry)</code>，则 <code>Dep</code> 则为 <code>SingleEntryDependency</code> 类，而在之前 <code>compiler.hooks:compilation</code> 的注册事件中添加了依赖： <code>compilation.dependencyFactories.set(SingleEntryDependency, normalModuleFactory)</code>，所以 <code>moduleFactory</code> 为 <code>normalModuleFactory</code>。</p><h3 id="开始创建-module"><a href="#开始创建-module" class="headerlink" title="开始创建 module"></a>开始创建 module</h3><h4 id="编译队列控制：semaphore-acquire"><a href="#编译队列控制：semaphore-acquire" class="headerlink" title="编译队列控制：semaphore.acquire"></a>编译队列控制：semaphore.acquire</h4><p>执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.semaphore.acquire(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  moduleFactory.create(</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    (err, <span class="built_in">module</span>) =&gt; &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>this.semaphore</code> 这个类是一个编译队列控制，原理很简单，对执行进行了并发控制，默认并发数为 <code>100</code>，超过后存入 <code>semaphore.waiters</code>，根据情况再调用 <code>semaphore.release</code> 去执行存入的事件 <code>semaphore.waiters</code>。</p><h4 id="moduleFactory-create"><a href="#moduleFactory-create" class="headerlink" title="moduleFactory.create"></a>moduleFactory.create</h4><p><code>this.semaphore.acquire</code> 里执行了 <code>moduleFactory.create</code>。（<strong>注：递归解析依赖的重复也从此处开始</strong>）</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>从编译过程启动的入口 <code>compiler.run</code> 开始，触发了一系列的生命周期钩子后，执行 <code>compiler.compile</code>。</li><li>获取 <code>compilation</code> 所需 <code>params</code>，实例化 <code>NormalModuleFactory</code> 类（插件会去注册其钩子） 及 <code>ContextModuleFactory</code> 类，在实例化 <code>NormalModuleFactory</code> 的过程中，会实例化 <code>RuleSet</code> 及注册钩子 <code>factory</code> 和 <code>resolver</code>。</li><li>实例化 <code>Compilation</code>，传入 <code>params</code> 参数，触发之前在注册 <code>plugin</code> 阶段所注册的 <code>NormalModuleFactory</code> 下的 <code>hooks</code>。</li><li>触发 <code>make</code> 钩子执行 <code>compilation.addEntry-&gt;_addModuleChain</code>，通过编译队列控制 <code>semaphore.acquire</code> 执行 <code>moduleFactory.create</code> 开始创建 <code>module</code>，而递归解析依赖的重复点亦从 <code>create</code> 开始。</li></ol>]]></content>
      
      
      <categories>
          
          <category> FE Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（三）：编译前的准备</title>
      <link href="374.html"/>
      <url>374.html</url>
      
        <content type="html"><![CDATA[<h2 id="Compiler-简述"><a href="#Compiler-简述" class="headerlink" title="Compiler 简述"></a>Compiler 简述</h2><ul><li><code>webpack/lib/Compiler.js</code> 该文件是 <code>webpack</code> 的核心, <code>Compiler</code> 类定义了整个构建的流程;</li><li><code>new Compiler</code> 执行 <code>constructor</code>，首先扩展了 <code>Tapable</code>，在 <code>constructor</code> 里定义了一堆钩子 <code>done,beforeRun,run,emit</code> 等等;</li><li>然后注册了<code>this._pluginCompat.tap(&quot;Compiler&quot;)</code>，这个用来兼容之前的老版 <code>webpack</code> 的 <code>plugin</code> 的钩子，触发时机在<code>tapable/lib/Tapable.js</code>里调用<code>plugin</code> 的时候;</li><li>该 <code>Compiler</code> 类下的的 <code>run</code> 即为整个打包的主流程函数；</li></ul><h2 id="封装-FS"><a href="#封装-FS" class="headerlink" title="封装 FS"></a>封装 FS</h2><p>继续执行 <code>webpack.js</code>，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> NodeEnvironmentPlugin(&#123;</span><br><span class="line">  infrastructureLogging: options.infrastructureLogging,</span><br><span class="line">&#125;).apply(compiler);</span><br></pre></td></tr></table></figure><p>该类主要对文件系统做了一些封装，包括<code>输入，输出，缓存，监听</code>等等，这些扩展后的方法全部挂载在 <code>compiler</code> 对象下。</p><h2 id="执行-plugins"><a href="#执行-plugins" class="headerlink" title="执行 plugins"></a>执行 plugins</h2><h3 id="项目配置的-plugins"><a href="#项目配置的-plugins" class="headerlink" title="项目配置的 plugins"></a>项目配置的 plugins</h3><p>然后对自己 <code>config</code> 文件里的 <code>plugins</code> 进行了注册：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (options.plugins &amp;&amp; <span class="built_in">Array</span>.isArray(options.plugins)) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> plugin <span class="keyword">of</span> options.plugins) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      plugin.call(compiler, compiler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      plugin.apply(compiler);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，会把 <code>compiler</code> 实例传进去供 <code>plugin</code> 使用，<code>compiler</code> 包含整个构建流程的全部钩子，通过它可以把控整个 <code>webpack</code> 构建周期。其中 <code>compiler</code> 的部分钩子会传入 <code>compilation</code> 对象参数，该对象又包含资源构建的很多钩子。</p><p>掌握流程里各对象（如 <code>compiler</code>，<code>compilation</code>）的事件钩子触发的时机，就是掌握如何写一个插件的关键。<span class="exturl" data-url="aHR0cHM6Ly93ZWJwYWNrLmRvY3NjaGluYS5vcmcvY29udHJpYnV0ZS93cml0aW5nLWEtcGx1Z2luLw==">如何写一个 webpack 插件？<i class="fa fa-external-link-alt"></i></span></p><p>接着触发了 <code>compiler</code> 的 <code>hooks</code>: <code>environment，afterEnvironment</code>，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compiler.options = <span class="keyword">new</span> WebpackOptionsApply().process(options, compiler);</span><br></pre></td></tr></table></figure><h3 id="项目默认的-plugins"><a href="#项目默认的-plugins" class="headerlink" title="项目默认的 plugins"></a>项目默认的 plugins</h3><p>该 <code>WebpackOptionsApply</code> 类的 <code>process</code> 除了把配置里的一些属性添加到 <code>compiler</code> 对象下，更主要的是根据 <code>options</code> 的配置不同，注册激活一些默认自带的插件和 <code>resolverFactory.hooks</code>，大部分插件的作用是往 <code>compiler.hooks:compilation,thisCompilation</code> 里注册一些事件（此时该钩子已经获取到 <code>normalModuleFactory</code> 等参数），如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> JavascriptModulesPlugin().apply(compiler); <span class="comment">//给normalModuleFactory的js模块提供Parser、JavascriptGenerator对象 ，并给seal阶段的template提供renderManifest数组（包含render方法）</span></span><br><span class="line"><span class="keyword">new</span> JsonModulesPlugin().apply(compiler); <span class="comment">//给normalModuleFactory的json模块提供Parser、JavascriptGenerator对象</span></span><br><span class="line"><span class="keyword">new</span> WebAssemblyModulesPlugin(&#123;</span><br><span class="line">  mangleImports: options.optimization.mangleWasmImports,</span><br><span class="line">&#125;).apply(compiler); <span class="comment">// 同理，webassembly模块</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> EntryOptionPlugin().apply(compiler);</span><br><span class="line">compiler.hooks.entryOption.call(options.context, options.entry); <span class="comment">//创建多入口还是单入口 SingleEntryPlugin | MultiEntryPlugin，两者均会在 apply 方法里注册 Compiler.hooks:compilation, make</span></span><br></pre></td></tr></table></figure><p>插件处理完毕后，触发 <code>compiler.hooks</code>: <code>afterPlugins</code>。</p><h2 id="注册-resolverFactory-hooks"><a href="#注册-resolverFactory-hooks" class="headerlink" title="注册 resolverFactory.hooks"></a>注册 resolverFactory.hooks</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">compiler.resolverFactory.hooks.resolveOptions.for(<span class="string">&#x27;normal&#x27;</span>).tap(<span class="string">&#x27;WebpackOptionsApply&#x27;</span>, <span class="function">(<span class="params">resolveOptions</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(</span><br><span class="line">    &#123;</span><br><span class="line">      fileSystem: compiler.inputFileSystem,</span><br><span class="line">    &#125;,</span><br><span class="line">    cachedCleverMerge(options.resolve, resolveOptions) <span class="comment">//配置项 options.resolve</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line">compiler.resolverFactory.hooks.resolveOptions.for(<span class="string">&#x27;context&#x27;</span>).tap(<span class="string">&#x27;WebpackOptionsApply&#x27;</span>, <span class="function">(<span class="params">resolveOptions</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(</span><br><span class="line">    &#123;</span><br><span class="line">      fileSystem: compiler.inputFileSystem,</span><br><span class="line">      resolveToContext: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    cachedCleverMerge(options.resolve, resolveOptions) <span class="comment">//配置项 options.resolve</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line">compiler.resolverFactory.hooks.resolveOptions.for(<span class="string">&#x27;loader&#x27;</span>).tap(<span class="string">&#x27;WebpackOptionsApply&#x27;</span>, <span class="function">(<span class="params">resolveOptions</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(</span><br><span class="line">    &#123;</span><br><span class="line">      fileSystem: compiler.inputFileSystem,</span><br><span class="line">    &#125;,</span><br><span class="line">    cachedCleverMerge(options.resolveLoader, resolveOptions) <span class="comment">//配置项 options.resolveLoader</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后注册 <code>compiler.resolverFactory.hooks</code>: <code>resolveOptions for (normal/context/loader)</code>，目的是为 <code>Factory.createResolver</code> 提供默认的参数对象（含有相关的 <code>resolve</code> 项目配置项）。</p><p>注册完成后，触发 <code>compiler.hooks</code>: <code>afterResolvers</code>，到此 <code>compiler</code> 初始化完毕。</p><h2 id="回到-cli-js"><a href="#回到-cli-js" class="headerlink" title="回到 cli.js"></a>回到 cli.js</h2><p>回到<code>cli.js</code>，处理配置项 <code>progress</code> 和 <code>infoVerbosity</code>，然后判断 <code>options</code> 里是否有 <code>watch</code>，有则走 <code>compiler.watch</code>，无则走 <code>compiler.run</code>，这里我们走<code>compiler.run</code>，进入 <code>webpack</code> 核心构建流程！</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li>实例化了 <code>Compiler</code>，它扩展于<code>Tapable</code>，是 <code>webapck</code> 的核心；</li><li>封装了输入输出等方法 <code>FS</code> ，然后执行了 <code>plugins</code>（<code>compiler</code> 作为参数），包括项目配置的和项目默认；</li><li>注册 <code>resolverFactory.hooks</code> 用于 <code>Factory.createResolver</code> 方法提供参数对象；</li><li>最后根据配置是否有 <code>watch</code> 来决定程序走向。</li></ol>]]></content>
      
      
      <categories>
          
          <category> FE Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（二）：配置初始化</title>
      <link href="373.html"/>
      <url>373.html</url>
      
        <content type="html"><![CDATA[<p>通过在 <code>cli</code> 执行命令 <code>webpack</code> 开始，以 <code>development</code> 模式为例，暂时忽略支线剧情（错误响应，缓存等等），只分析探索 <code>webpack</code> 的打包主流程。</p><h2 id="选择-cli"><a href="#选择-cli" class="headerlink" title="选择 cli"></a>选择 cli</h2><p>根据 <code>npm</code> 的<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm5wbWpzLmNvbS9maWxlcy9wYWNrYWdlLmpzb24jYmlu">规则<i class="fa fa-external-link-alt"></i></span>，<code>cli</code> 执行 <code>webpack</code> 后，就会去执行 <code>node_modules/.bin/webpack</code> 文件即 <code>node_modules/webpack/bin/webpack.js</code>。所以这里我们的 <code>npm scripts</code> 中的 <code>debug</code> 直接调试的 <code>node_modules/.bin/webpack</code> 的代码。 代码中通过:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.resolve(packageName);</span><br></pre></td></tr></table></figure><p>判断是否安装了包 <code>webpack-cli</code> 或者 <code>webpack-command</code>，通过安装的数量处理后，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(path.resolve(path.dirname(pkgPath), pkg.bin[installedClis[<span class="number">0</span>].binName]));</span><br></pre></td></tr></table></figure><p>即执行 <code>node_modules/webpack-cli/bin/cli.js</code>，</p><h2 id="webpack-cli"><a href="#webpack-cli" class="headerlink" title="webpack-cli"></a>webpack-cli</h2><p>该文件为一个自执行函数，<code>import-local</code> 包用于优先选用本地包，<code>v8-compile-cache</code> 包用于 <code>v8</code> <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZseXlhbmcvYmxvZy9pc3N1ZXMvMTM=">缓存优化<i class="fa fa-external-link-alt"></i></span>。</p><h3 id="配置-yargs"><a href="#配置-yargs" class="headerlink" title="配置 yargs"></a>配置 yargs</h3><p>接下来配置了 <code>yargs</code>的帮助等信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&quot;./config/config-yargs&quot;</span>)(yargs)；</span><br></pre></td></tr></table></figure><p>在文件 <code>node_modules/webpack-cli/bin/config/config-yargs.js</code> 里可以查阅具体的配置内容。</p><p>然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yargs.parse(process.argv.slice(<span class="number">2</span>), <span class="function">(<span class="params">err, argv, output</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 <code>yargs.parse</code> 的回调里执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options = <span class="built_in">require</span>(<span class="string">&#x27;./utils/convert-argv&#x27;</span>)(argv);</span><br></pre></td></tr></table></figure><h2 id="合并-cli-参数与项目配置参数"><a href="#合并-cli-参数与项目配置参数" class="headerlink" title="合并 cli 参数与项目配置参数"></a>合并 cli 参数与项目配置参数</h2><p>进入 <code>convert-argv.js</code>， 主要做了对 <code>cli</code> 所传的参数与项目配置进行融合，并处理部分参数，最终得到一个 <code>options</code>。</p><p>先处理了部分特定参数后（可能会有多个项目配置），然后通过一系列（<code>findup</code>,<code>interpret</code>）的处理，得到配置文件的路径值: <code>/nice/wpDemo/webpack.config.js</code>。然后读取 <code>webpack.config.js</code> 这个文件后，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processConfiguredOptions(options[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>方法里先对 <code>options</code> 的类型进行了验证：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">validateOptions(options);</span><br></pre></td></tr></table></figure><p>验证无误后，对项目配置文件进行了一系列的判断，包括是否是多数组，函数等等。最后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processOptions(options);</span><br></pre></td></tr></table></figure><p>在该方法里，通过 <code>ifArg</code> 对融合了 <code>cli</code> 参数配置和项目配置（<code>cli</code> 参数优先级更高），包括 <code>mode</code>，<code>entry</code> 等等，然后跳出 <code>processOptions</code> 继续执行，根据 <code>cli</code> 参数有没有 <code>watch</code> 相关而做一些处理。</p><h2 id="统计数据-stats-配置"><a href="#统计数据-stats-配置" class="headerlink" title="统计数据 stats 配置"></a>统计数据 stats 配置</h2><p><code>processOptions</code> 执行完后，回到 <code>cli.js</code> 文件执行同名方法 <code>processOptions</code> ，传入了融合了后的配置 <code>options</code>，然后对配置中的统计信息（<code>options.stats</code>）进行了处理。</p><h2 id="webpack-js"><a href="#webpack-js" class="headerlink" title="webpack.js"></a>webpack.js</h2><p>最后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">&#x27;webpack&#x27;</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  compiler = webpack(options);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里引入了<code>webpack</code>（<code>node_modules/webpack/lib/webpack.js</code>）, <code>webpack</code> 挂载了很多内置的插件，如 <code>BannerPlugin</code> 等等, 然后执行 <code>webpack</code>。</p><p>先通过 <code>ajv</code> 验证配置的每一项是否合法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpackOptionsValidationErrors = validateSchema(webpackOptionsSchema, options);</span><br></pre></td></tr></table></figure><p>然后判断如果 <code>options</code> 是数组则执行多个<code>webpack(options)</code>，然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options = <span class="keyword">new</span> WebpackOptionsDefaulter().process(options);</span><br></pre></td></tr></table></figure><h2 id="与合项目默认参数合并"><a href="#与合项目默认参数合并" class="headerlink" title="与合项目默认参数合并"></a>与合项目默认参数合并</h2><p>该方法在文件 <code>WebpackOptionsDefaulter.js</code> 里，初始化默认的 <code>config</code> 配置后，然后通过 <code>WebpackOptionsDefaulter</code> 的原始类 <code>OptionsDefaulter</code> 上的 <code>process</code> 方法 <code>merge</code> 了项目配置。然后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compiler = <span class="keyword">new</span> Compiler(options.context); <span class="comment">// options.context为当前项目绝对路径</span></span><br></pre></td></tr></table></figure><p><code>options</code> 是系统默认的配置、cli 配置、配置文件配置三种融合的结果，此时<code>项目配置</code>与<code>默认配置</code>都已处理完毕，进入编译前的准备。</p><h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><ol><li><code>webpack</code> 先选择了 <code>cli</code> 后，配置了 <code>yargs</code> 相关信息；</li><li>通过 <code>yarg</code> 解析了 <code>cli</code> 相关参数后，与读取到的配置文件的配置相融合；</li><li>统计数据 <code>stats</code> 配置后，执行方法 <code>webpack</code>，融合了项目配置与默认配置，最终得到 <code>options</code> 挂载到变量 <code>compiler</code> 下。</li></ol>]]></content>
      
      
      <categories>
          
          <category> FE Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack 4 源码主流程分析（一）：前言及总流程概览</title>
      <link href="372.html"/>
      <url>372.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>此系列文章作为笔记，用于记录分析 <code>webpack</code> 源码主流程的过程。</p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>根据 <code>webpack</code> 构建流程及相关，本系列文章一共分为以下章节：</p><ol><li>配置初始化</li><li>编译前的准备</li><li>reslove 前的准备</li><li>reslove 流程</li><li>构建 module（上）</li><li>构建 module（下）</li><li>生成 chunk</li><li>优化 chunk</li><li>资源的构建</li><li>文件的生成</li><li>打包后文件解析</li><li>watch</li><li>webpack 优化</li></ol><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><p><code>webpack</code> 构建流程图：</p><p><img data-src="http://cdn.flqin.com/p372-1.jpeg" alt="webpack 构建流程"></p><h2 id="本系列代码环境"><a href="#本系列代码环境" class="headerlink" title="本系列代码环境"></a>本系列代码环境</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;devDependencies&quot;: &#123;</span><br><span class="line">  &quot;@babel/core&quot;: &quot;^7.7.5&quot;,</span><br><span class="line">  &quot;@babel/preset-env&quot;: &quot;^7.7.6&quot;,</span><br><span class="line">  &quot;@fe_korey/test-loader&quot;: &quot;^1.0.0&quot;,</span><br><span class="line">  &quot;babel-loader&quot;: &quot;^8.0.6&quot;,</span><br><span class="line">  &quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">  &quot;webpack&quot;: &quot;^4.41.2&quot;,</span><br><span class="line">  &quot;webpack-cli&quot;: &quot;^3.3.10&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>版本不同，源码略微有差异。</p><p>本项目 <code>demo</code> 开源在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3poYW9reS93ZWJwYWNrLWRlbW8=">github<i class="fa fa-external-link-alt"></i></span>，欢迎交流学习。</p><h2 id="分析源码前的一系列准备工作"><a href="#分析源码前的一系列准备工作" class="headerlink" title="分析源码前的一系列准备工作"></a>分析源码前的一系列准备工作</h2><p>采用 <span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20v">vscode<i class="fa fa-external-link-alt"></i></span> 来打断点调试分析。</p><h3 id="配置-vscode"><a href="#配置-vscode" class="headerlink" title="配置 vscode"></a>配置 vscode</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//launch.json</span></span><br><span class="line">  &quot;configurations&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Launch Program&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;runtimeExecutable&quot;</span>: <span class="string">&quot;npm&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;runtimeArgs&quot;</span>: [<span class="string">&quot;run&quot;</span>, <span class="string">&quot;debug&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;port&quot;</span>: <span class="number">5858</span>,</span><br><span class="line">      <span class="attr">&quot;console&quot;</span>: <span class="string">&quot;externalTerminal&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;skipFiles&quot;</span>: [<span class="string">&quot;&lt;node_internals&gt;/**/*.js&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20vZG9jcy9ub2RlanMvbm9kZWpzLWRlYnVnZ2luZw==">这些配置是怎么来的？<i class="fa fa-external-link-alt"></i></span></p><h3 id="配置-npm-script"><a href="#配置-npm-script" class="headerlink" title="配置 npm script"></a>配置 npm script</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;debug&quot;: &quot;node --inspect-brk=5858 ./node_modules/.bin/webpack&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="了解-webpack-的插件架构"><a href="#了解-webpack-的插件架构" class="headerlink" title="了解 webpack 的插件架构"></a>了解 webpack 的插件架构</h3><p><code>webpack</code> 从配置初始化到打包完成定义了一个生命周期，在这个生命周期中的每一个阶段定义一些不同的功能。<code>webpack</code> 的流程同样也是一个事件驱动的架构，利用插件系统 <code>tapable</code>，通过 <code>发布订阅事件</code> 来实现所有内部的，外部扩展的功能。</p><h3 id="了解-webpack-的核心模块"><a href="#了解-webpack-的核心模块" class="headerlink" title="了解 webpack 的核心模块"></a>了解 webpack 的核心模块</h3><p><code>webpack</code> 的构建是通过 <code>Compiler</code> 控制构建流程，<code>Compilation</code> 解析，<code>ModuleFactory</code> 生成模块，<code>Parser</code> 解析源码，<code>Template</code> 渲染代码，最后输出打包后的文件。</p><h3 id="了解-tapable"><a href="#了解-tapable" class="headerlink" title="了解 tapable"></a>了解 tapable</h3><p><code>tapable</code> 本质就是一个事件发布订阅机制，支持同步异步，使用<code>xxx.tap</code>之类的来<strong>事件订阅</strong>，使用<code>xxx.call</code>之类的来进行<strong>事件发布</strong>。<br>相关文档查阅：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2svdGFwYWJsZQ==">git 仓库<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdHVnZW5odWEwNzA3L3AvMTEzMTc1NTcuaHRtbA==">用法解析<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzEyMDQ2YWYyNjVkYTYxMmIxMzc3YWE=">源码分析<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9jMmE1NDU3YzFjOTU=">伪代码实现<i class="fa fa-external-link-alt"></i></span></li></ul><h3 id="demo-准备"><a href="#demo-准备" class="headerlink" title="demo 准备"></a>demo 准备</h3><h4 id="npm-安装"><a href="#npm-安装" class="headerlink" title="npm 安装"></a>npm 安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i webpack-cli webpack</span><br><span class="line">npm i @babel/core @babel/preset-env babel-loader -D</span><br><span class="line">npm i @fe_korey/test-loader -D</span><br></pre></td></tr></table></figure><h4 id="demo-文件"><a href="#demo-文件" class="headerlink" title="demo 文件"></a>demo 文件</h4><p>我们以 <code>development</code> 模式为例，暂时忽略支线剧情，只分析探索 <code>webpack</code> 的打包主流程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">&#x27;Src/b&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./c.js&#x27;</span>).then(<span class="function">(<span class="params">m</span>) =&gt;</span> m.sub(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">add(<span class="number">3</span>, <span class="number">2</span> + a);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/b.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; mul &#125; <span class="keyword">from</span> <span class="string">&#x27;@fe_korey/test-loader?number=20!Src/e&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + mul(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">addddd</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/c.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; mul &#125; <span class="keyword">from</span> <span class="string">&#x27;Src/d&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span>(<span class="string">&#x27;./b.js&#x27;</span>).then(<span class="function">(<span class="params">m</span>) =&gt;</span> m.add(<span class="number">200</span>, <span class="number">100</span>));</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sub</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b + mul(<span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//src/d.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> d = <span class="number">10000</span>;</span><br><span class="line">  <span class="keyword">return</span> a * b + d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    bundle: <span class="string">&#x27;./src/a.js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="string">&#x27;/dist&#x27;</span>,</span><br><span class="line">    filename: <span class="string">&#x27;[name].[chunkhash:4].js&#x27;</span>,</span><br><span class="line">    chunkFilename: <span class="string">&#x27;[name].[chunkhash:8].js&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  mode: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      Src: path.resolve(__dirname, <span class="string">&#x27;src/&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//babel.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [<span class="string">&#x27;@babel/env&#x27;</span>],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="一颗坚定且耐操的心"><a href="#一颗坚定且耐操的心" class="headerlink" title="一颗坚定且耐操的心"></a>一颗坚定且耐操的心</h3><p>为什么要阅读它？</p><ul><li>因为可以让我们更好的理解海量配置，知道每一个配置在打包的具体哪个环节</li><li>在对构建流程进行优化时能更清楚的根据过程思考优化点</li><li>还可以学习下在这种大型项目里，如何实现稳定的架构和良好的扩展性</li><li>对自定义开发一些 <code>plugin</code> 和 <code>loader</code> 有更深刻的理解</li><li>了解它的一些代码设计方式能给我们的日常搬砖带来一些新的启发</li></ul><p>最重要的还是想满足自己的好奇欲，想知道在这犀利的打包背后，到底是怎么实现的。</p><p><code>webpack</code> 里包含数不清的变量和钩子，海量插件，这些足以让你怀疑人生，请务必保持一颗耐操的心。 一切准备就绪后，进入 <code>vscode</code> 的调试模式！</p>]]></content>
      
      
      <categories>
          
          <category> FE Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>proxy适用场景</title>
      <link href="371.html"/>
      <url>371.html</url>
      
        <content type="html"><![CDATA[<p><code>proxy</code> 在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。<span class="exturl" data-url="aHR0cDovL2VzNi5ydWFueWlmZW5nLmNvbS8jZG9jcy9wcm94eQ==">文档查阅<i class="fa fa-external-link-alt"></i></span></p><p><code>Proxy</code> 是一种代理模式，常用于三个方面：</p><ul><li>拦截和监视外部对对象的访问</li><li>降低函数或类的复杂度</li><li>在复杂操作前对操作进行校验或对所需资源进行管理</li></ul><p>正因为此，可以做一些<code>中间件</code>相关的事情。</p><h2 id="抽离校验模块"><a href="#抽离校验模块" class="headerlink" title="抽离校验模块"></a>抽离校验模块</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  pickyMethodOne: <span class="function"><span class="keyword">function</span> (<span class="params">obj, str, num</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  pickyMethodTwo: <span class="function"><span class="keyword">function</span> (<span class="params">num, obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> argTypes = &#123;</span><br><span class="line">  pickyMethodOne: [<span class="string">&#x27;object&#x27;</span>, <span class="string">&#x27;string&#x27;</span>, <span class="string">&#x27;number&#x27;</span>],</span><br><span class="line">  pickyMethodTwo: [<span class="string">&#x27;number&#x27;</span>, <span class="string">&#x27;object&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, proxy</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = target[key];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> checkArgs = argChecker(key, args, argTypes[key]);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(value, target, args);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">argChecker</span>(<span class="params">name, args, checkers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> idx = <span class="number">0</span>; idx &lt; args.length; idx++) &#123;</span><br><span class="line">    <span class="keyword">var</span> arg = args[idx];</span><br><span class="line">    <span class="keyword">var</span> type = checkers[idx];</span><br><span class="line">    <span class="keyword">if</span> (!arg || <span class="keyword">typeof</span> arg !== type) &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">`You are incorrectly implementing the signature of <span class="subst">$&#123;name&#125;</span>. Check param <span class="subst">$&#123;idx + <span class="number">1</span>&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.pickyMethodOne();</span><br><span class="line">obj.pickyMethodTwo(<span class="string">&#x27;wopdopadoo&#x27;</span>, &#123;&#125;);</span><br><span class="line">obj.pickyMethodOne(&#123;&#125;, <span class="string">&#x27;a little string&#x27;</span>, <span class="number">123</span>);</span><br><span class="line">obj.pickyMethodOne(<span class="number">123</span>, &#123;&#125;);</span><br></pre></td></tr></table></figure><h2 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> api = &#123;</span><br><span class="line">  _apiKey: <span class="string">&#x27;123abc456def&#x27;</span>,</span><br><span class="line">  getUsers: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  getUser: <span class="function"><span class="keyword">function</span> (<span class="params">userId</span>) </span>&#123;&#125;,</span><br><span class="line">  setUser: <span class="function"><span class="keyword">function</span> (<span class="params">userId, config</span>) </span>&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> RESTRICTED = [<span class="string">&#x27;_apiKey&#x27;</span>];</span><br><span class="line">api = <span class="keyword">new</span> <span class="built_in">Proxy</span>(api, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, key, proxy</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (RESTRICTED.indexOf(key) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> is restricted. Please see api documentation for further info.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, proxy);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, key, value, proxy</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (RESTRICTED.indexOf(key) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span> is restricted. Please see api documentation for further info.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, value, proxy);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 以下操作都会抛出错误</span></span><br><span class="line"><span class="built_in">console</span>.log(api._apiKey);</span><br><span class="line">api._apiKey = <span class="string">&#x27;987654321&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> api = &#123;</span><br><span class="line">  _apiKey: <span class="string">&#x27;123abc456def&#x27;</span>,</span><br><span class="line">  getUsers: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  getUser: <span class="function"><span class="keyword">function</span> (<span class="params">userId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">  setUser: <span class="function"><span class="keyword">function</span> (<span class="params">userId, config</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logMethodAsync</span>(<span class="params">timestamp, method</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;timestamp&#125;</span> - Logging <span class="subst">$&#123;method&#125;</span> request asynchronously.`</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">api = <span class="keyword">new</span> <span class="built_in">Proxy</span>(api, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, proxy</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = target[key];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...<span class="built_in">arguments</span></span>) </span>&#123;</span><br><span class="line">      logMethodAsync(<span class="keyword">new</span> <span class="built_in">Date</span>(), key);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(value, target, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">api.getUsers();</span><br></pre></td></tr></table></figure><h2 id="预警和拦截"><a href="#预警和拦截" class="headerlink" title="预警和拦截"></a>预警和拦截</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataStore = &#123;</span><br><span class="line">  noDelete: <span class="number">1235</span>,</span><br><span class="line">  oldMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">  &#125;,</span><br><span class="line">  doNotChange: <span class="string">&#x27;tried and true&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> NODELETE = [<span class="string">&#x27;noDelete&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> NOCHANGE = [<span class="string">&#x27;doNotChange&#x27;</span>];</span><br><span class="line"><span class="keyword">const</span> DEPRECATED = [<span class="string">&#x27;oldMethod&#x27;</span>];</span><br><span class="line">dataStore = <span class="keyword">new</span> <span class="built_in">Proxy</span>(dataStore, &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">target, key, value, proxy</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (NOCHANGE.includes(key)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`Error! <span class="subst">$&#123;key&#125;</span> is immutable.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, proxy);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">deleteProperty</span>(<span class="params">target, key</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (NODELETE.includes(key)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`Error! <span class="subst">$&#123;key&#125;</span> cannot be deleted.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(target, key);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, key, proxy</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEPRECATED.includes(key)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.warn(<span class="string">`Warning! <span class="subst">$&#123;key&#125;</span> is deprecated.`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> val = target[key];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">      ? <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">Reflect</span>.apply(target[key], target, args);</span><br><span class="line">        &#125;</span><br><span class="line">      : val;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// these will throw errors or log warnings, respectively</span></span><br><span class="line">dataStore.doNotChange = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="keyword">delete</span> dataStore.noDelete;</span><br><span class="line">dataStore.oldMethod();</span><br></pre></td></tr></table></figure><h2 id="过滤操作"><a href="#过滤操作" class="headerlink" title="过滤操作"></a>过滤操作</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  getGiantFile: <span class="function"><span class="keyword">function</span> (<span class="params">fileId</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, key, proxy</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> id = args[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">let</span> isEnroute = checkEnroute(id);</span><br><span class="line">      <span class="keyword">let</span> isDownloading = checkStatus(id);</span><br><span class="line">      <span class="keyword">let</span> cached = getCached(id);</span><br><span class="line">      <span class="keyword">if</span> (isEnroute || isDownloading) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cached) &#123;</span><br><span class="line">        <span class="keyword">return</span> cached;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.apply(target[key], target, args);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="中断代理"><a href="#中断代理" class="headerlink" title="中断代理"></a>中断代理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  username: <span class="string">&#x27;korey&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; proxy, revoke &#125; = <span class="built_in">Proxy</span>.revocable(data, &#123;&#125;);</span><br><span class="line"><span class="comment">// logs &#x27;devbryce&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.username);</span><br><span class="line">revoke();</span><br><span class="line"><span class="comment">// TypeError: Revoked</span></span><br><span class="line"><span class="built_in">console</span>.log(proxy.username);</span><br></pre></td></tr></table></figure><h2 id="解决对象属性为-undefined-的问题"><a href="#解决对象属性为-undefined-的问题" class="headerlink" title="解决对象属性为 undefined 的问题"></a>解决对象属性为 undefined 的问题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> handlers = &#123;</span><br><span class="line">    get: <span class="function">(<span class="params">target, property</span>) =&gt;</span> &#123;</span><br><span class="line">      target[property] = property <span class="keyword">in</span> target ? target[property] : &#123;&#125;;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> target[property] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(target[property], handlers);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> target[property];</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handlers);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;z&#x27;</span> <span class="keyword">in</span> proxy.x.y); <span class="comment">// false (其实这一步已经针对`target`创建了一个x.y的属性)</span></span><br><span class="line">  proxy.x.y.z = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;z&#x27;</span> <span class="keyword">in</span> proxy.x.y); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">console</span>.log(target.x.y.z); <span class="comment">// hello</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="普通函数与构造函数的兼容处理"><a href="#普通函数与构造函数的兼容处理" class="headerlink" title="普通函数与构造函数的兼容处理"></a>普通函数与构造函数的兼容处理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">a, b</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;constructor&#x27;</span>, a, b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test(1, 2) // throw an error</span></span><br><span class="line"><span class="keyword">let</span> proxyClass = <span class="keyword">new</span> <span class="built_in">Proxy</span>(Test, &#123;</span><br><span class="line">  <span class="function"><span class="title">apply</span>(<span class="params">target, thisArg, argumentsList</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果想要禁止使用非new的方式来调用函数，直接抛出异常即可</span></span><br><span class="line">    <span class="comment">// throw new Error(`Function $&#123;target.name&#125; cannot be invoked without &#x27;new&#x27;`)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> (target.bind(thisArg, ...argumentsList))();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxyClass(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// constructor 1 2</span></span><br></pre></td></tr></table></figure><h2 id="包装-fetch"><a href="#包装-fetch" class="headerlink" title="包装 fetch"></a>包装 fetch</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> handlers = &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params">target, property</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!target.init) &#123;</span><br><span class="line">      <span class="comment">// 初始化对象</span></span><br><span class="line">      [<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;POST&#x27;</span>].forEach(<span class="function">(<span class="params">method</span>) =&gt;</span> &#123;</span><br><span class="line">        target[method] = <span class="function">(<span class="params">url, params = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> fetch(url, &#123;</span><br><span class="line">            headers: &#123;</span><br><span class="line">              <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            mode: <span class="string">&#x27;cors&#x27;</span>,</span><br><span class="line">            credentials: <span class="string">&#x27;same-origin&#x27;</span>,</span><br><span class="line">            method,</span><br><span class="line">            ...params,</span><br><span class="line">          &#125;).then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json());</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target[property];</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> API = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handlers);</span><br></pre></td></tr></table></figure><h2 id="断言工具"><a href="#断言工具" class="headerlink" title="断言工具"></a>断言工具</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> assert = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="title">set</span>(<span class="params">target, message, value</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!value) <span class="built_in">console</span>.error(message);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">assert[<span class="string">&quot;Isn&#x27;t true&quot;</span>] = <span class="literal">false</span>; <span class="comment">// Error: Isn&#x27;t true</span></span><br><span class="line">assert[<span class="string">&#x27;Less than 18&#x27;</span>] = <span class="number">18</span> &gt;= <span class="number">19</span>; <span class="comment">// Error: Less than 18</span></span><br></pre></td></tr></table></figure><h2 id="统计函数调用次数"><a href="#统计函数调用次数" class="headerlink" title="统计函数调用次数"></a>统计函数调用次数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">orginFunction</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> proxyFunction = <span class="keyword">new</span> <span class="built_in">Proxy</span>(orginFunction, &#123;</span><br><span class="line">  apply (target, thisArg. argumentsList) &#123;</span><br><span class="line">    log(XXX)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> target.apply(thisArg, argumentsList)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="实现双绑比-Object-defineProperty-的优势"><a href="#实现双绑比-Object-defineProperty-的优势" class="headerlink" title="实现双绑比 Object.defineProperty 的优势"></a>实现双绑比 Object.defineProperty 的优势</h2><ul><li>可以直接监听对象而非属性</li><li>可以直接监听数组的变化</li><li>有多达 13 种拦截方法,不限于 <code>apply、ownKeys、deleteProperty、has</code> 等等</li></ul>]]></content>
      
      
      <categories>
          
          <category> FE Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）了解 HTML5 中的 MutationObserver</title>
      <link href="370.html"/>
      <url>370.html</url>
      
        <content type="html"><![CDATA[<p><code>MutationObserver</code> 翻译过来就是变动观察器，字面上就可以理解这是用来观察 <code>Node</code>（节点）变化的。<code>MutationObserver</code> 是在 <code>DOM4</code> 规范中定义的，它的前身是 <code>MutationEvent</code> 事件，该事件最初在 <code>DOM2</code> 事件规范中介绍，到来了 <code>DOM3</code> 事件规范中正式定义，但是由于该事件存在兼容性以及性能上的问题被弃用。<span class="exturl" data-url="aHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPU11dGF0aW9uT2JzZXJ2ZXI=">兼容性查阅<i class="fa fa-external-link-alt"></i></span></p><p><code>MutationObserver</code> 是一个构造器，接受一个 <code>callback</code> 参数，用来处理节点变化的回调函数。返回两个参数:</p><ul><li><code>mutations</code>：节点变化记录列表（<code>sequence&lt;MutationRecord&gt;</code>）</li><li><code>observer</code>：构造 <code>MutationObserver 对象</code>。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observe = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span> (<span class="params">mutations, observer</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p><code>MutationObserver</code> 对象有三个方法，分别如下：</p><ul><li><code>observe</code>：设置观察目标，接受两个参数: (<code>target</code>：观察目标，<code>options</code>：通过对象成员来设置观察选项)</li><li><code>disconnect</code>：阻止观察者观察任何改变</li><li><code>takeRecords</code>：清空记录队列并返回里面的内容</li></ul><p>关于 <code>observe</code> 方法中 <code>options</code> 参数有已下几个选项：</p><ul><li><code>childList</code>：设置 <code>true</code>，表示观察目标子节点的变化，比如添加或者删除目标子节点，不包括修改子节点以及子节点后代的变化</li><li><code>attributes</code>：设置 <code>true</code>，表示观察目标属性的改变</li><li><code>characterData</code>：设置 <code>true</code>，表示观察目标数据的改变</li><li><code>subtree</code>：设置为 <code>true</code>，目标以及目标的后代改变都会观察</li><li><code>attributeOldValue</code>：如果属性为 <code>true</code> 或者省略，则相当于设置为 <code>true</code>，表示需要记录改变前的目标属性值，设置了 <code>attributeOldValue</code> 可以省略 <code>attributes</code> 设置</li><li><code>characterDataOldValue</code>：如果 <code>characterData</code> 为 <code>true</code> 或省略，则相当于设置为 <code>true</code>,表示需要记录改变之前的目标数据，设置了 <code>characterDataOldValue</code> 可以省略 <code>characterData</code> 设置</li><li><code>attributeFilter</code>：如果不是所有的属性改变都需要被观察，并且 <code>attributes</code> 设置为 <code>true</code> 或者被忽略，那么设置一个需要观察的属性本地名称（不需要命名空间）的列表</li></ul><p>下表描述了 <code>MutationObserver</code> 选项与 <code>MutationEvent</code> 名称之间的对应关系：</p><table><thead><tr><th>MutationEvent</th><th>MutationObserver options</th></tr></thead><tbody><tr><td>DOMNodeInserted</td><td>{ childList: true, subtree: true }</td></tr><tr><td>DOMNodeRemoved</td><td>{ childList: true, subtree: true }</td></tr><tr><td>DOMSubtreeModified</td><td>{ childList: true, subtree: true }</td></tr><tr><td>DOMAttrModified</td><td>{ attributes: true, subtree: true }</td></tr><tr><td>DOMCharacterDataModified</td><td>{ characterData: true, subtree: true }</td></tr></tbody></table><p>从上表我们也可以看出相比与 <code>MutationEvent</code> 而言 <code>MutationObserver</code> 极大地增加了灵活性，可以设置各种各样的选项来满足程序员对目标的观察。</p><p>我们简单看几个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">&quot;target&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;block&quot;</span> name=<span class="string">&quot;target&quot;</span>&gt;</span><br><span class="line">  target的第一个子节点</span><br><span class="line">  &lt;p&gt;</span><br><span class="line">    &lt;span&gt;target的后代&lt;/span&gt;</span><br><span class="line">  &lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>1.callback 的回调次数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> target = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;target&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> observe = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span> (<span class="params">mutations, observe</span>) </span>&#123;</span><br><span class="line">  i++;</span><br><span class="line">&#125;);</span><br><span class="line">observe.observe(target, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">target.appendChild(docuemnt.createTextNode(<span class="string">&#x27;1&#x27;</span>));</span><br><span class="line">target.appendChild(docuemnt.createTextNode(<span class="string">&#x27;2&#x27;</span>));</span><br><span class="line">target.appendChild(docuemnt.createTextNode(<span class="string">&#x27;3&#x27;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p><code>MutationObserver</code> 的 <code>callback</code> 回调函数是异步的，只有在全部 <code>DOM</code> 操作完成之后才会调用 <code>callback。</code></p><p>2.当只设置<code>&#123; childList: true&#125;</code>时,表示观察目标子节点的变化</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observe = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span> (<span class="params">mutations, observe</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">debugger</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(mutations);</span><br><span class="line">  <span class="comment">//observe.discount();</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">observe.observe(target, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">target.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&#x27;新增 Text 节点&#x27;</span>)); <span class="comment">//增加节点，观察到变化</span></span><br><span class="line">target.childNodes[<span class="number">0</span>].remove(); <span class="comment">//删除节点，可以观察到</span></span><br><span class="line">target.childNodes[<span class="number">0</span>].textContent = <span class="string">&#x27;改变子节点的后代&#x27;</span>; <span class="comment">//不会观察到</span></span><br></pre></td></tr></table></figure><p>如果想要观察到子节点以及后代的变化需设置<code>&#123;childList: true, subtree: true&#125;</code></p><p><code>attributes</code> 选项用来观察目标属性的变化，用法类似与 <code>childList</code>,目标属性的删除添加以及修改都会被观察到。</p><p>3.我们需要注意的是 <code>characterData</code> 这个选项，它是用来观察 <code>CharacterData</code> 类型的节点的，只有在改变节点数据时才会观察到，如果你删除或者增加节点都不会进行观察，还有如果对不是 <code>CharacterData</code> 类型的节点的改变不会观察到，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">observe.observe(target, &#123; <span class="attr">characterData</span>: <span class="literal">true</span>, <span class="attr">subtree</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">target.childNodes[<span class="number">0</span>].textContent = <span class="string">&#x27;改变 Text 节点&#x27;</span>; <span class="comment">//观察到</span></span><br><span class="line">target.childNodes[<span class="number">1</span>].textContent = <span class="string">&#x27;改变 p 元素内容&#x27;</span>; <span class="comment">//不会观察到</span></span><br><span class="line">target.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&#x27;新增 Text 节点&#x27;</span>)); <span class="comment">//不会观察到</span></span><br><span class="line">target.childNodes[<span class="number">0</span>].remove(); <span class="comment">//删除 TEXT 节点也不会观察到</span></span><br></pre></td></tr></table></figure><p>我们只需要记住只有对 <code>CharacterData</code> 类型的节点的数据改变才会被 <code>characterData</code> 为 <code>true</code> 的选项所观察到。</p><p>4.最后关注一个特别有用的选项 <code>attributeFilter</code>，这个选项主要是用来筛选要观察的属性，比如你只想观察目标 <code>style</code> 属性的变化，这时可以如下设置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">observe.observe(target, &#123; <span class="attr">attributeFilter</span>: [<span class="string">&#x27;style&#x27;</span>], <span class="attr">subtree</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">target.style = <span class="string">&#x27;color:red&#x27;</span>; <span class="comment">//可以观察到</span></span><br><span class="line">target.removeAttribute(<span class="string">&#x27;name&#x27;</span>); <span class="comment">//删除 name 属性，无法观察到</span></span><br></pre></td></tr></table></figure><p><code>disconnect</code> 方法是用来阻止观察的，当你不再想观察目标节点的变化时可以调用 <code>observe.disconnect()</code> 方法来取消观察。</p><p><code>takeRecords</code> 方法是用来取出记录队列中的记录。它的一个作用是，比如你对一个节点的操作你不想马上就做出反应，过段时间在显示改变了节点的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> observe = <span class="keyword">new</span> MutationObserver(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">observe.observe(target, &#123; <span class="attr">childList</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">target.appendChild(<span class="built_in">document</span>.createTextNode(<span class="string">&#x27;新增 Text 节点&#x27;</span>));</span><br><span class="line"><span class="keyword">var</span> record = observe.takeRecords(); <span class="comment">//此时 record 保存了改变记录列表</span></span><br><span class="line"><span class="comment">//当调用 takeRecords 方法时，记录队列被清空因此不会触发 MutationObserver 中的 callback 回调方法。</span></span><br><span class="line">target.appendChild(<span class="built_in">document</span>.createElement(<span class="string">&#x27;span&#x27;</span>));</span><br><span class="line">observe.disconnect(); <span class="comment">//停止对 target 的观察。</span></span><br><span class="line"><span class="comment">//MutationObserver 中的回调函数只有一个记录，只记录了新增 span 元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//之后可以对 record 进行操作</span></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p><code>MutationRecord</code> 变动记录中的属性如下：</p><ul><li><code>type</code>：如果是属性变化，返回”attributes”，如果是一个 CharacterData 节点（Text 节点、Comment 节点）变化，返回”characterData”，节点树变化返回”childList”</li><li><code>target</code>：返回影响改变的节点</li><li><code>addedNodes</code>：返回添加的节点列表</li><li><code>removedNodes</code>：返回删除的节点列表</li><li><code>previousSibling</code>：返回分别添加或删除的节点的上一个兄弟节点，否则返回 null</li><li><code>nextSibling</code>：返回分别添加或删除的节点的下一个兄弟节点，否则返回 null</li><li><code>attributeName</code>：返回已更改属性的本地名称，否则返回 null</li><li><code>attributeNamespace</code>：返回已更改属性的名称空间，否则返回 null</li><li><code>oldValue</code>：返回值取决于 type。对于”attributes”，它是更改之前的属性的值。对于”characterData”，它是改变之前节点的数据。对于”childList”，它是 null</li></ul><p>其中 <code>type</code>、<code>target</code> 这两个属性不管是哪种观察方式都会有返回值，其他属性返回值与观察方式有关，比如只有当 <code>attributeOldValue</code> 或者 <code>characterDataOldValue</code> 为 <code>true</code> 时 <code>oldValue</code> <code>才有返回值，只有改变属性时，attributeName</code> 才有返回值等。</p>]]></content>
      
      
      <categories>
          
          <category> FE Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unable to preventDefault inside passive event listener due to target being treated as passive</title>
      <link href="369.html"/>
      <url>369.html</url>
      
        <content type="html"><![CDATA[<h2 id="事件现象"><a href="#事件现象" class="headerlink" title="事件现象"></a>事件现象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>chrome</code> 控制台报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Intervention] Unable to preventDefault inside passive event listener due to target being treated as passive. See https://www.chromestatus.com/features/5093566007214080</span><br></pre></td></tr></table></figure><p>在 <code>document</code> 上监听 <code>touch</code> 类事件时，如果在 <code>handler</code> 里调用了 <code>e.preventDefault()</code>，则会报错：<code>不能给passive(被动的)事件监听器 preventDefault，因为它被认为是 passive</code></p><h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><p><code>addEventListener()</code> 的第三个参数（可选）为以下二选一:</p><ul><li><code>useCapture</code> （<code>boolean</code>，默认值<code>false</code>）为 <code>true</code> 表示 <code>listener</code> 会在该类型的事件<code>捕获</code>阶段传播到该 <code>EventTarget</code> 时触发</li><li><code>options</code> （<code>object</code>）<ul><li><code>capture</code> （<code>boolean</code>，默认值 <code>false</code>,同 <code>useCapture</code>）</li><li><code>once</code> (<code>boolean</code>，默认值 <code>false</code>) 为 <code>true</code> 表示 <code>listener</code> 在添加之后最多只调用一次</li><li><code>passive</code> (<code>boolean</code>，默认值 <code>false</code> ) 为 <code>true</code> 表示 <code>listener</code> 调用 <code>preventDefault()</code> 无效并报错</li></ul></li></ul><h2 id="事件原因"><a href="#事件原因" class="headerlink" title="事件原因"></a>事件原因</h2><p>从 <code>Chrome 56</code> 开始，如果我们给 <code>document</code> 绑定 <code>touchmove</code> 或者 <code>touchstart</code> 事件的监听器，这个 <code>passive</code> 是会被默认设置为<code>true</code> 以提高性能<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2hyb21lc3RhdHVzLmNvbS9mZWF0dXJlLzUwOTM1NjYwMDcyMTQwODA=">查阅<i class="fa fa-external-link-alt"></i></span></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ul><li>避免在 <code>handler</code> 里调用 <code>e.preventDefault()</code>,提高性能</li><li><code>addEventListener</code> 里第三个参数设置为 <code>&#123;passive:false&#125;</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(</span><br><span class="line">  <span class="string">&#x27;touchstart&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    passive: <span class="literal">false</span>,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FE Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）javascript中的装箱和拆箱</title>
      <link href="368.html"/>
      <url>368.html</url>
      
        <content type="html"><![CDATA[<h2 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h2><p>把 <code>基本数据类型</code> 转换为对应的 <code>引用类型</code> 的操作称为 <code>装箱</code>，把 <code>引用类型</code> 转换为 <code>基本数据类型</code> 称为 <code>拆箱</code>。</p><blockquote><p>每当读取一个基本类型的时候，后台就会创建一个对应的基本包装类型对象，从而让我们能够调用一些方法来操作这些数据。 –《javascript 高级程序设计》</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&#x27;some text&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>如上所视，变量 <code>s1</code> 是一个基本类型值，它不是对象，所以它不应该有方法。但是 <code>js</code> 内部为我们完成了一系列处理（即我们称之为<code>装箱</code>），使得它能够调用方法,实现的机制如下：</p><ul><li>创建 <code>String</code> 类型的一个实例</li><li>在实例上调用指定的方法</li><li>销毁这个实例</li></ul><p>这个过程也可以用代码来展现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;some text&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>我在很多地方都看到过说装箱操作会泄露内存，可是这里明明是销毁了实例的，哎，我还是相信《javascript 高级程序设计》吧，认为它不会泄露~</p><h2 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h2><p>将 <code>引用类型</code> 对象转换为对应的 <code>基本数据类型</code>，它是通过 <code>引用类型</code> 的 <code>valueOf()</code> 或者 <code>toString()</code> 方法来实现的。如果是自定义的对象，你也可以自定义它的 <code>valueOf()/tostring()</code> 方法，实现对这个对象的 <code>拆箱</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objNum = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">var</span> objStr = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;123&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objNum); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objStr); <span class="comment">//object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objNum.valueOf()); <span class="comment">//number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objStr.valueOf()); <span class="comment">//string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objNum.toString()); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> objStr.toString()); <span class="comment">// string</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FE Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ast简介</title>
      <link href="367.html"/>
      <url>367.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>抽象语法树（Abstract Syntax Tree，AST）</code>是源代码语法结构的一种抽象表示。它以<strong>树状的形式表现编程语言的语法结构</strong>，树上的每个节点都表示源代码中的一种结构。之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>优化变更代码，改变代码结构达到想要的结构（<code>webpack</code> 等），代码语法、风格的检查（<code>eslint</code>），代码的格式化，代码的高亮，代码错误提示，代码自动补全（<code>IDE</code>）等等。</p><h2 id="如何转换"><a href="#如何转换" class="headerlink" title="如何转换"></a>如何转换</h2><p>可通过一些优秀的 <code>javascript Parser</code> 解析器，来实现源码转换为语法树，更改语法树，生成新的语法树。</p><h3 id="源码-gt-语法树"><a href="#源码-gt-语法树" class="headerlink" title="源码-&gt;语法树"></a>源码-&gt;语法树</h3><p>一般浏览器会把 <code>js</code> 源码通过解析器转化为抽象语法树，再进一步转化为字节码或直接生成机器码。</p><p>每一个 <code>js</code> 引擎都会有自己的抽象语法树格式，<code>chrome</code> 的 <code>v8</code> 引擎，<code>firefox</code> 的 <code>SpiderMonkey</code> 引擎等等，业界标准为：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Nb3ppbGxhL1Byb2plY3RzL1NwaWRlck1vbmtleS9QYXJzZXJfQVBJI05vZGVfb2JqZWN0cw==">AST 对象文档<i class="fa fa-external-link-alt"></i></span>，中文类似<span class="exturl" data-url="aHR0cDovL2RldmVsb3Blci41MWN0by5jb20vYXJ0LzIwMTYxMS81MjE0MDUuaHRt">讲解<i class="fa fa-external-link-alt"></i></span></p><p>在线解析点<span class="exturl" data-url="aHR0cHM6Ly9hc3RleHBsb3Jlci5uZXQv">这里<i class="fa fa-external-link-alt"></i></span></p><p>常用的 <code>parser</code> 有：<span class="exturl" data-url="aHR0cHM6Ly9lc3ByaW1hLm9yZy8=">esprima<i class="fa fa-external-link-alt"></i></span>，<code>traceur</code>，<code>acorn</code>( <code>webpack</code> 使用)，<code>shift</code></p><h3 id="遍历更新语法树"><a href="#遍历更新语法树" class="headerlink" title="遍历更新语法树"></a>遍历更新语法树</h3><p>常用的 <code>parser</code> 为：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VzdG9vbHMvZXN0cmF2ZXJzZQ==">estraverse<i class="fa fa-external-link-alt"></i></span></p><h3 id="语法树-gt-新的源码"><a href="#语法树-gt-新的源码" class="headerlink" title="语法树-&gt;新的源码"></a>语法树-&gt;新的源码</h3><p>常用的 <code>parser</code> 为：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VzdG9vbHMvZXNjb2RlZ2Vu">escodegen<i class="fa fa-external-link-alt"></i></span></p><p>使用 <code>esprima</code>, <code>estraverse</code>, <code>escodegen</code> 三板斧可完成源码编译解析，另有包 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2JlbmphbW4vcmVjYXN0">recast<i class="fa fa-external-link-alt"></i></span> 可完成这一系列操作。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="箭头函数转换成普通函数"><a href="#箭头函数转换成普通函数" class="headerlink" title="箭头函数转换成普通函数"></a>箭头函数转换成普通函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> esprima = <span class="built_in">require</span>(<span class="string">&#x27;esprima&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> estraverse = <span class="built_in">require</span>(<span class="string">&#x27;estraverse&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> escodegen = <span class="built_in">require</span>(<span class="string">&#x27;escodegen&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> code = <span class="string">`var a = b=&gt;&#123;console.log(123);&#125;`</span>;</span><br><span class="line"><span class="keyword">let</span> tree = esprima.parseScript(code);</span><br><span class="line">estraverse.traverse(tree, &#123;</span><br><span class="line">  <span class="function"><span class="title">leave</span>(<span class="params">node</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.type === <span class="string">&#x27;ArrowFunctionExpression&#x27;</span>) &#123;</span><br><span class="line">      node.type = <span class="string">&#x27;FunctionDeclaration&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> r = escodegen.generate(tree);</span><br><span class="line"><span class="built_in">console</span>.log(r); <span class="comment">// var a = function(b)&#123;console.log(123);&#125;</span></span><br></pre></td></tr></table></figure><h3 id="babel-插件"><a href="#babel-插件" class="headerlink" title="babel 插件"></a>babel 插件</h3><p>待补充 <span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxODc1MzcwNw==">参考<i class="fa fa-external-link-alt"></i></span></p><h3 id="vue-template-模板解析-AST"><a href="#vue-template-模板解析-AST" class="headerlink" title="vue template 模板解析 AST"></a>vue template 模板解析 AST</h3><p>待补充 <span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNTQzMjI1OA==">参考<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zpb2xldGphY2swODA4L2FydGljbGUvZGV0YWlscy83OTM1NDg1Mg==">参考 2<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> FE Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用proxy实现一个简单完整的MVVM库</title>
      <link href="366.html"/>
      <url>366.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>MVVM</code> 是当前时代前端日常业务开发中的必备模式（相关框架如<code>react</code>，<code>vue</code>，<code>angular</code> 等）， 使用 <code>MVVM</code> 可以将开发者的精力更专注于业务上的逻辑，而不需要关心如何操作 <code>dom</code>。虽然现在都 9012 年了，<code>mvvm</code> 相关原理的介绍已经烂大街了，但出于学习基础知识的目的（使用 <code>proxy</code> 实现的 <code>vue</code>3.0 还在开发中）， 在参考了之前 <code>vue.js</code> 的整体思路之后，自己动手实现了一个简易的通过 <code>proxy</code> 实现的 <code>mvvm</code>。</p><blockquote><p>本项目代码已经开源在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3poYW9reS9tdnZt">github<i class="fa fa-external-link-alt"></i></span>，项目正在持续完善中，欢迎交流学习，喜欢请点个 star 吧！</p></blockquote><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;title&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> MVVM <span class="keyword">from</span> <span class="string">&#x27;@fe_korey/mvvm&#x27;</span>;</span><br><span class="line"><span class="keyword">new</span> MVVM(&#123;</span><br><span class="line">  view: <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>),</span><br><span class="line">  model: &#123;</span><br><span class="line">    title: <span class="string">&#x27;hello mvvm!&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;主程编译完成,欢迎使用MVVM！&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="结构概览"><a href="#结构概览" class="headerlink" title="结构概览"></a>结构概览</h2><ul><li><code>Complier</code> 模块实现解析、收集指令，并初始化视图</li><li><code>Observer</code> 模块实现了数据的监听，包括添加订阅者和通知订阅者</li><li><code>Parser</code> 模块实现解析指令，提供该指令的更新视图的更新方法</li><li><code>Watcher</code> 模块实现建立指令与数据的关联</li><li><code>Dep</code> 模块实现一个订阅中心，负责收集，触发数据模型各值的订阅列表</li></ul><p>流程为：<code>Complier</code>收集编译好指令后，根据指令不同选择不同的<code>Parser</code>，根据<code>Parser</code>在<code>Watcher</code>中订阅数据的变化并更新初始视图。<code>Observer</code>监听数据变化然后通知给 <code>Watcher</code> ，<code>Watcher</code> 再将变化结果通知给对应<code>Parser</code>里的 <code>update</code> 刷新函数进行视图的刷新。</p><p><img data-src="http://cdn.flqin.com/mvvm.jpeg" alt="mvvm.js整体流程图"></p><h2 id="模块详解"><a href="#模块详解" class="headerlink" title="模块详解"></a>模块详解</h2><h3 id="Complier"><a href="#Complier" class="headerlink" title="Complier"></a>Complier</h3><ul><li><p>将整个数据模型 <code>data</code> 传入<code>Observer</code>模块进行数据监听</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$data = <span class="keyword">new</span> Observer(option.model).getData();</span><br></pre></td></tr></table></figure></li><li><p>循环遍历整个 <code>dom</code>，对每个 <code>dom</code> 元素的所有指令进行扫描提取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectDir</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> children = element.childNodes;</span><br><span class="line">  <span class="keyword">const</span> childrenLen = children.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childrenLen; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> node = children[i];</span><br><span class="line">    <span class="keyword">const</span> nodeType = node.nodeType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nodeType !== <span class="number">1</span> &amp;&amp; nodeType !== <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasDirective(node)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.$queue.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node.hasChildNodes() &amp;&amp; !hasLateCompileChilds(node)) &#123;</span><br><span class="line">      collectDir(element);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>对每个指令进行编译，选择对应的解析器<code>Parser</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parser = <span class="built_in">this</span>.selectParsers(&#123; node, dirName, dirValue, <span class="attr">cs</span>: <span class="built_in">this</span> &#125;);</span><br></pre></td></tr></table></figure></li><li><p>将得到的解析器<code>Parser</code>传入<code>Watcher</code>，并初始化该 <code>dom</code> 节点的视图</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(parser);</span><br><span class="line">parser.update(&#123; <span class="attr">newVal</span>: watcher.value &#125;);</span><br></pre></td></tr></table></figure></li><li><p>所有指令解析完毕后，触发 <code>MVVM</code> 编译完成回调<code>$mounted()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.$mounted();</span><br></pre></td></tr></table></figure></li><li><p>使用文档碎片<code>document.createDocumentFragment()</code>来代替真实 <code>dom</code> 节点片段，待所有指令编译完成后，再将文档碎片追加回真实 <code>dom</code> 节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> child;</span><br><span class="line"><span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"><span class="keyword">while</span> ((child = <span class="built_in">this</span>.$element.firstChild)) &#123;</span><br><span class="line">  fragment.appendChild(child);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解析完后</span></span><br><span class="line"><span class="built_in">this</span>.$element.appendChild(fragment);</span><br><span class="line"><span class="keyword">delete</span> $fragment;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h3><ul><li><p>在<code>Complier</code>模块编译后的指令，选择不同听解析器解析，目前包括<code>ClassParser</code>,<code>DisplayParser</code>,<code>ForParser</code>,<code>IfParser</code>,<code>StyleParser</code>,<code>TextParser</code>,<code>ModelParser</code>,<code>OnParser</code>,<code>OtherParser</code>等解析模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (name) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;text&#x27;</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> TextParser(&#123; node, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;style&#x27;</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> StyleParser(&#123; node, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;class&#x27;</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> ClassParser(&#123; node, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;for&#x27;</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> ForParser(&#123; node, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;on&#x27;</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> OnParser(&#123; node, dirName, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;display&#x27;</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> DisplayParser(&#123; node, dirName, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;if&#x27;</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> IfParser(&#123; node, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">&#x27;model&#x27;</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> ModelParser(&#123; node, dirValue, cs &#125;);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    parser = <span class="keyword">new</span> OtherParser(&#123; node, dirName, dirValue, cs &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不同的解析器提供不同的视图刷新函数<code>update()</code>，通过<code>update</code>更新<code>dom</code>视图</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//text.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.el.textContent = _toString(newVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>OnParser</code> 解析事件绑定，与数据模型中的 <code>methods</code>字段对应</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//详见 https://github.com/zhaoky/mvvm/blob/master/src/core/parser/on.ts</span></span><br><span class="line">el.addEventListener(handlerType, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  handlerFn(scope, e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p><code>ForParser</code> 解析数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//详见 https://github.com/zhaoky/mvvm/blob/master/src/core/parser/for.ts</span></span><br></pre></td></tr></table></figure></li><li><p><code>ModelParser</code> 解析双向绑定，目前支持<code>input[text/password] &amp; textarea</code>,<code>input[radio]</code>,<code>input[checkbox]</code>,<code>select</code>四种情况的双向绑定，双绑原理：</p><ul><li><p>数据变化更新表单：跟其他指令更新视图一样，通过<code>update</code>方法触发更新表单的<code>value</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">&#123; newVal &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.model.el.value = _toString(newVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>表单变化更新数据：监听表单变化事件如<code>input</code>,<code>change</code>，在回调里<code>set</code>数据模型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.model.el.addEventListener(<span class="string">&#x27;input&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  model.watcher.set(e.target.value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><ul><li><code>MVVM</code> 模型中的核心，一般通过 <code>Object.defineProperty</code> 的 <code>get</code>，<code>set</code> 方法进行数据的监听，在 <code>get</code> 里添加订阅者，<code>set</code> 里通知订阅者更新视图。在本项目采用 <code>Proxy</code> 来实现数据监听，好处有三：<ul><li><code>Proxy</code> 可以直接监听对象而非属性</li><li><code>Proxy</code> 可以直接监听数组的变化</li><li><code>Proxy</code> 有多达 13 种拦截方法，<span class="exturl" data-url="aHR0cDovL2VzNi5ydWFueWlmZW5nLmNvbS8jZG9jcy9wcm94eQ==">查阅<i class="fa fa-external-link-alt"></i></span><br>而劣势是兼容性问题,且无法通过 <code>polyfill</code> 磨平。查阅<span class="exturl" data-url="aHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPVByb3h5">兼容性<i class="fa fa-external-link-alt"></i></span></li></ul></li><li>注意 <code>Proxy</code> 只会监听自身的每一个属性，如果属性是对象，则该对象不会被监听，所以需要递归监听</li><li>设置监听后，返回一个 <code>Proxy</code> 替代原数据对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//如果满足条件则添加订阅者</span></span><br><span class="line">    dep.addDep(curWatcher);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//如果满足条件则通知订阅者</span></span><br><span class="line">    dep.notfiy();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><ul><li><p>在 <code>Complier</code> 模块里对每一个解析后的 <code>Parser</code> 进行指令与数据模型直接的绑定，并触发 <code>Observer</code> 的 <code>get</code> 监听，添加订阅者（<code>Watcher</code>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>._getter(<span class="built_in">this</span>.parser.dirValue)(<span class="built_in">this</span>.scope || <span class="built_in">this</span>.parser.cs.$data);</span><br></pre></td></tr></table></figure></li><li><p>当数据模型变化时，就会触发 -&gt; <code>Observer</code> 的 <code>set</code> 监听 -&gt; <code>Dep</code> 的 <code>notfiy</code> 方法(通知订阅者的所有订阅列表) -&gt; 执行订阅列表所有 <code>Watcher</code> 的 <code>update</code> 方法 -&gt; 执行对应 <code>Parser</code> 的 <code>update</code> -&gt; 完成更新视图</p></li><li><p><code>Watcher</code> 里的 <code>set</code> 方法用于设置双向绑定值，注意访问层级</p></li></ul><h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><ul><li><code>MVVM</code> 的订阅中心，在这里收集数据模型的每个属性的订阅列表</li><li>包含添加订阅者，通知订阅者等方法</li><li>本质是一种发布/订阅模式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.dependList = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addDep</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.dependList.push(dep);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">notfiy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.dependList.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      item.update();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>目前该 <code>mvvm</code> 项目只实现了<code>数据绑定</code>和<code>视图更新</code>的功能，通过这个简易轮子的实现，对 <code>dom</code> 操作，<code>proxy</code>，<code>发布订阅模式</code>等若干基础知识都进行了再次理解，查漏补缺。同时欢迎大家一起探讨交流，后面会继续完善！</p>]]></content>
      
      
      <categories>
          
          <category> FE Summary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式的先行断言(lookahead)和后行断言(lookbehind)</title>
      <link href="365.html"/>
      <url>365.html</url>
      
        <content type="html"><![CDATA[<p>均是<strong>匹配位置</strong>，在匹配过程中，不占用字符，所以被称为<strong>零宽</strong>。</p><ul><li><p><code>(?=pattern)</code> 零宽<code>正向先行</code>断言(zero-width positive lookahead assertion)</p><ul><li><p>紧接该位置<strong>之后</strong>的字符序列<strong>能够</strong>匹配 <code>pattern</code></p></li><li><p>如替换后面紧跟<code>c</code>的<code>ab</code>为<code>xx</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abcabdabe&#x27;</span>.replace(<span class="regexp">/ab(?=c)/g</span>, <span class="string">&#x27;xx&#x27;</span>); <span class="comment">// xxcabdabe</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>(?!pattern)</code> 零宽<code>负向先行</code>断言(zero-width negative lookahead assertion)</p><ul><li><p>紧接该位置<strong>之后</strong>的字符序列<strong>不能</strong>匹配 <code>pattern</code></p></li><li><p>如替换后面不为<code>c</code>的<code>ab</code>为<code>xx</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abcabdabe&#x27;</span>.replace(<span class="regexp">/ab(?!c)/g</span>, <span class="string">&#x27;xx&#x27;</span>); <span class="comment">// abcxxdxxe</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>(?&lt;=pattern)</code> 零宽<code>正向后行</code>断言(zero-width positive lookbehind assertion)</p><ul><li><p>紧接该位置<strong>之前</strong>的字符序列<strong>能够</strong>匹配 <code>pattern</code></p></li><li><p>如替换前面为<code>a</code>的<code>bc</code>为<code>xx</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abcdbcebc&#x27;</span>.replace(<span class="regexp">/(?&lt;=a)bc/g</span>, <span class="string">&#x27;xx&#x27;</span>); <span class="comment">// axxdbcebc</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>(?&lt;!pattern)</code> 零宽<code>负向后行</code>断言(zero-width negative lookbehind assertion)</p><ul><li><p>紧接该位置<strong>之前</strong>的字符序列<strong>不能</strong>匹配 <code>pattern</code></p></li><li><p>如替换后面不为<code>a</code>的<code>bc</code>为<code>xx</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abcdbcebc&#x27;</span>.replace(<span class="regexp">/(?&lt;!a)bc/g</span>, <span class="string">&#x27;xx&#x27;</span>); <span class="comment">// abcdxxexx</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>另：非捕获分组<code>(?:p)</code></p><p><code>括号</code>是提供分组功能，如果只想要<code>括号</code>最原始的功能，但不会引用它，即既不在 API 里引用，也不在正则里反向引用。此时可以使用<code>非捕获分组(?:p)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;abcde&#x27;</span>.replace(<span class="regexp">/(ab)c(de)/g</span>, <span class="string">&#x27;$1&#x27;</span>); <span class="comment">// ab</span></span><br><span class="line"><span class="string">&#x27;abcde&#x27;</span>.replace(<span class="regexp">/(?:ab)c(de)/g</span>, <span class="string">&#x27;$1&#x27;</span>); <span class="comment">// de</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FE Code </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）为什么JavaScript里面typeof(null)的值是&quot;object&quot;</title>
      <link href="364.html"/>
      <url>364.html</url>
      
        <content type="html"><![CDATA[<ol><li>null 不是一个空引用, 而是一个原始值, 参考 <span class="exturl" data-url="aHR0cDovL2x6dy5tZS9wYWdlcy9lY21hc2NyaXB0LyMyMA==">ECMAScript5.1 中文版<i class="fa fa-external-link-alt"></i></span> 4.3.11 节; 它只是期望此处将引用一个对象, 注意是”期望”, 参考 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvbnVsbA==">null - JavaScript<i class="fa fa-external-link-alt"></i></span>.</li><li>typeof null 结果是 object, 这是个历史遗留 bug, 参考 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL3R5cGVvZg==">typeof - JavaScript<i class="fa fa-external-link-alt"></i></span></li><li>在 ECMA6 中, 曾经有提案为历史平反, 将 type null 的值纠正为 null, 但最后提案被拒了. 理由是历史遗留代码太多, 不想得罪人, 不如继续将错就错当和事老, 参考 <span class="exturl" data-url="aHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTp0eXBlb2ZfbnVsbA==">harmony:typeof_null -ES Wiki<i class="fa fa-external-link-alt"></i></span></li></ol>]]></content>
      
      
      <categories>
          
          <category> FE Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>NFE（具名函数表达式）的问题</title>
      <link href="363.html"/>
      <url>363.html</url>
      
        <content type="html"><![CDATA[<p>群里小伙伴讨论了这么一个问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;;</span><br><span class="line">a(); <span class="comment">//打印b为function()&#123;b=1;console.log(b);&#125;</span></span><br></pre></td></tr></table></figure><p>为什么这里打印的 <code>b</code> 为 <code>b</code> 函数，而不是 <code>1</code>？</p><p>声明提前：一个声明在函数体内都是可见的，函数声明优先于变量声明；<code>函数表达式</code> 如果有 <code>name</code> 的话，这个 <code>name</code> 是 <code>不可删除且为只读</code>。</p><p>资料查阅：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9nb2RkeXpoYW8udHVtYmxyLmNvbS9wb3N0LzExMjczNzEzOTIwL2Z1bmN0aW9ucw==">函数（Functions）<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9nb2RkeXpoYW8udHVtYmxyLmNvbS9wb3N0LzExMjU5NjQ0MDkyL3Njb3BlLWNoYWlu">作用域链（Scope Chain）<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9nb2RkeXpoYW8udHVtYmxyLmNvbS9wb3N0LzExMTQxNzEwNDQxL3ZhcmlhYmxlLW9iamVjdA==">变量对象（Variable object）<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9nb2RkeXpoYW8udHVtYmxyLmNvbS9wb3N0LzEwMDIwMjMwMzUyL2V4ZWN1dGlvbi1jb250ZXh0">执行上下文（Execution Context）<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> FE Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自定义事件</title>
      <link href="362.html"/>
      <url>362.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建，触发，删除自定义事件"><a href="#创建，触发，删除自定义事件" class="headerlink" title="创建，触发，删除自定义事件"></a>创建，触发，删除自定义事件</h2><ul><li>创建自定义事件 文档<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvR3VpZGUvRXZlbnRzL0NyZWF0aW5nX2FuZF90cmlnZ2VyaW5nX2V2ZW50cw==">查阅<i class="fa fa-external-link-alt"></i></span></li><li>Event() 文档<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50L0V2ZW50">查阅<i class="fa fa-external-link-alt"></i></span></li><li>Event 属性 文档<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50">查阅<i class="fa fa-external-link-alt"></i></span></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">&#x27;build&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen for the event.</span></span><br><span class="line">elem.addEventListener(<span class="string">&#x27;build&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; ... &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dispatch the event.</span></span><br><span class="line">elem.dispatchEvent(event);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete the event.</span></span><br><span class="line">elem.removeEventListener(<span class="string">&#x27;build&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="添加自定义数据"><a href="#添加自定义数据" class="headerlink" title="添加自定义数据"></a>添加自定义数据</h2><p>要向事件对象添加更多数据，可以使用 <code>CustomEvent</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">&#x27;build&#x27;</span>, &#123; <span class="attr">detail</span>: elem.dataset.time &#125;);</span><br></pre></td></tr></table></figure><p>事件监听器中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eventHandler</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  log(<span class="string">&#x27;The time is: &#x27;</span> + e.detail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="触发内置事件"><a href="#触发内置事件" class="headerlink" title="触发内置事件"></a>触发内置事件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">&#x27;input&#x27;</span>, &#123;</span><br><span class="line">  bubbles: <span class="literal">true</span>, <span class="comment">//能否冒泡</span></span><br><span class="line">  cancelable: <span class="literal">true</span>, <span class="comment">//事件是否可以取消默认行为</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">element.dispatchEvent(event);</span><br></pre></td></tr></table></figure><h2 id="createEvent-amp-initEvent-（已废弃-IE-中可用）"><a href="#createEvent-amp-initEvent-（已废弃-IE-中可用）" class="headerlink" title="createEvent &amp; initEvent （已废弃,IE 中可用）"></a>createEvent &amp; initEvent （已废弃,IE 中可用）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">&#x27;Event&#x27;</span>);</span><br><span class="line">event.initEvent(<span class="string">&#x27;build&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FE Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用typescript下的项目架构最佳实践</title>
      <link href="361.html"/>
      <url>361.html</url>
      
        <content type="html"><![CDATA[<p>此贴记录下在 <code>typescript</code> 项目里的一些相关配置和包的选用，其中各种依赖包和最佳实践都在不断发展演变中，最新的配置以该仓库 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3poYW9reS9tdnZt">MVVM<i class="fa fa-external-link-alt"></i></span> 为准。</p><h2 id="typescript-支持"><a href="#typescript-支持" class="headerlink" title="typescript 支持"></a>typescript 支持</h2><p>在<code>webpack</code>中使用 <code>babel 7.0 +</code>,摒弃了传统的 <code>ts-loader</code> 或 <code>awesome-typescript-loader</code> 方案。原因如下：</p><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Zyb250ZW5kOS9mZTktbGlicmFyeS9pc3N1ZXMvMjM=">参考 1<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzgyMmU0MjZmYjlhMDRhMGE1ZmZiNDk=">参考 2<i class="fa fa-external-link-alt"></i></span></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add @babel/core babel-loader @babel/preset-env @babel/preset-typescript -D</span><br><span class="line">yarn add @babel/plugin-proposal-class-propertie -D //根据项目需求添加其他env未包含的转义插件</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>babel</code> 只负责转换，并不会做对应的类型检查，所以需要安装 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1R5cGVTdHJvbmcvZm9yay10cy1jaGVja2VyLXdlYnBhY2stcGx1Z2lu">fork-ts-checker-webpack-plugin<i class="fa fa-external-link-alt"></i></span> 来进行报错提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add fork-ts-checker-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>项目通用转 <code>ES5</code> 安装包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add @babel/plugin-transform-runtime @babel/runtime-corejs3 -D</span><br></pre></td></tr></table></figure><p><code>babel.config.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&#x27;@babel/env&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        targets: <span class="string">&#x27;&gt; 1%, not dead&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&#x27;@babel/preset-typescript&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&#x27;@babel/plugin-transform-runtime&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        corejs: <span class="number">3</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&#x27;@babel/plugin-proposal-class-properties&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>tsconfig.json</code> 配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;ESNext&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;commonjs&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;noImplicitAny&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;sourceMap&quot;</span>: <span class="literal">false</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;include&quot;</span>: [<span class="string">&quot;src/**/*&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>webpack</code> 配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(js|ts)$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">      use: [<span class="string">&#x27;babel-loader&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码检查-amp-风格统一"><a href="#代码检查-amp-风格统一" class="headerlink" title="代码检查 &amp; 风格统一"></a>代码检查 &amp; 风格统一</h2><p><strong>代码检查</strong>使用 <code>eslint</code>（<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3R5cGVzY3JpcHQtZXNsaW50L3R5cGVzY3JpcHQtZXNsaW50">官方未来推荐<i class="fa fa-external-link-alt"></i></span>），抛弃传统的 <code>tslint</code> 方案：<span class="exturl" data-url="aHR0cHM6Ly90cy54Y2F0bGl1LmNvbS9lbmdpbmVlcmluZy9saW50">参考链接<i class="fa fa-external-link-alt"></i></span>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yarn add eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin -D</span><br><span class="line"></span><br><span class="line">//@typescript-eslint/parser :将 TypeScript 转换为 ESTree，使 eslint 可以识别</span><br><span class="line">//@typescript-eslint/eslint-plugin :只是一个可以打开或关闭的规则列表</span><br></pre></td></tr></table></figure><p><code>@typescript-eslint/parser</code> 作为 <code>babel</code> 的解析器，这时候就不需要安装 <code>babel</code> 默认推荐的 <code>eslint</code> 解析器(<code>babel-eslint</code>)了，规则列表<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3R5cGVzY3JpcHQtZXNsaW50L3R5cGVzY3JpcHQtZXNsaW50L3RyZWUvbWFzdGVyL3BhY2thZ2VzL2VzbGludC1wbHVnaW4=">查阅<i class="fa fa-external-link-alt"></i></span>。</p><p><strong>风格统一</strong>使用 <code>prettier</code>，在 <code>typescript</code> 项目里将配置文件 <code>prettier.config.js</code> 里添加 <code>parser: &quot;typescript&quot;</code> 即可(前提是已安装 <code>@typescript-eslint/parser</code>：<span class="exturl" data-url="aHR0cHM6Ly9wcmV0dGllci5pby9kb2NzL2VuL29wdGlvbnMuaHRtbCNwYXJzZXI=">参考链接<i class="fa fa-external-link-alt"></i></span>)。</p><p>项目通用 <code>prettier</code> 的其他包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add prettier eslint-config-prettier eslint-plugin-prettier -D</span><br></pre></td></tr></table></figure><p>结合 <code>eslint+prettier</code>，得到：</p><p><code>prettier.config.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  singleQuote: <span class="literal">false</span>,</span><br><span class="line">  printWidth: <span class="number">200</span>,</span><br><span class="line">  parser: <span class="string">&#x27;typescript&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>.eslintrc.js</code> (这里使用的 <code>google</code> 默认规则 <code>eslint-config-google</code>):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  root: <span class="literal">true</span>,</span><br><span class="line">  parser: <span class="string">&#x27;@typescript-eslint/parser&#x27;</span>,</span><br><span class="line">  plugins: [<span class="string">&#x27;@typescript-eslint&#x27;</span>],</span><br><span class="line">  env: &#123;</span><br><span class="line">    browser: <span class="literal">true</span>,</span><br><span class="line">    es6: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">extends</span>: [<span class="string">&#x27;plugin:@typescript-eslint/recommended&#x27;</span>, <span class="string">&#x27;google&#x27;</span>, <span class="string">&#x27;prettier&#x27;</span>, <span class="string">&#x27;prettier/@typescript-eslint&#x27;</span>],</span><br><span class="line">  globals: &#123;</span><br><span class="line">    Atomics: <span class="string">&#x27;readonly&#x27;</span>,</span><br><span class="line">    SharedArrayBuffer: <span class="string">&#x27;readonly&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">    ecmaVersion: <span class="number">2018</span>,</span><br><span class="line">    sourceType: <span class="string">&#x27;module&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/no-explicit-any&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&#x27;@typescript-eslint/no-use-before-define&#x27;</span>: <span class="number">0</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="jest"><a href="#jest" class="headerlink" title="jest"></a>jest</h3><p>这里选用 <code>jest</code> 框架来测试。<span class="exturl" data-url="aHR0cDovL3d3dy5mbHk2My5jb20vYXJ0aWNsZS9kZXRpYWwvMTcw">jest 的优势？<i class="fa fa-external-link-alt"></i></span>。</p><p>在 <code>ts</code> 项目里，摒弃了传统的 <code>ts-jest</code>，只需如上安装 <code>@babel/preset-typescript</code>，并在 <code>babel.config.js</code> 里的 <code>presets</code> 添加即可。<span class="exturl" data-url="aHR0cHM6Ly9qZXN0anMuaW8vZG9jcy9lbi9nZXR0aW5nLXN0YXJ0ZWQuaHRtbCN1c2luZy10eXBlc2NyaXB0">参考链接<i class="fa fa-external-link-alt"></i></span>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn jest @types/jest -D  //@types/jest 是 jest 的 ts 类型定义文件，而 vscode 便是基于 ts 进行代码提示的</span><br></pre></td></tr></table></figure><ul><li>经查 <code>jest</code> 依赖包里发现，<code>jest</code> 依赖 <code>babel-jest</code> (用于支持 <code>es6</code> 语法)，故不需要在单独引入依赖包 <code>babel-jest</code>。</li><li>因为引入了 <code>@types/jest</code>，也就不需要引入 <code>eslint-plugin-jest</code> 来消除 <code>jest</code> 变量的报错。</li><li><code>jest config</code> 采用默认配置即可，更多个性化配置<span class="exturl" data-url="aHR0cHM6Ly9qZXN0anMuaW8vZG9jcy9lbi9jb25maWd1cmF0aW9u">参见<i class="fa fa-external-link-alt"></i></span>。</li></ul><h3 id="coveralls"><a href="#coveralls" class="headerlink" title="coveralls"></a>coveralls</h3><p>这里选用了 <span class="exturl" data-url="aHR0cHM6Ly9jb3ZlcmFsbHMuaW8v">coveralls<i class="fa fa-external-link-alt"></i></span> 作为自动测试代码覆盖率的在线工具。由于项目走 <code>travis.com</code> 的持续集成，所以配置为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add coveralls -D</span><br></pre></td></tr></table></figure><p><code>.coveralls.yml</code>:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">service_name:</span> <span class="string">travis-pro</span></span><br><span class="line"><span class="attr">repo_token:</span> <span class="string">COVERALLS_TOKEN</span> <span class="comment"># COVERALLS_TOKEN为加密变量</span></span><br></pre></td></tr></table></figure><p><code>package.json</code> 添加 <code>scripts</code> (测试框架为 <code>jest</code>，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25pY2ttZXJ3aW4vbm9kZS1jb3ZlcmFsbHM=">更多方法查阅<i class="fa fa-external-link-alt"></i></span>):</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;coveralls&quot;: &quot;jest --coverage &amp;&amp; cat ./coverage/lcov.info | coveralls&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><code>.travis.yml</code> 添加：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&quot;s/COVERALLS_TOKEN/$COVERALLS_TOKEN/&quot;</span> <span class="string">.coveralls.yml</span> <span class="comment">#$COVERALLS_TOKEN为在travis.com项目里配置的加密变量</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">run</span> <span class="string">coveralls</span></span><br></pre></td></tr></table></figure><h3 id="在-vscode-里调试-jest-webpack-等-node-js"><a href="#在-vscode-里调试-jest-webpack-等-node-js" class="headerlink" title="在 vscode 里调试 jest/webpack 等 node.js"></a>在 vscode 里调试 jest/webpack 等 node.js</h3><p><code>调试</code> -&gt; <code>添加配置</code> -&gt; 选择<code>node.js</code>，自动生成<code>.vscode/launch.json</code>，修改配置为：</p><p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20vZG9jcy9ub2RlanMvbm9kZWpzLWRlYnVnZ2luZw==">文档<i class="fa fa-external-link-alt"></i></span></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&quot;configurations&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;node&quot;</span>, <span class="comment">//系统默认，不可更改，标识要使用的调试器的类型</span></span><br><span class="line">      <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>, <span class="comment">//系统默认，不可更改，在指定的文件上启动调试器 program. attach: 将调试器附加到已经运行的进程。</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Launch Program&quot;</span>, <span class="comment">//调试配置的名称</span></span><br><span class="line">      <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/index.js&quot;</span>, <span class="comment">//要调试的Node.js程序的绝对路径</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span>: [<span class="string">&quot;--runInBand&quot;</span>, <span class="string">&quot;--env=jsdom&quot;</span>, <span class="string">&quot;$&#123;fileBasename&#125;&quot;</span>], <span class="comment">//传递给程序进行调试的参数[array]</span></span><br><span class="line">      <span class="attr">&quot;runtimeExecutable&quot;</span>: <span class="string">&quot;npm&quot;</span>, <span class="comment">// 要使用的运行时可执行文件的绝对路径。默认是node (https://code.visualstudio.com/docs/nodejs/nodejs-debugging#_launch-configuration-support-for-npm-and-other-tools)</span></span><br><span class="line">      <span class="attr">&quot;runtimeArgs&quot;</span>: [<span class="string">&quot;run-script&quot;</span>, <span class="string">&quot;debug&quot;</span>], <span class="comment">// 传递给运行时可执行文件的可选参数</span></span><br><span class="line">      <span class="attr">&quot;runtimeVersion&quot;</span>:<span class="string">&quot;7.10.1&quot;</span>, <span class="comment">//使用nvm可以用此属性控制node.js版本</span></span><br><span class="line">      <span class="attr">&quot;port&quot;</span>: <span class="number">5858</span>, <span class="comment">//要使用的调试端口</span></span><br><span class="line">      <span class="attr">&quot;console&quot;</span>: <span class="string">&quot;externalTerminal&quot;</span>, <span class="comment">//指定如何显示程序输出: externalTerminal:独立控制台窗口,integratedTerminal(默认):VS代码集成终端</span></span><br><span class="line">      <span class="attr">&quot;stopOnEntry&quot;</span>: <span class="literal">true</span>, <span class="comment">// 设置为true时，在调试程序的第一行中断开调试器。如果省略（默认）或设置为false，则调试器将程序运行到第一个断点。</span></span><br><span class="line">      <span class="attr">&quot;skipFiles&quot;</span>: [<span class="string">&quot;&lt;node_internals&gt;/**/*.js&quot;</span>,<span class="string">&quot;$&#123;workspaceFolder&#125;/lib/**/*.js&quot;</span>] <span class="comment">// 跳过不感兴趣的代码, Node.js的内置核心模块定义为：&lt;node_internals&gt;，其他变量定义(https://code.visualstudio.com/docs/editor/variables-reference)</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>调试单一 <code>node</code> 文件：<ul><li><code>launch.json</code> 配置：<ul><li><code>program:$&#123;workspaceFolder&#125;/index.js</code></li><li><code>args:[&#39;--dev&#39;]</code></li></ul></li></ul></li><li>调试 <code>npm scripts</code> (包括普通 <code>node</code> 命令如 <code>index.js</code> 和非 <code>node</code> 命令如 <code>jest,webpack</code> 等)时：<ul><li><code>launch.json</code> 配置：<ul><li><code>runtimeExecutable:&quot;npm&quot;</code> //必须设置为<code>npm</code></li><li><code>runtimeArgs:[&quot;run&quot;, &quot;debug&quot;]</code> //第一个参数必须为<code>run</code></li><li><code>runtimeVersion:&quot;10.6.0&quot;</code> //可选</li></ul></li><li><code>package.json</code> 的 <code>npm scripts</code> 配置：<ul><li>必须加 <code>--inspect-brk=5858</code>，<code>5858</code> 与 <code>port</code> 设置须相同</li><li>非普通命令需要转换成 <code>node</code> 调用: <code>webpack=&gt;./node_modules/.bin/webpack</code> (因为 <code>npm run build</code> 实际调用的是 <code>node_modules/.bin/webpack</code>)</li><li>带参数的命令接在后面即可：<code>node --inspect-brk=5858 ./node_modules/.bin/jest --coverage</code></li></ul></li></ul></li></ul><p><code>npm scripts</code>:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;debug&quot;: &quot;node --inspect-brk=5858 index.js&quot;,</span><br><span class="line">  &quot;build&quot;: &quot;node --inspect-brk=5858 ./node_modules/.bin/webpack --mode=development&quot;,</span><br><span class="line">  &quot;test&quot;: &quot;node --inspect-brk=5858 ./node_modules/.bin/jest --coverage&quot;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="前端测试概念"><a href="#前端测试概念" class="headerlink" title="前端测试概念"></a>前端测试概念</h3><h4 id="测试类型"><a href="#测试类型" class="headerlink" title="测试类型"></a>测试类型</h4><ul><li>单元测试 (<code>Unit Test</code>) - 通过模拟输入和预测输出的方式测试独立的函数或者类。</li><li>集成测试 (<code>Integration Test</code>) - 测试多个模块间的联动是否和期望相同。</li><li><code>E2E</code> 测试 (也被称为 <code>Functional Test</code>) - 关注点不在内部实现方式，而是测试产品在真实使用场景（比如在浏览器）中是否可以达到预想的结果，属于黑盒测试。</li></ul><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMjcwMjQyMQ==">更多<i class="fa fa-external-link-alt"></i></span></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Typescript-错误忽略"><a href="#Typescript-错误忽略" class="headerlink" title="Typescript 错误忽略"></a>Typescript 错误忽略</h3><ul><li>单行忽略 <code>// @ts-ignore</code></li><li>忽略全文 <code>// @ts-nocheck</code></li><li>取消忽略全文 <code>// @ts-check</code></li></ul><h3 id="github-徽章"><a href="#github-徽章" class="headerlink" title="github 徽章"></a>github 徽章</h3><p>在 <span class="exturl" data-url="aHR0cHM6Ly9zaGllbGRzLmlvLw==">shields<i class="fa fa-external-link-alt"></i></span> 上面可生成任意徽章。</p><h3 id="d-ts-文件是什么"><a href="#d-ts-文件是什么" class="headerlink" title=".d.ts 文件是什么"></a>.d.ts 文件是什么</h3><p><code>d.ts</code> 就是 <code>TypedDefinition 类型定义文件</code>，用来定义类型信息以及接口规范。</p><p><code>ts</code>代码最终会编译成 <code>.js</code> 的 <code>js</code> 代码，供他人使用。这个时候类型信息就丢失了。所以 <code>ts</code> 编译器会自动根据 <code>.ts</code> 中的信息，可以自动生成对外的 <code>.d.ts</code> 文件，和生成的 <code>js</code> 文件搭配使用。其中，<code>js</code> 文件是给运行引擎用的，而 <code>.d.ts</code> 文件是给 <code>IDE（智能编辑器）</code> 写代码时参考用的。</p><h3 id="如何测试本地-node-包"><a href="#如何测试本地-node-包" class="headerlink" title="如何测试本地 node 包"></a>如何测试本地 node 包</h3><p>采用 <code>npm link</code></p><ul><li>在需要测试的包（如 <code>test</code> ）路径下执行：<code>npm link</code>，这时 <code>全局node_modules</code> 包下就可以看到这个 <code>test</code> 包。</li><li>在需引用的目标包的项目下安装该测试包：<code>npm link test</code>（如果有作用域需要加上作用域：<code>npm link @fe_korey/test</code>）,这时 test 包就被安装在了该目录下，在 <code>test</code> 包里的修改会同步到目标包里。</li><li>取消连接：在 <code>test</code> 包里执行：<code>npm unlink</code> 即可.</li></ul><p>注意：在 <code>webpack</code> 项目中，如果用 <code>npm link</code> 方式测试本地包，需要设置 <code>config</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  symlinks: <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FE Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）点击穿透</title>
      <link href="360.html"/>
      <url>360.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>点击穿透这种现象算是移动 <code>web</code> 开发比较经典的问题，也常用来做面试题。本文目标是结合移动 <code>web</code> 开发的相关事件，介绍一下点击穿透现象形成的原因以及避免这种现象的解决方法。</p><h2 id="点击穿透现象"><a href="#点击穿透现象" class="headerlink" title="点击穿透现象"></a>点击穿透现象</h2><p>现象描述：</p><p>页面中存在上下两个层，上层元素具有表单，链接或者绑定相应事件，上层元素点击或触摸，导致上层 <code>DOM</code> 改变，下层中同样位置的元素触发点击事件。这种现象就是<code>点击穿透（Ghost Clicks）</code>。其实我觉得用“幽冥点击”称呼它更加带感。</p><p>要理解这种现象，首先要了解移动端的相关事件 —— <code>触摸(Touch)事件</code>，<code>点击(Click)事件</code>。</p><p><code>Touch</code> 事件中，常用的为 <code>touchstart</code>, <code>touchmove</code>, <code>touchend</code> 三种。除此之外还有 <code>touchcancel</code>。<br>注意，原生事件中并没有 <code>tap</code> 事件。下面会解释 <code>tap</code> 事件怎么产生的。</p><p>事件描述如下：</p><table><thead><tr><th>事件</th><th>描述</th><th>触发时机</th></tr></thead><tbody><tr><td>touchstart</td><td>开始触摸</td><td>手指接触屏幕时立即触发</td></tr><tr><td>touchmove</td><td>移动或拖拽</td><td>取决于系统和浏览器</td></tr><tr><td>touchend</td><td>触摸结束</td><td>手指离开屏幕时立即出发</td></tr></tbody></table><p>而 <code>Touch</code> 事件的触发一般通过手指，还会存在多点触控，拖拽方向等情况。列出几个重要参数如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>touches</td><td>屏幕中每根手指信息列表</td></tr><tr><td>targetTouches</td><td>和 touches 类似，把同一节点的手指信息过滤掉</td></tr><tr><td>changedTouches</td><td>响应当前事件的每根手指的信息列表</td></tr></tbody></table><p>代码获取如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxDOM.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.touches, e.targetTouches, e.changedTouches);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>手指触发触摸事件的过程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touchstart -&gt; touchmove -&gt; ... touchmove -&gt; touchend</span><br></pre></td></tr></table></figure><p>由此，我们可以在 <code>ontouchstart</code> 事件上记录开始触摸开始，<code>ontouchend</code> 记录触摸结束信息。</p><p>通过上述这些参数，很容易的去计算幽冥点击的时间，以及点击穿透的相关信息，包括响应的坐标情况。</p><h2 id="造成的原因"><a href="#造成的原因" class="headerlink" title="造成的原因"></a>造成的原因</h2><p>问题来了，<code>click 事件</code> 什么时候触发？</p><p>浏览器在 <code>touchend</code> 之后会等待约 <code>300ms</code> ，如果没有 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vemh1emhlbndlaTkxOC9wLzc1ODg1NTMuaHRtbA==">tap 行为<i class="fa fa-external-link-alt"></i></span>，则触发 <code>click</code> 事件。</p><p>而浏览器等待约 <code>300ms</code> 的原因是，判断用户是否是<code>双击（double tap）行为</code>，双击过程中就不适合触发 click 事件了。</p><p>由此可以看出 <code>click</code> 事件触发代表一轮触摸事件的结束。</p><p>上面说到原生事件中并没有 <code>tap</code> 事件，可以参考经典的 <code>zepto.js</code> 对 <code>singleTap</code> 事件的处理。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21hZHJvYmJ5L3plcHRvL2Jsb2IvbWFzdGVyL3NyYy90b3VjaC5qcyNMMTM2LUwxNDM=">见源码 136-143 行<i class="fa fa-external-link-alt"></i></span></p><p>可以看出，<code>singleTap</code> 事件的触发时机 —— 在 <code>touchend</code> 事件响应 <code>250ms</code> 无操作后，触发 <code>singleTap</code>。</p><p>因此，点击穿透的现象就容易理解了，在这 <code>300ms</code> 以内，因为上层元素隐藏或消失了，由于 <code>click</code> 事件的滞后性，同样位置的 <code>DOM</code> 元素触发了 <code>click</code> 事件（如果是 <code>input</code> 则触发了 <code>focus</code> 事件）。在代码中，给我们的感觉就是 <code>target</code> 发生了飘移。</p><h2 id="怎样避免点击穿透"><a href="#怎样避免点击穿透" class="headerlink" title="怎样避免点击穿透"></a>怎样避免点击穿透</h2><p>理解点击穿透的原因，我们从各种途径去阻止现象的产生。</p><p>毫无疑问，能想到的方法很多，比如中间的层添加一个 <code>300ms</code> 渐隐的动画，触摸结束后阻止 <code>click</code> 事件等。</p><ol><li><p>触摸开始时<br><code>touchstart</code> 事件触发时，<code>preventDefault()</code>。毫无疑问，很容易想到这一点，而且也从根本上解决了这个问题。但是，它有一个避免不了或者说引入了很大的缺陷，页面中 <code>DOM</code> 元素无法再进行滚动了。这个方法显然不能满足我们的需求，但是这个思路其实可以给我们更多的启发，比如说 <code>iscroll</code> 只允许横向滚动的实现，相关实现这里暂且不表。</p></li><li><p>触摸结束时<br><code>touchend</code> 事件触发时，<code>preventDefault()</code>。看上去好像没有什么问题，但是，很遗憾的是不是所有的浏览器都支持。</p></li><li><p>禁止页面缩放<br>通过设置 <code>meta</code> 标签，可以禁止页面缩放，部分浏览器不再需要等待 <code>300ms</code>，导致点击穿透。点击事件仍然会触发，但相对较快，所以 <code>click</code> 事件从某种意义上来说可以取代点击事件，<br>而代价是牺牲少数用户（<code>click</code> 事件触发仍然较慢）的体验。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, user-scalable=no&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p><code>IE 10</code> 可以用 <code>CSS</code> 取消点击穿透的延迟：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  -ms-touch-action: manipulation;</span><br><span class="line">  touch-action: manipulation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>IE 11+</code> 可以用 <code>touch-action: manipulation;</code> 属性来阻止元素的双击缩放。</p></li><li><p>CSS3 的方法<br>虽然主要讲的是事件，但是有必要介绍一个 CSS3 的属性 —— <code>pointer-events</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pointer-events</span>: auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit;</span><br></pre></td></tr></table></figure><p><code>pointer-events</code> 属性有很多值，有用的主要是 <code>auto</code> 和 <code>none</code>，其他属性为 <code>SVG</code> 服务。</p><p><span class="exturl" data-url="aHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXBvaW50ZXItZXZlbnRz">查看浏览器支持情况<i class="fa fa-external-link-alt"></i></span> 可见移动端开发还是可以用的。</p><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>auto</td><td>默认值，鼠标或触屏事件不会穿透当前层</td></tr><tr><td>none</td><td>元素不再是 target，监听的元素变成了下层的元素（如果子元素设置成 auto，点击子元素会继续监听事件）</td></tr></tbody></table></li><li><p>处理点击事件 —— <code>Touch to Click</code><br>最靠谱的方案还是从点击事件的根源上解决问题。用 <code>js</code> 去判断幽冥点击，然后阻止点击穿透。这种方式显然可以实现，缺点是阻止点击穿透时需要小心，不要导致原生的 <code>HTML</code> 元素（如：链接，多选框，单选框）无法正常运行。</p><p>通过上文中介绍的 <code>touches，targetTouches，changedTouches</code> 参数，我们可以构建出这样的测试页面，可以统计出点击穿透的时间，以及已经响应的情况。</p><table><thead><tr><th></th><th>preventDefault()</th><th>preventDefault()</th><th>点击穿透时间</th><th>点击穿透时间</th><th>点击穿透区域</th><th>点击穿透区域</th></tr></thead><tbody><tr><td>Browser</td><td>touchstart</td><td>touchend</td><td>缩放页面</td><td>禁止缩放页面</td><td>缩放页面</td><td>禁止缩放页面</td></tr><tr><td>Safari Mobile iOS 5.1.1</td><td>Yes</td><td>Yes</td><td>370ms after end</td><td>370ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Safari Mobile iOS 6.1.3</td><td>Yes</td><td>Yes</td><td>370ms after end</td><td>370ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Safari Mobile iOS 7.1.1</td><td>Yes</td><td>Yes</td><td>370ms after end</td><td>370ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Android 2.3.7</td><td>Yes</td><td>No</td><td>410ms after end</td><td>410ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Android 4.0.4</td><td>Yes</td><td>No</td><td>300ms after end</td><td>10ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Android 4.1.2</td><td>Yes</td><td>No</td><td>300ms after end</td><td>300ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Android 4.2.2</td><td>Yes</td><td>No</td><td>300ms after start</td><td>10ms after end</td><td>touchstart</td><td>touchend</td></tr><tr><td>IE10 Windows Phone 8</td><td>No</td><td>No</td><td>310ms after end</td><td>10ms after end</td><td>touchend</td><td>touchend</td></tr><tr><td>Blackberry 10</td><td>Yes</td><td>Yes</td><td>260ms after end</td><td>10ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Chrome for iOS</td><td>Yes</td><td>Yes</td><td>360ms after end</td><td>360ms after end</td><td>touchstart</td><td>touchstart</td></tr><tr><td>Chrome for Android</td><td>Yes</td><td>Yes</td><td>300ms after start</td><td>10ms after end</td><td>touchstart</td><td>touchend</td></tr><tr><td>Firefox for Android</td><td>Yes</td><td>No</td><td>300ms after end</td><td>10ms after end</td><td>touchstart</td><td>touchend</td></tr></tbody></table><p>由此可以看出：</p><ul><li>点击穿透受浏览器和页面是否缩放影响</li><li>点击穿透有两种情况：快速情况有 <code>10ms</code> 慢速情况有 <code>300ms</code></li><li>在 <code>touchend</code> 时间上调用 <code>preventDefault()</code> 可以阻止多数情况的点击穿透</li></ul><p>代码上处理建议如下：</p><ul><li>在 <code>touchend</code> 事件上调用 <code>preventDefault()</code></li><li>在一次成功的点击后，建议接下来的 <code>500ms</code> 以内取消所有的 <code>click</code> 事件。</li><li>分析点击事件，判断如果是慢速点击穿透，则取消所有 <code>click</code> 事件，如果是快速点击穿透，取消触摸事件 <code>50ms</code> 以内的 <code>click</code> 事件即可。</li></ul><p>有个好消息是，移动端开发已经有人写好相应的库，帮助我们处理点击穿透。</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Z0bGFicy9mYXN0Y2xpY2s=">fastclick<i class="fa fa-external-link-alt"></i></span> 可以参考和使用。</p><p>其实现思路是，取消 <code>click</code> 事件<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Z0bGFicy9mYXN0Y2xpY2svYmxvYi9tYXN0ZXIvbGliL2Zhc3RjbGljay5qcyNMNTIxLUw2MTA=">（参看源码 164-173 行）<i class="fa fa-external-link-alt"></i></span>，用 <code>touchend</code> 模拟快速点击行为<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Z0bGFicy9mYXN0Y2xpY2svYmxvYi9tYXN0ZXIvbGliL2Zhc3RjbGljay5qcyNMMTY0LUwxNzM=">（参看源码 521-610 行）<i class="fa fa-external-link-alt"></i></span>。</p></li></ol><h2 id="原文链接"><a href="#原文链接" class="headerlink" title="原文链接"></a>原文链接</h2><p><span class="exturl" data-url="aHR0cDovL2xpdWRvbmcubWUvY29uY2x1c2lvbi90b3VjaC1kZWZlY3Qv">点击穿透<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> FE Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式和发布订阅模式的区别</title>
      <link href="357.html"/>
      <url>357.html</url>
      
        <content type="html"><![CDATA[<h2 id="观察者模式（Observer）"><a href="#观察者模式（Observer）" class="headerlink" title="观察者模式（Observer）"></a>观察者模式（Observer）</h2><p>观察者模式指的是一个对象（<code>Subject</code>）维持一系列依赖于它的对象（<code>Observer</code>），当有关状态发生变更时 <code>Subject</code> 对象则通知一系列 <code>Observer</code> 对象进行更新。</p><p>在观察者模式中，<code>Subject</code> 对象拥有添加、删除和通知一系列 <code>Observer</code> 的方法等等，而 <code>Observer</code> 对象拥有更新方法等等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//观察者模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.list = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params">ob</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.list.push(ob);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">remove</span>(<span class="params">ob</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.list.splice(<span class="built_in">this</span>.list.indexOf(<span class="built_in">this</span>.list.find(<span class="function">(<span class="params">item</span>) =&gt;</span> ob.id === item.id)), <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">notfiy</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.list.forEach(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">      i.update(i.id);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params">id</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`我是<span class="subst">$&#123;id&#125;</span>,我被通知了！`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> people1 = <span class="keyword">new</span> Observer(<span class="number">123</span>);</span><br><span class="line"><span class="keyword">let</span> people2 = <span class="keyword">new</span> Observer(<span class="number">9527</span>);</span><br><span class="line"><span class="keyword">let</span> people3 = <span class="keyword">new</span> Observer(<span class="number">89757</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sub = <span class="keyword">new</span> Subject();</span><br><span class="line"></span><br><span class="line">sub.add(people1);</span><br><span class="line">sub.add(people2);</span><br><span class="line">sub.add(people3);</span><br><span class="line"></span><br><span class="line">sub.notfiy();</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  sub.remove(people2);</span><br><span class="line">  sub.notfiy();</span><br><span class="line">&#125;, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><h2 id="发布订阅模式（Publisher-amp-amp-Subscriber）"><a href="#发布订阅模式（Publisher-amp-amp-Subscriber）" class="headerlink" title="发布订阅模式（Publisher &amp;&amp; Subscriber）"></a>发布订阅模式（Publisher &amp;&amp; Subscriber）</h2><p>发布订阅模式指的是希望接收通知的对象（<code>Subscriber</code>）基于一个 <code>主题</code> 通过自定义事件订阅主题，被激活事件的对象（<code>Publisher</code>）通过发布主题事件的方式通知各个订阅该主题的 <code>Subscriber</code> 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发布订阅模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pub</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.list = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">subscribe</span>(<span class="params">name, cb</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.list[name]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.list[name] = [];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.list[name].push(cb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">unSubscribe</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.list[name] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">publish</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> name = <span class="built_in">Array</span>.from(args).shift();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.list[name] || <span class="built_in">this</span>.list[name].length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;name&#125;</span>主题没有可发布的事件！`</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.list[name].forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      item(args);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> publisher = <span class="keyword">new</span> Pub();</span><br><span class="line"></span><br><span class="line">publisher.subscribe(<span class="string">&#x27;event1&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br><span class="line">publisher.subscribe(<span class="string">&#x27;event1&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br><span class="line">publisher.subscribe(<span class="string">&#x27;event2&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br><span class="line">publisher.subscribe(<span class="string">&#x27;event3&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">publisher.publish(<span class="string">&#x27;event1&#x27;</span>, <span class="string">&#x27;额外参数1&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  publisher.unSubscribe(<span class="string">&#x27;event2&#x27;</span>);</span><br><span class="line">  publisher.publish(<span class="string">&#x27;event2&#x27;</span>, <span class="string">&#x27;额外参数2&#x27;</span>);</span><br><span class="line">  publisher.publish(<span class="string">&#x27;event3&#x27;</span>, <span class="string">&#x27;额外参数3&#x27;</span>, <span class="string">&#x27;额外参数4&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>发布订阅模式是观察者模式的一种变体。发布订阅只是把一部分功能抽象成一个独立的 <code>ChangeManager</code>。</p><p>在「一对多」的场景下，发布者的某次更新只想通知它的部分订阅者？</p><p>在「多对一」或者「多对多」场景下。一个订阅者依赖于多个发布者，某个发布者更新后是否需要通知订阅者？还是等所有发布者都更新完毕再通知订阅者？</p><p>这些逻辑都可以放到 <code>ChangeManager</code> 里。</p><p>观察者模式中依赖于 <code>Subject</code> 对象的一系列 <code>Observer</code> 对象在被通知之后只能执行同一个特定的更新方法，而在发布订阅模式中则可以基于不同的主题去执行不同的自定义事件。相对而言，发布订阅模式比观察者模式要更加灵活多变。</p><h2 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h2><p><img data-src="http://cdn.flqin.com/p357-1.png" alt="关系图"></p>]]></content>
      
      
      <categories>
          
          <category> FE Code </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>promise 实现</title>
      <link href="358.html"/>
      <url>358.html</url>
      
        <content type="html"><![CDATA[<p><span class="exturl" data-url="aHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8=">规范<i class="fa fa-external-link-alt"></i></span> | <span class="exturl" data-url="aHR0cDovL3d3dy5pdHVyaW5nLmNvbS5jbi9hcnRpY2xlLzY2NTY2">中文解析<i class="fa fa-external-link-alt"></i></span></p><h2 id="promise-实现"><a href="#promise-实现" class="headerlink" title="promise 实现"></a>promise 实现</h2><p>相关术语及概念见上述链接，以下为 <code>promise</code> 实现:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isFunc = <span class="function">(<span class="params">obj</span>) =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">&#x27;[object Function]&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> isObj = <span class="function">(<span class="params">obj</span>) =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">&#x27;[object Object]&#x27;</span>;</span><br><span class="line"><span class="comment">// 等待态 规范 2.1.1</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line"><span class="comment">// 执行态 规范 2.1.2</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">&#x27;fulfilled&#x27;</span>;</span><br><span class="line"><span class="comment">// 拒绝态 规范 2.1.3</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.status = PENDING;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="built_in">this</span>.callbacks = [];</span><br><span class="line">    <span class="keyword">let</span> resolve = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._execCallback(FULFILLED, val);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._execCallback(REJECTED, reason);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fn(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="built_in">this</span>._reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">_execCallback</span>(<span class="params">status, val</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status !== PENDING) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.status = status;</span><br><span class="line">    <span class="built_in">this</span>.value = val;</span><br><span class="line">    <span class="built_in">this</span>.callbacks.forEach(<span class="function">(<span class="params">cb</span>) =&gt;</span> cb());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//规范 2.3 Promise 解决过程 [[Resolve]](promise, x)</span></span><br><span class="line">  <span class="function"><span class="title">_resolvePromise</span>(<span class="params">newPromise, x, resolve, reject</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (newPromise === x) &#123;</span><br><span class="line">      <span class="comment">//规范 2.3.1</span></span><br><span class="line">      <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;循环引用&#x27;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      <span class="comment">//规范 2.3.2</span></span><br><span class="line">      x.then(<span class="function">(<span class="params">y</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>._resolvePromise(newPromise, y, resolve, reject);</span><br><span class="line">      &#125;, reject);</span><br><span class="line">      <span class="comment">//规范 2.3.3</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isObj(x) || isFunc(x)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">let</span> then = <span class="literal">undefined</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//规范 2.3.3.1 把 x.then 赋值给 then</span></span><br><span class="line">        then = x.then;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="comment">//规范 2.3.3.2</span></span><br><span class="line">        <span class="keyword">return</span> reject(err);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//规范 2.3.3.3</span></span><br><span class="line">      <span class="keyword">if</span> (isFunc(then)) &#123;</span><br><span class="line">        <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          then.call(</span><br><span class="line">            x,</span><br><span class="line">            (y) =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">              called = <span class="literal">true</span>;</span><br><span class="line">              <span class="built_in">this</span>._resolvePromise(newPromise, y, resolve, reject);</span><br><span class="line">            &#125;,</span><br><span class="line">            (r) =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">              called = <span class="literal">true</span>;</span><br><span class="line">              reject(r);</span><br><span class="line">            &#125;</span><br><span class="line">          );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">          reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//规范 2.3.3.4</span></span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//规范 2.3.4</span></span><br><span class="line">      resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//规范 2.2 promise.then(onFulfilled, onRejected)</span></span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onFulfilled, onRejected</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//规范 2.2.1.1，2.2.7.3</span></span><br><span class="line">    onFulfilled = isFunc(onFulfilled) ? onFulfilled : <span class="function">(<span class="params">val</span>) =&gt;</span> val;</span><br><span class="line">    <span class="comment">// //规范 2.2.1.2，2.2.7.4</span></span><br><span class="line">    onRejected = isFunc(onRejected)</span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> fn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//规范 2.2.4, 2.2.5 onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用，且被作为函数调用（即没有 this 值）</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x = <span class="built_in">this</span>.status === FULFILLED ? onFulfilled(<span class="built_in">this</span>.value) : onRejected(<span class="built_in">this</span>.value);</span><br><span class="line">            <span class="comment">//规范 2.2.7.1</span></span><br><span class="line">            <span class="built_in">this</span>._resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">            <span class="comment">//规范 2.2.7.2</span></span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 规范 2.2.6</span></span><br><span class="line">      <span class="built_in">this</span>.status === PENDING ? <span class="built_in">this</span>.callbacks.push(fn) : fn();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 规范 2.2.7</span></span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//catch 方法</span></span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//finally 方法</span></span><br><span class="line">  <span class="function"><span class="title">finally</span>(<span class="params">cb</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(</span><br><span class="line">      (val) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> MyPromise.resolve(cb()).then(<span class="function">() =&gt;</span> val);</span><br><span class="line">      &#125;,</span><br><span class="line">      (err) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> MyPromise.resolve(cb()).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> err;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//resolve 方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">params</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve(params);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//reject 方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">err</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//all 方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">params</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">let</span> valueList = [];</span><br><span class="line">      <span class="keyword">const</span> promises = <span class="built_in">Array</span>.from(params);</span><br><span class="line">      <span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(valueList);</span><br><span class="line">      &#125;</span><br><span class="line">      promises.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!item <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          item = MyPromise.resolve(item);</span><br><span class="line">        &#125;</span><br><span class="line">        item.then(<span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">          valueList[index] = r;</span><br><span class="line">          <span class="keyword">if</span> (promises.length === ++count) &#123;</span><br><span class="line">            resolve(valueList);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, reject);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//race 方法</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">params</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> promises = <span class="built_in">Array</span>.from(params);</span><br><span class="line">      <span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve();</span><br><span class="line">      &#125;</span><br><span class="line">      promises.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!item <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">          item = MyPromise.resolve(item);</span><br><span class="line">        &#125;</span><br><span class="line">        item.then(resolve, reject);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//用于 promise test</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">deferred</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line">    result.promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      result.resolve = resolve;</span><br><span class="line">      result.reject = reject;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = MyPromise;</span><br></pre></td></tr></table></figure><h2 id="promise-测试"><a href="#promise-测试" class="headerlink" title="promise 测试"></a>promise 测试</h2><p>手写的 <code>Promise</code> 可通过<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Byb21pc2VzLWFwbHVzL3Byb21pc2VzLXRlc3Rz">promises-aplus-tests<i class="fa fa-external-link-alt"></i></span>测试是否符合规范，<code>Promise</code> 内部添加 <code>deferred</code> 静态方法并导出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">deferred</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line">  result.promise = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    result.resolve = resolve;</span><br><span class="line">    result.reject = reject;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = MyPromise;</span><br></pre></td></tr></table></figure><p>然后执行命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promises-aplus-tests MyPromise</span><br></pre></td></tr></table></figure><p><img data-src="http://cdn.flqin.com/p358-1.png" alt="测试结果"></p><h2 id="chrome-里的实现"><a href="#chrome-里的实现" class="headerlink" title="chrome 里的实现"></a>chrome 里的实现</h2><p>实践中要确保 <code>onFulfilled</code> 和 <code>onRejected</code> 方法异步执行，且应该在 <code>then</code> 方法被调用的那一轮事件循环之后的新执行栈中执行。本实现代码采用 <code>setTimeout</code>（宏任务）来实现异步任务，而 <code>chrome</code> 里的 <code>promise</code> 实现则是采用微任务（<code>%EnqueueMicrotask</code>）的方式，故略有不同。</p><p><code>chrome</code> 的 <code>promise</code> 实现参考源码版本小于 <code>5.6.100</code> 的 <span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL3Y4L3Y4LysvcmVmcy90YWdzLzUuNi4xMC9zcmMvanMvcHJvbWlzZS5qcw==">src/js/promise.js<i class="fa fa-external-link-alt"></i></span> 文件，其中 <code>PromiseEnqueue</code> 方法里的 <code>C</code> 函数 <code>%EnqueueMicrotask</code> 将 <code>PromiseHandle</code> 加入到 <code>JS运行时</code> 的微任务队列中。</p><p>其中因为 <code>chrome</code> 版本的不断迭代， 在版本 <span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL3Y4L3Y4Lytsb2cvcmVmcy90YWdzLzUuNi4xMDA=">5.6.100<i class="fa fa-external-link-alt"></i></span> 里的 <code>hash</code> 为 <span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL3Y4L3Y4LysvNmY5NGE4ZjFjN2YwYTk0Yzc0YzUwNTViMDJiNjYwZDhlOTNmZTVmZSU1RSUyMS8jRjg=">6f94a8<i class="fa fa-external-link-alt"></i></span> 的提交里重写了整个 <code>PromiseEnqueue</code>，然后在后续版本 <span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL3Y4L3Y4Lytsb2cvcmVmcy90YWdzLzYuMS4zOTU=">6.1.395<i class="fa fa-external-link-alt"></i></span> 里的 <code>hash</code> 为 <span class="exturl" data-url="aHR0cHM6Ly9jaHJvbWl1bS5nb29nbGVzb3VyY2UuY29tL3Y4L3Y4LysvYmJhNDczZGI3NDcxYTRkYzNlYTc0MDM1YzI3MGY2OGRiYzA1NjJkZQ==">bba473<i class="fa fa-external-link-alt"></i></span> 的提交里完全删除了 <code>promise.js</code>），最终由 <code>JS</code> 实现完全迭代为 <code>C</code> 开发实现。</p>]]></content>
      
      
      <categories>
          
          <category> FE Code </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>事件循环(Event Loop)</title>
      <link href="359.html"/>
      <url>359.html</url>
      
        <content type="html"><![CDATA[<p><code>javascript</code> 从诞生之日起就是一门单线程的非阻塞的脚本语言。而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如 <code>I/O</code> 事件）的时候，主线程会挂起（<code>pending</code>）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。到底是如何实现非阻塞这一点呢？答案就是 <code>事件循环(Event Loop)</code>。</p><p>当函数被调用时，会被添加到 <code>调用栈</code> 栈中的顶部，执行完成之后就从栈顶部移出该函数，直到栈内被清空。每次栈内被清空都会去读取 <code>任务队列</code> 有没有任务，有就按照顺序读取执行。如果这个时候栈中又出现了事件，该事件又去调用了 <code>WebAPIs</code> 里的异步方法，那这些异步方法会在再被调用的时候放在 <code>任务队列</code> 里，一直循环读取-执行的操作，就形成了 <code>事件循环</code>。</p><p><code>调用栈\执行栈（call stack）</code> 是一种 <code>后进先出（LIFO）</code> 的数据结构，<code>任务队列</code> 是 <code>先进先出（FIFO）</code> 的数据结构。</p><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>事件循环是通过 <code>任务队列（task queue）</code> 的机制来进行协调的。一个事件循环中，可以有一个或者多个任务队列，一个任务队列便是一系列有序任务 <code>task</code> 的集合，每个任务都有一个任务源 <code>task source</code>，源自同一个任务源的 <code>task</code> 必须放到同一个任务队列，从不同源来的则被添加到不同队列。</p><p><code>JavaScript</code> 单线程中的任务分为 <code>同步任务</code> 和 <code>异步任务</code>。同步任务会在 <code>调用栈</code> 中按照顺序排队等待<code>主线程</code>执行，异步任务则会在异步有了结果后将注册的回调函数添加到 <code>任务队列(消息队列)</code> 中等待主线程空闲（即栈内被清空）的时候读取到栈中等待主线程执行。</p><p>异步任务队列可分为 <code>task(macrotask)</code> 宏任务队列和 <code>microtask(job)</code> 微任务队列两类，不同的 <code>API</code> 注册的异步任务会依次进入自身对应的队列中，然后等待 <code>Event Loop</code> 将它们依次压入执行栈中执行，宏任务队列可以有多个，微任务队列只有一个。</p><ul><li>宏任务主要包含：<code>script(整体代码)</code>、<code>setTimeout</code>、<code>setInterval</code>、<code>I/O</code>、<code>UI交互事件</code>、<code>postMessage</code>、<code>MessageChannel</code>、<code>setImmediate(Node.js 环境)</code>、<code>requestAnimationFrame</code></li><li>微任务主要包含：<code>Promise的方法及其派生</code>、<code>MutationObserver（浏览器）</code>、<code>Object.observe(已废弃)</code><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2x1b2t1bmluZy9ibG9ncy9pc3N1ZXMvMQ==">查阅<i class="fa fa-external-link-alt"></i></span></li></ul><h2 id="浏览器中的事件循环"><a href="#浏览器中的事件循环" class="headerlink" title="浏览器中的事件循环"></a>浏览器中的事件循环</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>在事件循环中，每进行一次循环操作称为 <code>tick</code>，每一次 <code>tick</code> 的任务处理模型是比较复杂的，但关键步骤如下：</p><ul><li>在此次 <code>tick</code> 中选择最先进入队列的任务(<code>oldest task</code>)，如果有则执行(<strong>一个</strong>)，如果执行中有异步任务就放至各自的队列中</li><li>检查是否存在 <code>Microtasks</code>，如果存在则<strong>不停地执行</strong>，直至清空 <code>Microtasks Queue</code></li><li><code>UI</code> 更新渲染 <code>Update the UI rendering</code> (<code>GUI</code> 线程，<code>帧</code>开始)</li><li>取出下一个宏任务 <code>task</code>，主线程重复执行上述步骤（回到 JS 线程）</li></ul><p><img data-src="http://cdn.flqin.com/p359-2.png" alt="示意图"></p><h3 id="相关点"><a href="#相关点" class="headerlink" title="相关点"></a>相关点</h3><h4 id="await"><a href="#await" class="headerlink" title="await"></a>await</h4><p><code>await</code> 将直接使用 <code>Promise.resolve()</code> 相同语义<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI2ODAwNzk2OS9hbnN3ZXIvMzM5ODExOTk4">查阅<i class="fa fa-external-link-alt"></i></span>，即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(async2()).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(async2());</span><br><span class="line">  &#125;).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="update-rendering（更新渲染）"><a href="#update-rendering（更新渲染）" class="headerlink" title="update rendering（更新渲染）"></a>update rendering（更新渲染）</h4><p><code>update rendering（更新渲染）</code>发生在本轮事件循环的 <code>microtask</code> 队列被执行完之后（下轮事件循环执行之前），也就是说执行任务的耗时会影响视图渲染的时机。通常浏览器以每秒 60 帧（<code>60fps</code>）的速率刷新页面，这个帧率最适合人眼交互，大概 <code>16.7ms</code> 渲染一帧，所以如果要让用户觉得顺畅，单个 <code>macrotask</code> 及它相关的所有 <code>microtask</code> 最好能在 <code>16.7ms</code> 内完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="built_in">document</span>.body.style.backgroundColor = <span class="string">&#x27;red&#x27;</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Date</span>.now() - now &lt;= <span class="number">2000</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">document</span>.body.style.backgroundColor = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo();</span><br><span class="line"><span class="comment">//2s 后变成蓝色</span></span><br></pre></td></tr></table></figure><p>也不是每轮事件循环都会执行 <code>update rendering</code>，浏览器有自己的优化策略，可能把几次的视图更新累积到一起重绘。重绘之前会通知 <code>requestAnimationFrame</code> 执行回调函数，即<code>requestAnimationFrame</code> 的执行时机是在一次或多次事件循环的 <code>UI render</code> 阶段。<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc3Vuc2hxL3AvNTgwNzU3NS5odG1s">查阅 1<i class="fa fa-external-link-alt"></i></span>,<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Zod2ZyMnUwMnEvYXJ0aWNsZS9kZXRhaWxzLzc5NDkyMzAz">查阅 2<i class="fa fa-external-link-alt"></i></span></p><h4 id="life-of-a-frame"><a href="#life-of-a-frame" class="headerlink" title="life of a frame"></a>life of a frame</h4><p>浏览器页面是一帧一帧绘制出来的，每一帧（<code>Frame</code>）都需要完成哪些工作？</p><ol><li><strong>Input event</strong>：处理用户的交互，如点击、触碰、滚动等事件</li><li><strong>JS</strong>：<code>JS</code> 解析执行（可能有多个事件循环）</li><li><strong>Begin frame</strong>：帧开始，<code>更新渲染</code>开始。窗口尺寸变更(<code>resize</code>执行)，页面滚动(<code>scroll</code>执行)等的处理</li><li><strong>rAf</strong>：<code>requestAnimationFrame</code></li><li><strong>Layout</strong>：布局</li><li><strong>Paint</strong>： 绘制</li></ol><p><img data-src="http://cdn.flqin.com/p359-4.png" alt="life of a frame"></p><p>上面六个步骤完成后没超过 16 ms，说明时间有富余，此时就会执行 <code>IntersectionObserver</code> 和 <code>requestIdleCallback</code> 里注册的任务。</p><h4 id="requestAnimationFrame-amp-requestIdleCallback"><a href="#requestAnimationFrame-amp-requestIdleCallback" class="headerlink" title="requestAnimationFrame &amp; requestIdleCallback"></a>requestAnimationFrame &amp; requestIdleCallback</h4><ul><li><p><code>requestAnimationFrame</code>: 告诉浏览器在下次重绘之前执行传入的回调函数(通常是用于操纵 <code>dom</code>，更新动画的函数)；由于是每帧执行一次，那结果就是每秒的执行次数与浏览器屏幕刷新次数一样，通常是每秒 60 次。</p></li><li><p><code>requestIdleCallback</code>: 会在浏览器空闲时间执行回调，也就是允许开发人员在主事件循环中执行低优先级任务，而不影响一些延迟关键事件。如果有多个回调，会按照先进先出原则执行；但是当传入了 <code>timeout</code>，为了避免超时，有可能会打乱这个顺序；由于它发生在一帧的最后，此时页面布局已经完成，所以不建议在 <code>requestIdleCallback</code> 里再操作 <code>DOM</code>，这样会导致页面再次重绘。</p></li></ul><blockquote><p><code>Promise</code> 不建议在这里面进行，因为 <code>Promise</code> 的回调属性 <code>Event loop</code> 中优先级较高的一种微任务，会在 <code>requestIdleCallback</code> 结束时立即执行，不管此时是否还有富余的时间，这样有很大可能会让一帧超过 16 ms。</p></blockquote><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个sleep函数，模拟阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> t = <span class="built_in">Date</span>.now(); <span class="built_in">Date</span>.now() - t &lt;= d;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callself</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(++count, <span class="string">&#x27;frame&#x27;</span>)</span><br><span class="line">    sleep(<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">if</span>(count&lt;<span class="number">20</span>)&#123;</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame(callself);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当count&lt;20时候，就一直使用raf占满16ms，这样模拟一帧中无空闲时间</span></span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(callself);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cb1</span>(<span class="params">&#123;didTimeout&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;idle cb1&#x27;</span>, didTimeout)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cb2</span>(<span class="params">&#123;didTimeout&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;idle cb2&#x27;</span>, didTimeout)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cb3</span>(<span class="params">&#123;didTimeout&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;idle cb3&#x27;</span>, didTimeout)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册三个rIC回调，正常是按照先进先出原则执行这三个回调，当设置的有timeout，该回调会被提前</span></span><br><span class="line"><span class="built_in">window</span>.requestIdleCallback(cb1)</span><br><span class="line"><span class="built_in">window</span>.requestIdleCallback(cb2)</span><br><span class="line"><span class="built_in">window</span>.requestIdleCallback(cb3, &#123;</span><br><span class="line">    timeout: <span class="number">30</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="浏览器举例"><a href="#浏览器举例" class="headerlink" title="浏览器举例"></a>浏览器举例</h3><p>通过例子加深对浏览器事件循环执行顺序的理解：</p><p>eg1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> <span class="title">promise1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout1&#x27;</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> <span class="title">promise2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">setTimeout2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout2&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>eg2：</p><p>解析<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2R3cXMvYmxvZy9pc3N1ZXMvNjE=">查阅<i class="fa fa-external-link-alt"></i></span></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">t</span>) =&gt;</span> <span class="built_in">console</span>.log(t));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>eg3：</p><p>解析<span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL3EvMTAxMDAwMDAxNzgwMTMyNA==">查阅<i class="fa fa-external-link-alt"></i></span> <span class="exturl" data-url="aHR0cHM6Ly9lczYucnVhbnlpZmVuZy5jb20vI2RvY3MvcHJvbWlzZSNQcm9taXNlLXJlc29sdmU=">参照<i class="fa fa-external-link-alt"></i></span></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  resolve(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(&#123;</span><br><span class="line">    then: <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">      resolve(<span class="number">3</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">t</span>) =&gt;</span> <span class="built_in">console</span>.log(t));</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">t</span>) =&gt;</span> <span class="built_in">console</span>.log(t));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>eg4：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise3&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure><p>eg5：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> intervalA = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;intervalA&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">clearInterval</span>(intervalA);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> intervalB = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;intervalB&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> intervalC = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;intervalC&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">    i === <span class="number">9999</span> &amp;&amp; resolve();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise after for-loop&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clearInterval</span>(intervalB);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise in timeout&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise after timeout&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise4&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise5&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">clearInterval</span>(intervalC);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise3&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>);</span><br></pre></td></tr></table></figure><p>eg6：</p><p>解析<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NjA2ODE3MQ==">查阅<i class="fa fa-external-link-alt"></i></span></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout1&#x27;</span>);</span></span><br><span class="line">  &#125;, 0);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout2&#x27;</span>);</span></span><br><span class="line">  &#125;, 0);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  requestAnimationFrame(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;requestAnimationFrame&#x27;</span>);</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 输出：start promise1 end promise2 requestAnimationFrame timeout1 timeout2  --&gt;</span></span><br></pre></td></tr></table></figure><h2 id="NODE-中的事件循环-适用于-NODE-11-以下"><a href="#NODE-中的事件循环-适用于-NODE-11-以下" class="headerlink" title="NODE 中的事件循环(适用于 NODE 11 以下)"></a>NODE 中的事件循环(适用于 NODE 11 以下)</h2><p><code>Node.js</code> 采用 <code>V8</code> 作为 <code>js</code> 的解析引擎，而事件循环方面使用了自己设计的 <code>libuv</code>。<code>Node.js</code> 的事件循环核心对应 <code>libuv</code> 中的 <a href="https://github.com/libuv/libuv/blob/v1.35.0/src/unix/core.c#L365-L400"><code>uv_run</code> 函数</a>，整个事件循环迭代就是一个 <code>while</code> 无限循环。</p><blockquote><p>libuv 是使用 C 语言实现的单线程非阻塞异步 I/O 解决方案，本质上它是对常见操作系统底层异步 I/O 操作的封装，并对外暴露功能一致的 API， 首要目的是尽可能的为 nodejs 在不同系统平台上提供统一的事件循环模型。</p></blockquote><h3 id="事件循环模型"><a href="#事件循环模型" class="headerlink" title="事件循环模型"></a>事件循环模型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   ┌───────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │ 执行到期的 `setTimeout` 和 `setInterval` 回调</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │ 执行到期的一些被延迟调用的 `I/O` 回调</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │ 仅 `node` 内部使用</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │ 立即执行大部分 `I/O` 回调</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │ 执行到期的 `setImmediate` 的回调</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │ 执行注册 `close` 事件的回调，如 `socket` 等</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure><p>其中外部输入数据则从 <code>poll</code> 阶段开始。</p><ul><li><code>event loop</code> 总是要经历以上阶段，由 <code>timer</code> 阶段开始，由 <code>close</code> 回调函数阶段结束。</li><li><code>event loop</code> 的每个阶段都有一个任务队列。</li><li><code>event loop</code> 到达某个阶段时，将执行该阶段的任务队列，该任务队列完成后执行 <code>nextTick队列</code>，然后执行 <code>微任务队列</code>。直到队列清空或执行的回调达到系统上限后，才会转入下一个阶段。</li><li>当所有阶段被顺序执行一次后，称 <code>event loop</code> 完成了一个 <code>tick</code>。</li></ul><p><img data-src="http://cdn.flqin.com/p359-3.png" alt="示意图"></p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p><code>poll</code> 是一个至关重要的阶段，会做两件事情：</p><ul><li>计算当前轮询需要阻塞后续阶段（即维持）的时间：由<strong>后续 tick 各个阶段是否存在不为空的回调函数队列</strong> 和 <strong>最近的计时器时间节点</strong> 决定。若所有队列为空且不存在任何计时器，那么事件循环将 <strong>无限制地维持在 poll 阶段</strong>。其中<ul><li>对于事件循环部分属性而言:<ul><li><code>uv_stop()</code> 函数标记为停止时，不阻塞；</li><li>不处于活动状态时且不存在活动的 <code>request</code> 时，不阻塞；</li><li><code>idle</code> 句柄队列不为空时，不阻塞；</li><li><code>I/O callbacks</code> 回调队列不为空时，不阻塞；</li><li><code>closing</code> 句柄不为空时，不阻塞；</li></ul></li><li>对于计时器而言：<ul><li>若不存在任何计时器（<code>setTimeout/setInterval</code>），那么当前事件循环中的 <code>poll</code> 阶段将<strong>一直阻塞</strong></li><li>若最近计时器时间节点&lt;=开始时间，则表明在<code>计时器二叉最小</code>堆中<strong>至少存在一个</strong>过期的计时器，那么当前 <code>poll</code> 阶段的超时时间将被设置为 0 即不阻塞。这是为了尽可能快的进入下一阶段，即尽可能快地结束当前事件循环。</li><li>若最近计时器时间节点&gt;开始时间，<code>poll</code> 将根据此差值来阻塞当前阶段，阻塞是为了保持在该阶段从而尽可能快的处理异步 I/O 事件。</li></ul></li></ul></li><li>处理 <code>poll</code> 队列的事件回调（<strong>事件循环 tick 总有一种维持 poll 状态的倾向</strong>，为了尽可能快的处理随时可能到来异步 <code>I/O</code> 事件）</li></ul><p>如果 <code>poll</code> 阶段进入 <code>idle</code> 状态并且存在 <code>setImmediate</code>，那么 <code>poll</code> 阶段将打破无限制的等待状态，并进入 <code>check</code> 阶段执行 <code>setImmediate</code>。</p><blockquote><p>poll 阶段控制了计时器回调函数的执行时机：在没有满足 poll 阶段的结束条件时，就无法进入到下一个事件循环 tick 的 timer 阶段，就无法执行 timer queue 中到期计时器的回调函数。<br>因为 poll 阶段的超时时间在进入 poll 阶段之前计算，故当前 poll 阶段中回调函数队列中的计时器并不影响当前 poll 阶段的超时时间。</p></blockquote><h4 id="node-内置定时器"><a href="#node-内置定时器" class="headerlink" title="node 内置定时器"></a>node 内置定时器</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//一些代码;</span></span><br><span class="line">&#125;, timeout);</span><br></pre></td></tr></table></figure><p><code>nodejs</code> 中所有计时器是通过一个<code>双向链表</code>实现关联。有且仅有两种计时器：<code>setTimeout/setInterval</code> 和 <code>setImmediate</code>。同浏览器一致，所有的计时器实现都不能保证在到达时间阈值后回调函数一定会被立即执行，它们只能保证在到达时间阈值后，尽快执行由计时器注册的回调函数。</p><p>所有计时器在 <code>libuv</code> 中是以计时器回调函数的执行时间节点（即 <code>time + timeout</code>，而不是<code>计时器时间阈值（上述代码里的timeout）</code>）构成的<code>二叉最小堆</code>结构来存储。通过<code>二叉最小堆</code>的根节点来获取时间线上最近的 <code>timer</code> 对应的回调函数的句柄，再通过该句柄对应的 <code>timeout</code> 值获取最近的计时器的执行时间节点。</p><p>时间阈值 <code>timeout</code> 的取值范围是 <code>1 ~ 231-1 ms</code>，且为整数。所有超出时间阈值范围的时间阈值都会被重置为 <code>1ms</code>，且所有非整数值会被转换为 <code>整数值</code>。即 <code>setTimeout(callback, 0)</code> 会自动转为 <code>setTimeout(callback, 1)</code>。</p><h3 id="node-注意点"><a href="#node-注意点" class="headerlink" title="node 注意点"></a>node 注意点</h3><ul><li><code>process.nextTick()</code>: 这个函数其实是独立于 <code>Event Loop</code> 之外的，它有一个自己的队列，当 <code>每个阶段</code> 完成后，如果存在 <code>nextTick 队列</code>，就会清空队列中的所有回调函数，并且 <code>优先于其他 microtask 执行</code>。</li><li><code>setTimeout(callback, 0)</code> 和 <code>setImmediate(callback)</code> 的执行顺序是随机的，跟代码执行时间与 <code>1ms</code> 大小比较有关。而上述代码在 <code>I/0 callbacks</code> 阶段调用则执行顺序是 <code>setImmediate</code> <code>在前，setTimeout</code> 在后（第二轮）。</li></ul><h3 id="node-举例"><a href="#node-举例" class="headerlink" title="node 举例"></a>node 举例</h3><p>根据以上知识点，以下这些例子就很容易理解了：</p><p>eg1：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&#x27;test.txt&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;readFile&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">  setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;immediate&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>eg2：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timer2&#x27;</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise3&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;end&#x27;</span>);</span><br></pre></td></tr></table></figure><p>eg3：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timer1&#x27;</span>);</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick&#x27;</span>);</span><br><span class="line">  process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick&#x27;</span>);</span><br><span class="line">    process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick&#x27;</span>);</span><br><span class="line">      process.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;nextTick&#x27;</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>eg4:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">new</span> <span class="built_in">Date</span>() - startTime &lt; time) &#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1s over&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout - 1&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout - 1 - 1&#x27;</span>);</span><br><span class="line">    sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve()).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout - 1 - then&#x27;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve()).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout - 1 - then - then&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout - 2&#x27;</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout - 2 - 1&#x27;</span>);</span><br><span class="line">    sleep(<span class="number">1000</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve()).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout - 2 - then&#x27;</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> resolve()).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;setTimeout - 2 - then - then&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="node-11-版本后"><a href="#node-11-版本后" class="headerlink" title="node 11 版本后"></a>node 11 版本后</h3><p><strong>和浏览器趋同，都是每执行一个宏任务就执行完微任务队列</strong>，故上面例子在不同版本表现不一致。<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81NDk1MTU1MA==">查阅 1<i class="fa fa-external-link-alt"></i></span>,<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0FkdmFuY2VkLUZyb250ZW5kL0RhaWx5LUludGVydmlldy1RdWVzdGlvbi9pc3N1ZXMvMjY=">查阅 2<i class="fa fa-external-link-alt"></i></span></p><h2 id="两者循环区别-NODE-11-之前"><a href="#两者循环区别-NODE-11-之前" class="headerlink" title="两者循环区别(NODE 11 之前)"></a>两者循环区别(NODE 11 之前)</h2><ul><li>在浏览器中,事件循环是由 <code>macrotask、microtask</code> 组成，执行顺序是 <code>macrotask-&gt;microtask</code>。</li><li>在 <code>Node.js</code> 中，事件循环由多个 <code>阶段 phase</code> 的 <code>多个回调函数队列 callbacks queues</code> 组成。在每一个阶段执行顺序是 <code>macrotask-&gt;nextTick-&gt;microtask</code>。</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80ODUyMjI0OQ==">从 Chrome 源码看事件循环<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9zZXQuc2gvcG9zdC8yMDAzMTctaG93LW5vZGVqcy1ldmVudC1sb29wLXdvcmtz">从 libuv 看 nodejs 事件循环<i class="fa fa-external-link-alt"></i></span></li></ul>]]></content>
      
      
      <categories>
          
          <category> FE Summary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）nginx配置location总结及rewrite规则写法</title>
      <link href="356.html"/>
      <url>356.html</url>
      
        <content type="html"><![CDATA[<h2 id="nginx-介绍"><a href="#nginx-介绍" class="headerlink" title="nginx 介绍"></a>nginx 介绍</h2><p><code>nginx</code> 是一个高性能的 <code>web</code> 服务器，常用作反向代理服务器。<code>nginx</code> 作为反向代理服务器，就是把 <code>http</code> 请求转发到另一个或者一些服务器上。 通过把本地一个 <code>url</code> 前缀映射到要跨域访问的 <code>web</code> 服务器上，就可以实现跨域访问。 对于浏览器来说，访问的就是同源服务器上的一个 <code>url</code>。而 <code>nginx</code> 通过检测 <code>url</code> 前缀，把 <code>http</code> 请求转发到后面真实的物理服务器。并通过 <code>rewrite</code> 命令把前缀再去掉。这样真实的服务器就可以正确处理请求，并且并不知道这个请求是来自代理服务器的。 简单说，<code>nginx</code> 服务器欺骗了浏览器，让它认为这是同源调用，从而解决了浏览器的跨域问题。又通过重写 <code>url</code>，欺骗了真实的服务器，让它以为这个 <code>http</code> 请求是直接来自与用户浏览器的。 这样，为了解决跨域问题，只需要动一下 <code>nginx</code> 配置文件即可。简单、强大、高效!</p><h2 id="nginx-conf-配置文件"><a href="#nginx-conf-配置文件" class="headerlink" title="nginx.conf 配置文件"></a>nginx.conf 配置文件</h2><p><code>Nginx</code> 配置文件主要分成四部分：<code>main（全局设置）</code>、<code>server（主机设置）</code>、<code>upstream（上游服务器设置，主要为反向代理、负载均衡相关配置）</code>和 <code>location（URL 匹配特定位置后的设置）</code>，每部分包含若干个指令。</p><p><code>main</code> 部分设置的指令将影响其它所有部分的设置；<code>server</code>部分的指令主要用于指定虚拟主机域名、IP 和端口；<code>upstream</code> 的指令用于设置一系列的后端服务器，设置反向代理及后端服务器的负载均衡；<code>location</code> 部分用于匹配网页位置（比如，根目录“/”,“/images”,等等）。</p><p>他们之间的关系是：<code>server</code> 继承 <code>main</code>，<code>location</code> 继承 <code>server</code>，<code>upstream</code> 既不会继承指令也不会被继承。它有自己的特殊指令，不需要在其他地方的应用。</p><h3 id="通用"><a href="#通用" class="headerlink" title="通用"></a>通用</h3><p>下面的 <code>nginx.conf</code> 简单的实现 <code>nginx</code> 在前端做反向代理服务器的例子，处理 <code>js、png</code> 等静态文件，<code>jsp</code> 等动态请求转发到其它服务器 <code>tomcat</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">user  www www;</span><br><span class="line">worker_processes  2;</span><br><span class="line"></span><br><span class="line">error_log  logs&#x2F;error.log;</span><br><span class="line">#error_log  logs&#x2F;error.log  notice;</span><br><span class="line">#error_log  logs&#x2F;error.log  info;</span><br><span class="line"></span><br><span class="line">pid        logs&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    use epoll;</span><br><span class="line">    worker_connections  2048;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">    #log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">    #                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">    #                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">    #access_log  logs&#x2F;access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile        on;</span><br><span class="line">    # tcp_nopush     on;</span><br><span class="line"></span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">  # gzip压缩功能设置</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_min_length 1k;</span><br><span class="line">    gzip_buffers    4 16k;</span><br><span class="line">    gzip_http_version 1.0;</span><br><span class="line">    gzip_comp_level 6;</span><br><span class="line">    gzip_types text&#x2F;html text&#x2F;plain text&#x2F;css text&#x2F;javascript application&#x2F;json application&#x2F;javascript application&#x2F;x-javascript application&#x2F;xml;</span><br><span class="line">    gzip_vary on;</span><br><span class="line"></span><br><span class="line">  # http_proxy 设置</span><br><span class="line">    client_max_body_size   10m;</span><br><span class="line">    client_body_buffer_size   128k;</span><br><span class="line">    proxy_connect_timeout   75;</span><br><span class="line">    proxy_send_timeout   75;</span><br><span class="line">    proxy_read_timeout   75;</span><br><span class="line">    proxy_buffer_size   4k;</span><br><span class="line">    proxy_buffers   4 32k;</span><br><span class="line">    proxy_busy_buffers_size   64k;</span><br><span class="line">    proxy_temp_file_write_size  64k;</span><br><span class="line">    proxy_temp_path   &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;proxy_temp 1 2;</span><br><span class="line"></span><br><span class="line">  # 设定负载均衡后台服务器列表</span><br><span class="line">    upstream  backend  &#123;</span><br><span class="line">              #ip_hash;</span><br><span class="line">              server   192.168.10.100:8080 max_fails&#x3D;2 fail_timeout&#x3D;30s ;</span><br><span class="line">              server   192.168.10.101:8080 max_fails&#x3D;2 fail_timeout&#x3D;30s ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  # 很重要的虚拟主机配置</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  itoatest.example.com;</span><br><span class="line">        root   &#x2F;apps&#x2F;oaapp;</span><br><span class="line"></span><br><span class="line">        charset utf-8;</span><br><span class="line">        access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">        #对 &#x2F; 所有做负载均衡+反向代理</span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   &#x2F;apps&#x2F;oaapp;</span><br><span class="line">            index  index.jsp index.html index.htm;</span><br><span class="line"></span><br><span class="line">            proxy_pass        http:&#x2F;&#x2F;backend;</span><br><span class="line">            proxy_redirect off;</span><br><span class="line">            # 后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br><span class="line">            proxy_set_header  Host  $host;</span><br><span class="line">            proxy_set_header  X-Real-IP  $remote_addr;</span><br><span class="line">            proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">            proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        #静态文件，nginx自己处理，不去backend请求tomcat</span><br><span class="line">        location  ~* &#x2F;download&#x2F; &#123;</span><br><span class="line">            root &#x2F;apps&#x2F;oa&#x2F;fs;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        location ~ .*\.(gif|jpg|jpeg|bmp|png|ico|txt|js|css)$</span><br><span class="line">        &#123;</span><br><span class="line">            root &#x2F;apps&#x2F;oaapp;</span><br><span class="line">            expires      7d;</span><br><span class="line">        &#125;</span><br><span class="line">        location &#x2F;nginx_status &#123;</span><br><span class="line">            stub_status on;</span><br><span class="line">            access_log off;</span><br><span class="line">            allow 192.168.10.0&#x2F;24;</span><br><span class="line">            deny all;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location ~ ^&#x2F;(WEB-INF)&#x2F; &#123;</span><br><span class="line">            deny all;</span><br><span class="line">        &#125;</span><br><span class="line">        #error_page  404              &#x2F;404.html;</span><br><span class="line"></span><br><span class="line">        # redirect server error pages to the static page &#x2F;50x.html</span><br><span class="line">        #</span><br><span class="line">        error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">        location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ## 其它虚拟主机，server 指令开始</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常用指令说明"><a href="#常用指令说明" class="headerlink" title="常用指令说明"></a>常用指令说明</h3><h4 id="main-全局配置"><a href="#main-全局配置" class="headerlink" title="main 全局配置"></a>main 全局配置</h4><p><code>nginx</code> 在运行时与具体业务功能（比如 <code>http</code> 服务或者 <code>email</code> 服务代理）无关的一些参数，比如工作进程数，运行的身份等。</p><ul><li><p><code>woker_processes 2</code></p><p>在配置文件的顶级 <code>main</code> 部分，<code>worker</code> 角色的工作进程的个数，<code>master</code> 进程是接收并分配请求给 <code>worker</code> 处理。这个数值简单一点可以设置为 <code>cpu</code> 的核数 <code>grep ^processor /proc/cpuinfo | wc -l</code>，也是 <code>auto</code> 值，如果开启了 <code>ssl</code> 和 <code>gzip</code> 更应该设置成与逻辑 <code>CPU</code> 数量一样甚至为 2 倍，可以减少 <code>I/O</code> 操作。如果 <code>nginx</code> 服务器还有其它服务，可以考虑适当减少。</p></li><li><p><code>worker_cpu_affinity</code></p><p>也是写在 <code>main</code> 部分。在高并发情况下，通过设置 <code>cpu</code> 粘性来降低由于多 <code>CPU</code> 核切换造成的寄存器等现场重建带来的性能损耗。如 <code>worker_cpu_affinity 0001 0010 0100 1000</code>; （四核）。</p></li><li><p><code>worker_connections 2048</code></p><p>写在 <code>events</code> 部分。每一个 <code>worker</code> 进程能并发处理（发起）的最大连接数（包含与客户端或后端被代理服务器间等所有连接数）。<code>nginx</code> 作为反向代理服务器，计算公式 <code>最大连接数 = worker_processes \* worker_connections/4</code>，所以这里客户端最大连接数是 <code>1024</code>，这个可以增到到 <code>8192</code> 都没关系，看情况而定，但不能超过后面的 <code>worker_rlimit_nofile</code>。当 <code>nginx</code> 作为 <code>http</code> 服务器时，计算公式里面是除以 2。</p></li><li><p><code>worker_rlimit_nofile 10240</code></p><p>写在 <code>main</code> 部分。默认是没有设置，可以限制为操作系统最大的限制 65535。</p></li><li><p><code>use epoll</code></p><p>写在 <code>events</code> 部分。在 <code>Linux</code> 操作系统下，<code>nginx</code> 默认使用 <code>epoll</code> 事件模型，得益于此，<code>nginx</code> 在 <code>Linux</code> 操作系统下效率相当高。同时 <code>Nginx</code> 在 <code>OpenBSD</code> 或 <code>FreeBSD</code> 操作系统上采用类似于 <code>epoll</code> 的高效事件模型 <code>kqueue</code>。在操作系统不支持这些高效模型时才使用 <code>select</code>。</p></li></ul><h4 id="http-服务器"><a href="#http-服务器" class="headerlink" title="http 服务器"></a>http 服务器</h4><p>与提供 <code>http</code> 服务相关的一些配置参数。例如：是否使用 <code>keepalive</code> 啊，是否使用 <code>gzip</code> 进行压缩等。</p><ul><li><p><code>sendfile on</code></p><p>开启高效文件传输模式，<code>sendfile</code> 指令指定 <code>nginx</code> 是否调用 <code>sendfile</code> 函数来输出文件，减少用户空间到内核空间的上下文切换。对于普通应用设为 <code>on</code>，如果用来进行下载等应用磁盘 <code>IO</code> 重负载应用，可设置为 <code>off</code>，以平衡磁盘与网络 <code>I/O</code> 处理速度，降低系统的负载。</p></li><li><p><code>keepalive_timeout 65</code></p><p>长连接超时时间，单位是秒，这个参数很敏感，涉及浏览器的种类、后端服务器的超时设置、操作系统的设置，可以另外起一片文章了。长连接请求大量小文件的时候，可以减少重建连接的开销，但假如有大文件上传，65s 内没上传完成会导致失败。如果设置时间过长，用户又多，长时间保持连接会占用大量资源。</p></li><li><p><code>send_timeout</code></p><p>用于指定响应客户端的超时时间。这个超时仅限于两个连接活动之间的时间，如果超过这个时间，客户端没有任何活动，Nginx 将会关闭连接。</p></li><li><p><code>client_max_body_size 10m</code></p><p>允许客户端请求的最大单文件字节数。如果有上传较大文件，请设置它的限制值</p></li><li><p><code>client_body_buffer_size 128k</code></p><p>缓冲区代理缓冲用户端请求的最大字节数</p></li></ul><h5 id="模块-http-proxy"><a href="#模块-http-proxy" class="headerlink" title="模块 http_proxy"></a>模块 http_proxy</h5><p>这个模块实现的是 <code>nginx</code> 作为反向代理服务器的功能，包括缓存功能（另见文章）</p><ul><li><p><code>proxy_connect_timeout 60</code></p><p>nginx 跟后端服务器连接超时时间(代理连接超时)</p></li><li><p><code>proxy_read_timeout 60</code></p><p>连接成功后，与后端服务器两个成功的响应操作之间超时时间(代理接收超时)</p></li><li><p><code>proxy_buffer_size 4k</code></p><p>设置代理服务器（nginx）从后端 realserver 读取并保存用户头信息的缓冲区大小，默认与 proxy_buffers 大小相同，其实可以将这个指令值设的小一点</p></li><li><p><code>proxy_buffers 4 32k</code></p><p>proxy_buffers 缓冲区，nginx 针对单个连接缓存来自后端 realserver 的响应，网页平均在 32k 以下的话，这样设置</p></li><li><p><code>proxy_busy_buffers_size 64k</code></p><p>高负荷下缓冲大小（proxy_buffers*2）</p></li><li><p><code>proxy_max_temp_file_size</code></p><p>当 proxy_buffers 放不下后端服务器的响应内容时，会将一部分保存到硬盘的临时文件中，这个值用来设置最大临时文件大小，默认 1024M，它与 proxy_cache 没有关系。大于这个值，将从 upstream 服务器传回。设置为 0 禁用。</p></li><li><p><code>proxy_temp_file_write_size 64k</code></p><p>当缓存被代理的服务器响应到临时文件时，这个选项限制每次写临时文件的大小。proxy_temp_path（可以在编译的时候）指定写到哪那个目录。</p></li></ul><h5 id="模块-http-gzip"><a href="#模块-http-gzip" class="headerlink" title="模块 http_gzip"></a>模块 http_gzip</h5><ul><li><p><code>gzip on</code> : 开启 gzip 压缩输出，减少网络传输。</p><ul><li><code>gzip_min_length 1k</code> ： 设置允许压缩的页面最小字节数，页面字节数从 header 头得 content-length 中进行获取。默认值是 20。建议设置成大于 1k 的字节数，小于 1k 可能会越压越大。</li><li><code>gzip_buffers 4 16k</code> ： 设置系统获取几个单位的缓存用于存储 gzip 的压缩结果数据流。4 16k 代表以 16k 为单位，安装原始数据大小以 16k 为单位的 4 倍申请内存。</li><li><code>gzip_http_version 1.0</code> ： 用于识别 http 协议的版本，早期的浏览器不支持 Gzip 压缩，用户就会看到乱码，所以为了支持前期版本加上了这个选项，如果你用了 Nginx 的反向代理并期望也启用 Gzip 压缩的话，由于末端通信是 http/1.0，故请设置为 1.0。</li><li><code>gzip_comp_level 6</code> ： gzip 压缩比，1 压缩比最小处理速度最快，9 压缩比最大但处理速度最慢(传输快但比较消耗 cpu)</li><li><code>gzip_types</code> ：匹配 mime 类型进行压缩，无论是否指定,”text/html”类型总是会被压缩的。</li><li><code>gzip_proxied any</code> ： Nginx 作为反向代理的时候启用，决定开启或者关闭后端服务器返回的结果是否压缩，匹配的前提是后端服务器必须要返回包含”Via”的 header 头。</li><li><code>gzip_vary on</code> ： 和 http 头有关系，会在响应头加个 Vary: Accept-Encoding ，可以让前端的缓存服务器缓存经过 gzip 压缩的页面，例如，用 Squid 缓存经过 Nginx 压缩的数据。。</li></ul></li></ul><h4 id="server-虚拟主机"><a href="#server-虚拟主机" class="headerlink" title="server 虚拟主机"></a>server 虚拟主机</h4><p>http 服务上支持若干虚拟主机。每个虚拟主机一个对应的 server 配置项，配置项里面包含该虚拟主机相关的配置。在提供 mail 服务的代理时，也可以建立若干 server。每个 server 通过监听地址或端口来区分。</p><ul><li><code>listen</code>:监听端口，默认 80，小于 1024 的要以 root 启动。可以为 listen *:80、listen 127.0.0.1:80 等形式。</li><li><code>server_name</code>:服务器名，如 localhost、<span class="exturl" data-url="aHR0cDovL3d3dy5leGFtcGxlLmNvbSzlj6/ku6XpgJrov4fmraPliJnljLnphY0uLw==">www.example.com，可以通过正则匹配。<i class="fa fa-external-link-alt"></i></span></li></ul><h5 id="模块-http-stream"><a href="#模块-http-stream" class="headerlink" title="模块 http_stream"></a>模块 http_stream</h5><p>这个模块通过一个简单的调度算法来实现客户端 IP 到后端服务器的负载均衡，upstream 后接负载均衡器的名字，后端 realserver 以 host:port options; 方式组织在 {} 中。如果后端被代理的只有一台，也可以直接写在 proxy_pass 。</p><h4 id="location"><a href="#location" class="headerlink" title="location"></a>location</h4><p>http 服务中，某些特定的 URL 对应的一系列配置项。</p><ul><li><p><code>root /var/www/html</code></p><p>定义服务器的默认网站根目录位置。如果 locationURL 匹配的是子目录或文件，root 没什么作用，一般放在 server 指令里面或/下。</p></li><li><p><code>index.jsp index.html index.htm</code></p><p>定义路径下默认访问的文件名，一般跟着 root 放</p></li><li><p><code>proxy_pass http:/backend</code></p><p>请求转向 backend 定义的服务器列表，即反向代理，对应 upstream 负载均衡器。也可以 <code>proxy_pass http://ip:port</code>。</p></li><li><p><code>proxy_redirect off;</code></p><p><code>proxy_set_header Host \$host;</code></p><p><code>proxy_set_header X-Real-IP \$remote_addr;</code></p><p><code>proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;</code></p><p>这四个暂且这样设，如果深究的话，每一个都涉及到很复杂的内容，也将通过另一篇文章来解读。</p></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="访问控制-allow-deny"><a href="#访问控制-allow-deny" class="headerlink" title="访问控制 allow/deny"></a>访问控制 allow/deny</h4><p>Nginx 的访问控制模块默认就会安装，而且写法也非常简单，可以分别有多个 allow,deny，允许或禁止某个 ip 或 ip 段访问，依次满足任何一个规则就停止往下匹配。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;nginx-status &#123;</span><br><span class="line">  stub_status on;</span><br><span class="line">  access_log off;</span><br><span class="line">#  auth_basic   &quot;NginxStatus&quot;;</span><br><span class="line">#  auth_basic_user_file   &#x2F;usr&#x2F;local&#x2F;nginx-1.6&#x2F;htpasswd;</span><br><span class="line"></span><br><span class="line">  allow 192.168.10.100;</span><br><span class="line">  allow 172.29.73.0&#x2F;24;</span><br><span class="line">  deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也常用 httpd-devel 工具的 htpasswd 来为访问的路径设置登录密码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># htpasswd -c htpasswd admin</span><br><span class="line">New passwd:</span><br><span class="line">Re-type new password:</span><br><span class="line">Adding password for user admin</span><br><span class="line"></span><br><span class="line"># htpasswd htpasswd admin    &#x2F;&#x2F;修改admin密码</span><br><span class="line"># htpasswd htpasswd sean    &#x2F;&#x2F;多添加一个认证用户</span><br></pre></td></tr></table></figure><p>这样就生成了默认使用 CRYPT 加密的密码文件。打开上面 nginx-status 的两行注释，重启 nginx 生效。</p><h4 id="列出目录-autoindex"><a href="#列出目录-autoindex" class="headerlink" title="列出目录 autoindex"></a>列出目录 autoindex</h4><p>Nginx 默认是不允许列出整个目录的。如需此功能，打开 nginx.conf 文件，在 location，server 或 http 段中加入 autoindex on;，另外两个参数最好也加上去:</p><ul><li><p><code>autoindex_exact_size off;</code></p><p>默认为 on，显示出文件的确切大小，单位是 bytes。改为 off 后，显示出文件的大概大小，单位是 kB 或者 MB 或者 GB</p></li><li><p><code>autoindex_localtime on;</code></p><p>默认为 off，显示的文件时间为 GMT 时间。改为 on 后，显示的文件时间为文件的服务器时间</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;images &#123;</span><br><span class="line">  root   &#x2F;var&#x2F;www&#x2F;nginx-default&#x2F;images;</span><br><span class="line">  autoindex on;</span><br><span class="line">  autoindex_exact_size off;</span><br><span class="line">  autoindex_localtime on;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="重新加载-nginx-配置文件"><a href="#重新加载-nginx-配置文件" class="headerlink" title="重新加载 nginx 配置文件"></a>重新加载 nginx 配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure><h2 id="location-正则写法"><a href="#location-正则写法" class="headerlink" title="location 正则写法"></a>location 正则写法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">location  &#x3D; &#x2F; &#123;</span><br><span class="line">  # 精确匹配 &#x2F; ，主机名后面不能带任何字符串</span><br><span class="line">  [ configuration A ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location  &#x2F; &#123;</span><br><span class="line">  # 因为所有的地址都以 &#x2F; 开头，所以这条规则将匹配到所有请求</span><br><span class="line">  # 但是正则和最长字符串会优先匹配</span><br><span class="line">  [ configuration B ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F;documents&#x2F; &#123;</span><br><span class="line">  # 匹配任何以 &#x2F;documents&#x2F; 开头的地址，匹配符合以后，还要继续往下搜索</span><br><span class="line">  # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条</span><br><span class="line">  [ configuration C ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ &#x2F;documents&#x2F;Abc &#123;</span><br><span class="line">  # 匹配任何以 &#x2F;documents&#x2F;Abc 开头的地址，匹配符合以后，还要继续往下搜索</span><br><span class="line">  # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条</span><br><span class="line">  [ configuration CC ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ^~ &#x2F;images&#x2F; &#123;</span><br><span class="line">  # 匹配任何以 &#x2F;images&#x2F; 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。</span><br><span class="line">  [ configuration D ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line">  # 匹配所有以 gif,jpg或jpeg 结尾的请求</span><br><span class="line">  # 然而，所有请求 &#x2F;images&#x2F; 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则</span><br><span class="line">  [ configuration E ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F;images&#x2F; &#123;</span><br><span class="line">  # 字符匹配到 &#x2F;images&#x2F;，继续往下，会发现 ^~ 存在</span><br><span class="line">  [ configuration F ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location &#x2F;images&#x2F;abc &#123;</span><br><span class="line">  # 最长字符匹配到 &#x2F;images&#x2F;abc，继续往下，会发现 ^~ 存在</span><br><span class="line">  # F与G的放置顺序是没有关系的</span><br><span class="line">  [ configuration G ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ &#x2F;images&#x2F;abc&#x2F; &#123;</span><br><span class="line">  # 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用</span><br><span class="line">    [ configuration H ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* &#x2F;js&#x2F;.*&#x2F;\.js</span><br></pre></td></tr></table></figure><ul><li>以<code>=</code>开头表示精确匹配</li><li>如<code>A</code>中只匹配根目录结尾的请求，后面不能带任何字符串。</li><li><code>^~</code>开头表示<code>uri</code>以某个常规字符串开头，不是正则匹配</li><li><code>~</code>开头表示区分大小写的正则匹配;</li><li><code>~\*</code>开头表示不区分大小写的正则匹配</li><li><code>/</code>通用匹配, 如果没有其它匹配,任何请求都会匹配到</li><li>顺序<code>(location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ~,~* 正则顺序) &gt; (location 部分起始路径) &gt; (/)</code></li></ul><p>按照上面的 location 写法，以下的匹配示例成立:</p><ul><li>/ -&gt; config A<br>精确完全匹配，即使/index.html 也匹配不了</li><li>/downloads/download.html -&gt; config B<br>匹配 B 以后，往下没有任何匹配，采用 B</li><li>/images/1.gif -&gt; configuration D<br>匹配到 F，往下匹配到 D，停止往下</li><li>/images/abc/def -&gt; config D<br>最长匹配到 G，往下匹配 D，停止往下<br>你可以看到 任何以/images/开头的都会匹配到 D 并停止，FG 写在这里是没有任何意义的，H 是永远轮不到的，这里只是为了说明匹配顺序</li><li>/documents/document.html -&gt; config C<br>匹配到 C，往下没有任何匹配，采用 C</li><li>/documents/1.jpg -&gt; configuration E<br>匹配到 C，往下正则匹配到 E</li><li>/documents/Abc.jpg -&gt; config CC<br>最长匹配到 C，往下正则顺序匹配到 CC，不会往下到 E</li></ul><p>实际使用建议</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">所以实际使用中，个人觉得至少有三个匹配规则定义，如下：</span><br><span class="line">#直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。</span><br><span class="line">#这里是直接转发给后端应用服务器了，也可以是一个静态首页</span><br><span class="line"># 第一个必选规则</span><br><span class="line">location &#x3D; &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;tomcat:8080&#x2F;index</span><br><span class="line">&#125;</span><br><span class="line"># 第二个必选规则是处理静态文件请求，这是nginx作为http服务器的强项</span><br><span class="line"># 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用</span><br><span class="line">location ^~ &#x2F;static&#x2F; &#123;</span><br><span class="line">    root &#x2F;webroot&#x2F;static&#x2F;;</span><br><span class="line">&#125;</span><br><span class="line">location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123;</span><br><span class="line">    root &#x2F;webroot&#x2F;res&#x2F;;</span><br><span class="line">&#125;</span><br><span class="line">#第三个规则就是通用规则，用来转发动态请求到后端应用服务器</span><br><span class="line">#非静态文件请求就默认是动态请求，自己根据实际把握</span><br><span class="line">#毕竟目前的一些框架的流行，带.php,.jsp后缀的情况很少了</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;tomcat:8080&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Rewrite-规则"><a href="#Rewrite-规则" class="headerlink" title="Rewrite 规则"></a>Rewrite 规则</h2><p><code>rewrite</code>使用<code>nginx</code>提供的全局变量或自己设置的变量，结合<code>正则表达式</code>和<code>标志位</code>实现 url 重写以及重定向。</p><p><code>rewrite</code> 只能放在 <code>server&#123;&#125;,location&#123;&#125;,if&#123;&#125;</code>中，并且只能对域名后边的除去传递的参数外的字符串起作用，例如 <code>http://seanlook.com/a/we/index.php?id=1&amp;u=str</code> 只对<code>/a/we/index.php</code> 重写。</p><p>如果相对域名或参数字符串起作用，可以使用全局变量匹配，也可以使用 <code>proxy_pass</code> 反向代理。</p><p>表明看 <code>rewrite</code> 和 <code>location</code> 功能有点像，都能实现跳转，主要区别在于 <code>rewrite</code> 是在同一域名内更改获取资源的路径，而 <code>location</code> 是对一类路径做控制访问或反向代理，可以 <code>proxy_pass</code> 到其他机器。很多情况下 <code>rewrite</code> 也会写在 <code>location</code> 里，它们的执行顺序是：</p><ul><li>执行 <code>server</code> 块的 <code>rewrite</code> 指令</li><li>执行 location 匹配</li><li>执行选定的 location 中的 rewrite 指令</li></ul><p>如果其中某步 <code>URI</code> 被重写，则重新循环执行 <code>1-3</code>，直到找到真实存在的文件；循环超过 10 次，则返回 500 Internal Server Error 错误。</p><h3 id="flag-标志位"><a href="#flag-标志位" class="headerlink" title="flag 标志位"></a>flag 标志位</h3><ul><li><code>last</code> : 相当于 Apache 的<code>[L]</code>标记，表示完成 rewrite</li><li><code>break</code> : 停止执行当前虚拟主机的后续 rewrite 指令集</li><li><code>redirect</code> : 返回 302 临时重定向，地址栏会显示跳转后的地址</li><li><code>permanent</code> : 返回 301 永久重定向，地址栏会显示跳转后的地址</li></ul><p>因为 301 和 302 不能简单的只返回状态码，还必须有重定向的 URL，这就是 return 指令无法返回 301,302 的原因了。这里 last 和 break 区别有点难以理解：</p><ul><li>last 一般写在 server 和 if 中，而 break 一般使用在 location 中</li><li>last 不终止重写后的 url 匹配，即新的 url 会再从 server 走一遍匹配流程，而 break 终止重写后的匹配</li><li>break 和 last 都能阻止继续执行后面的 rewrite 指令</li></ul><h3 id="if-指令与全局变量"><a href="#if-指令与全局变量" class="headerlink" title="if 指令与全局变量"></a>if 指令与全局变量</h3><h4 id="if-判断指令"><a href="#if-判断指令" class="headerlink" title="if 判断指令"></a>if 判断指令</h4><p>语法为 <code>if(condition)&#123;...&#125;</code>，对给定的条件 <code>condition</code> 进行判断。如果为真，大括号内的 <code>rewrite</code> 指令将被执行，if 条件(<code>conditon</code>)可以是如下任何内容：</p><ul><li>当表达式只是一个变量时，如果值为空或任何以 0 开头的字符串都会当做 false</li><li>直接比较变量和内容时，使用<code>=或!=</code></li><li><code>~</code>正则表达式匹配，<code>~\*</code>不区分大小写的匹配，<code>!~</code>区分大小写的不匹配</li><li><code>-f 和!-f</code> 用来判断是否存在文件</li><li>`-d 和!-d 用来判断是否存在目录</li><li><code>-e 和!-e</code> 用来判断是否存在文件或目录</li><li><code>-x 和!-x</code> 用来判断文件是否可执行</li></ul><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">if ($http_user_agent ~ MSIE) &#123;</span><br><span class="line">    rewrite ^(.*)$ &#x2F;msie&#x2F;$1 break;</span><br><span class="line">&#125; &#x2F;&#x2F;如果UA包含&quot;MSIE&quot;，rewrite请求到&#x2F;msid&#x2F;目录下</span><br><span class="line"></span><br><span class="line">if ($http_cookie ~* &quot;id&#x3D;([^;]+)(?:;|$)&quot;) &#123;</span><br><span class="line">    set $id $1;</span><br><span class="line"> &#125; &#x2F;&#x2F;如果cookie匹配正则，设置变量$id等于正则引用部分</span><br><span class="line"></span><br><span class="line">if ($request_method &#x3D; POST) &#123;</span><br><span class="line">    return 405;</span><br><span class="line">&#125; &#x2F;&#x2F;如果提交方法为POST，则返回状态405（Method not allowed）。return不能返回301,302</span><br><span class="line"></span><br><span class="line">if ($slow) &#123;</span><br><span class="line">    limit_rate 10k;</span><br><span class="line">&#125; &#x2F;&#x2F;限速，$slow可以通过 set 指令设置</span><br><span class="line"></span><br><span class="line">if (!-f $request_filename)&#123;</span><br><span class="line">    break;</span><br><span class="line">    proxy_pass  http:&#x2F;&#x2F;127.0.0.1;</span><br><span class="line">&#125; &#x2F;&#x2F;如果请求的文件名不存在，则反向代理到localhost 。这里的break也是停止rewrite检查</span><br><span class="line"></span><br><span class="line">if ($args ~ post&#x3D;140)&#123;</span><br><span class="line">    rewrite ^ http:&#x2F;&#x2F;example.com&#x2F; permanent;</span><br><span class="line">&#125; &#x2F;&#x2F;如果query string中包含&quot;post&#x3D;140&quot;，永久重定向到example.com</span><br><span class="line"></span><br><span class="line">location ~* \.(gif|jpg|png|swf|flv)$ &#123;</span><br><span class="line">    valid_referers none blocked www.jefflei.com www.leizhenfang.com;</span><br><span class="line">    if ($invalid_referer) &#123;</span><br><span class="line">        return 404;</span><br><span class="line">    &#125; &#x2F;&#x2F;防盗链</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>下面是可以用作 if 判断的全局变量:</p><ul><li><code>$args</code> ： #这个变量等于请求行中的参数，同$query_string</li><li><code>$content_length</code> ： 请求头中的 Content-length 字段。</li><li><code>$content_type</code> ： 请求头中的 Content-Type 字段。</li><li><code>$document_root</code> ： 当前请求在 root 指令中指定的值。</li><li><code>$host</code> ： 请求主机头字段，否则为服务器名称。</li><li><code>$http_user_agent</code> ： 客户端 agent 信息</li><li><code>$http_cookie</code> ： 客户端 cookie 信息</li><li><code>$limit_rate</code> ： 这个变量可以限制连接速率。</li><li><code>$request_method</code> ： 客户端请求的动作，通常为 GET 或 POST。</li><li><code>$remote_addr</code> ： 客户端的 IP 地址。</li><li><code>$remote_port</code> ： 客户端的端口。</li><li><code>$remote_user</code> ： 已经经过 Auth Basic Module 验证的用户名。</li><li><code>$request_filename</code> ： 当前请求的文件路径，由 root 或 alias 指令与 URI 请求生成。</li><li><code>$scheme</code> ： HTTP 方法（如 http，https）。</li><li><code>$server_protocol</code> ： 请求使用的协议，通常是 HTTP/1.0 或 HTTP/1.1。</li><li><code>$server_addr</code> ： 服务器地址，在完成一次系统调用后可以确定这个值。</li><li><code>$server_name</code> ： 服务器名称。</li><li><code>$server_port</code> ： 请求到达服务器的端口号。</li><li><code>$request_uri</code> ： 包含请求参数的原始 URI，不包含主机名，如：”/foo/bar.php?arg=baz”。</li><li><code>$uri</code> ： 不带请求参数的当前 URI，$uri 不包含主机名，如”/foo/bar.html”。</li><li><code>$document_uri</code> ： 与$uri 相同。</li></ul><p>例：<code>http://localhost:88/test1/test2/test.php</code></p><ul><li><code>$host</code>：<code>localhost</code></li><li><code>$server_port</code>：<code>88</code></li><li><code>$request_uri</code>：<code>http://localhost:88/test1/test2/test.php</code></li><li><code>$document_uri</code>：<code>/test1/test2/test.php</code></li><li><code>$document_root</code>：<code>/var/www/html</code></li><li><code>$request_filename</code>：<code>/var/www/html/test1/test2/test.php</code></li></ul><h4 id="rewrite-实例"><a href="#rewrite-实例" class="headerlink" title="rewrite 实例"></a>rewrite 实例</h4><p>例 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">http &#123; # 定义 image 日志格式</span><br><span class="line">log_format imagelog &#39;[$time_local] &#39; $image_file &#39; &#39; $image_type &#39; &#39; $body_bytes_sent &#39; &#39; $status; # 开启重写日志</span><br><span class="line">rewrite_log on;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        root &#x2F;home&#x2F;www;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">                # 重写规则信息</span><br><span class="line">                error_log logs&#x2F;rewrite.log notice;</span><br><span class="line">                # 注意这里要用‘’单引号引起来，避免&#123;&#125;</span><br><span class="line">                rewrite &#39;^&#x2F;images&#x2F;([a-z]&#123;2&#125;)&#x2F;([a-z0-9]&#123;5&#125;)&#x2F;(.*)\.(png|jpg|gif)$&#39; &#x2F;data?file&#x3D;$3.$4;</span><br><span class="line">                # 注意不能在上面这条规则后面加上“last”参数，否则下面的set指令不会执行</span><br><span class="line">                set $image_file $3;</span><br><span class="line">                set $image_type $4;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location &#x2F;data &#123;</span><br><span class="line">                # 指定针对图片的日志格式，来分析图片类型和大小</span><br><span class="line">                access_log logs&#x2F;images.log mian;</span><br><span class="line">                root &#x2F;data&#x2F;images;</span><br><span class="line">                # 应用前面定义的变量。判断首先文件在不在，不在再判断目录在不在，如果还不在就跳转到最后一个url里</span><br><span class="line">                try_files &#x2F;$arg_file &#x2F;image404.html;</span><br><span class="line">        &#125;</span><br><span class="line">        location &#x3D; &#x2F;image404.html &#123;</span><br><span class="line">                # 图片不存在返回特定的信息</span><br><span class="line">                return 404 &quot;image not found\n&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对形如<code>/images/ef/uh7b3/test.png</code> 的请求，重写到<code>/data?file=test.png</code>，于是匹配到 <code>location /data</code>，先看<code>/data/images/test.png</code> 文件存不存在，如果存在则正常响应，如果不存在则重写 <code>tryfiles</code> 到新的 <code>image404 location</code>，直接返回 <code>404</code> 状态码。</p><p>例 2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewrite ^&#x2F;images&#x2F;(.\*)\_(\d+)x(\d+)\.(png|jpg|gif)$ &#x2F;resizer&#x2F;$1.$4?width&#x3D;$2&amp;height&#x3D;\$3? last;</span><br></pre></td></tr></table></figure><p>对形如<code>/images/bla_500x400.jpg</code> 的文件请求，重写到<code>/resizer/bla.jpg?width=500&amp;height=400</code> 地址，并会继续尝试匹配 <code>location</code>。</p><p>例 3：</p><p><span class="exturl" data-url="aHR0cDovL3NlYW5sb29rLmNvbS8yMDE1LzA1LzI4L25naW54LXNzbC8=">ssl 部分页面加密<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> FE Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>深浅拷贝总结</title>
      <link href="355.html"/>
      <url>355.html</url>
      
        <content type="html"><![CDATA[<h2 id="深浅拷贝的区分"><a href="#深浅拷贝的区分" class="headerlink" title="深浅拷贝的区分"></a>深浅拷贝的区分</h2><p>深浅拷贝，只针对复杂数据类型来说的。</p><h3 id="浅拷贝-ShallowCopy"><a href="#浅拷贝-ShallowCopy" class="headerlink" title="浅拷贝 (ShallowCopy)"></a>浅拷贝 (ShallowCopy)</h3><p>是一个对象的逐位副本。创建一个新对象，该对象具有原始对象中的精确副本。如果对象的任何字段是对其他对象的引用，则只复制引用地址，即只复制内存地址，而不复制对象本身，新旧对象还是共享同一块堆内存。改变其中一个对象，另一个也会受影响。如果有修改，会失去原始数据。</p><h3 id="深拷贝-DeepCopy"><a href="#深拷贝-DeepCopy" class="headerlink" title="深拷贝 (DeepCopy)"></a>深拷贝 (DeepCopy)</h3><p>复制出一个全新的对象实例，新对象跟原对象不共享内存，两者操作互不影响。</p><p><strong>深拷贝是一个很复杂的问题，边缘 case 太多，比如<code>环引</code>、<code>原生 DOM/BOM对象</code>、<code>RegExp</code>、<code>Date</code>、<code>包装类Number,String,Boolean</code> 、<code>函数</code>、<code>原型链</code>、<code>不可枚举的属性</code>、<code>set/map/weakset/weakmap</code>、<code>Symbol</code>等，很多深拷贝如<code>函数</code>、<code>RegExp</code>等在实际运用中都没有多大意义，如果在开发中遇到需要深拷贝的地方，首先考虑代码设计问题，它面对的问题往往可以用更优雅的方式解决。</strong></p><h2 id="浅拷贝方法"><a href="#浅拷贝方法" class="headerlink" title="浅拷贝方法"></a>浅拷贝方法</h2><h3 id="直接赋值"><a href="#直接赋值" class="headerlink" title="直接赋值"></a>直接赋值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = o1;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">o1.a = <span class="number">2</span>;</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o2.a); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(b === a); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Array-concat"><a href="#Array-concat" class="headerlink" title="Array.concat()"></a>Array.concat()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = [<span class="number">1</span>, [<span class="number">2</span>], <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> o2 = o1.concat(); <span class="comment">// 这里会返回一个o1对象的浅拷贝对象</span></span><br><span class="line"><span class="built_in">console</span>.log(o2); <span class="comment">//  [1, [2], 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(o1 === o2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Array-slice"><a href="#Array-slice" class="headerlink" title="Array.slice()"></a>Array.slice()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = [<span class="number">1</span>, [<span class="number">2</span>], <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> o2 = o1.slice(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(o2); <span class="comment">// [1, [2], 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(o1 === o2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p><code>Object.assign()</code> 方法用于将所有可枚举的自有属性的值从一个或多个源对象复制到目标对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span>, <span class="attr">d</span>: <span class="number">3</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">Object</span>.assign(&#123;&#125;, o1);</span><br><span class="line"><span class="built_in">console</span>.log(o1); <span class="comment">// &#123; a : 1, b : &#123; c : 2, d : 3&#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o2); <span class="comment">// &#123; a : 1, b : &#123; c : 2, d : 3&#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o2 === o1); <span class="comment">// false    说明实现了浅拷贝</span></span><br></pre></td></tr></table></figure><h2 id="深拷贝方法"><a href="#深拷贝方法" class="headerlink" title="深拷贝方法"></a>深拷贝方法</h2><h3 id="手动拷贝"><a href="#手动拷贝" class="headerlink" title="手动拷贝"></a>手动拷贝</h3><p>将每个引用对象都通过复制值来实现深拷贝。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123; <span class="attr">a</span>: o1.a, <span class="attr">b</span>: o1.b &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o2 === o1); <span class="comment">// false</span></span><br><span class="line">o1.a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o1); <span class="comment">// &#123;a: 2, b: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o2); <span class="comment">// &#123;a: 1, b: 2&#125;</span></span><br></pre></td></tr></table></figure><p>该方法只适合简单的对象，并且没有引用的属性，适用范围很窄。</p><h3 id="JSON-parse-JSON-stringify-（常用）"><a href="#JSON-parse-JSON-stringify-（常用）" class="headerlink" title="JSON.parse(JSON.stringify()) （常用）"></a>JSON.parse(JSON.stringify()) （常用）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123; <span class="attr">c</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(o1));</span><br><span class="line"><span class="built_in">console</span>.log(o1 === o2); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(o1.b === o2.b); <span class="comment">// false</span></span><br><span class="line">o1.b.c = <span class="number">22</span>;</span><br><span class="line">o1.a = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o1); <span class="comment">//   &#123; a : 11, b : &#123; c : 22&#125; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(o2); <span class="comment">//   &#123; a : 1, b : &#123; c : 2&#125; &#125;</span></span><br></pre></td></tr></table></figure><ul><li>该方法只能深拷贝对象和数组，内部递归实现，毕竟 <code>JSON</code> 的两个方法本身就只是用来转换 <code>js</code> 内的对象为 <code>JSON</code> 格式</li><li><code>Set</code> 类型、<code>Map</code> 类型以及 <code>Buffer</code> 类型会被转换成 {}</li><li><code>undefined</code>、任意的函数以及 <code>symbol</code> 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 <code>null</code>（出现在数组中时）</li><li>对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误</li><li>所有以 <code>symbol</code> 为属性键的属性都会被完全忽略掉，即便 <code>replacer</code> 参数中强制指定包含了它们</li><li>不可枚举的属性会被忽略</li></ul><h3 id="迭代递归法（常用）"><a href="#迭代递归法（常用）" class="headerlink" title="迭代递归法（常用）"></a>迭代递归法（常用）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(x) === <span class="string">&#x27;[object Object]&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(obj)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;obj 不是一个对象！&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> isArray = <span class="built_in">Array</span>.isArray(obj);</span><br><span class="line">  <span class="keyword">let</span> cloneObj = isArray ? [] : &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      cloneObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cloneObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法存在的问题：</p><ul><li>适合一般 <code>对象</code> 和 <code>数组</code> 的拷贝</li><li>层级太深时容易爆栈</li><li>未考虑 <code>func,date,reg,err,Map,Set,Symbol,原型链，不可枚举</code> 等 <code>case</code></li><li>未考虑循环引用</li></ul><h3 id="循环法"><a href="#循环法" class="headerlink" title="循环法"></a>循环法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保持引用关系</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneForce</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// =============</span></span><br><span class="line">  <span class="keyword">const</span> uniqueList = []; <span class="comment">// 用来去重</span></span><br><span class="line">  <span class="comment">// =============</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> root = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 循环数组</span></span><br><span class="line">  <span class="keyword">const</span> loopList = [</span><br><span class="line">    &#123;</span><br><span class="line">      parent: root,</span><br><span class="line">      key: <span class="literal">undefined</span>,</span><br><span class="line">      data: x,</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (loopList.length) &#123;</span><br><span class="line">    <span class="comment">// 广度优先</span></span><br><span class="line">    <span class="keyword">const</span> node = loopList.pop();</span><br><span class="line">    <span class="keyword">const</span> parent = node.parent;</span><br><span class="line">    <span class="keyword">const</span> key = node.key;</span><br><span class="line">    <span class="keyword">const</span> data = node.data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化赋值目标，key为undefined则拷贝到父元素，否则拷贝到子元素</span></span><br><span class="line">    <span class="keyword">let</span> res = parent;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> key !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">      res = parent[key] = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// =============</span></span><br><span class="line">    <span class="comment">// 数据已经存在</span></span><br><span class="line">    <span class="keyword">let</span> uniqueData = find(uniqueList, data);</span><br><span class="line">    <span class="keyword">if</span> (uniqueData) &#123;</span><br><span class="line">      parent[key] = uniqueData.target;</span><br><span class="line">      <span class="keyword">continue</span>; <span class="comment">// 中断本次循环</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据不存在</span></span><br><span class="line">    <span class="comment">// 保存源数据，在拷贝数据中对应的引用</span></span><br><span class="line">    uniqueList.push(&#123;</span><br><span class="line">      source: data,</span><br><span class="line">      target: res,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// =============</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> data) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data.hasOwnProperty(k)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> data[k] === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">          <span class="comment">// 下一次循环</span></span><br><span class="line">          loopList.push(&#123;</span><br><span class="line">            parent: res,</span><br><span class="line">            key: k,</span><br><span class="line">            data: data[k],</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          res[k] = data[k];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">arr, item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i].source === item) &#123;</span><br><span class="line">      <span class="keyword">return</span> arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>该方法未采用递归，采用循环的方式遍历，不会爆栈。</li><li>解决了循环引用的问题。</li><li>未考虑 <code>func,date,reg,err,Map,Set,Symbol,原型链，不可枚举</code> 等 <code>case</code></li></ul><h3 id="结构化克隆方法"><a href="#结构化克隆方法" class="headerlink" title="结构化克隆方法"></a>结构化克隆方法</h3><p>结构化算法嗦支持的拷贝类型见<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvR3VpZGUvQVBJL0RPTS9UaGVfc3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG0=">文档<i class="fa fa-external-link-alt"></i></span></p><h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage()"></a>postMessage()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">structuralClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;port1, port2&#125; = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">    port2.onmessage = <span class="function"><span class="params">ev</span> =&gt;</span> resolve(ev.data);</span><br><span class="line">    port1.postMessage(obj);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="keyword">const</span> clone = <span class="keyword">await</span> structuralClone(obj);</span><br></pre></td></tr></table></figure><p>特点：异步、兼容性 ok</p><h4 id="Notification-API"><a href="#Notification-API" class="headerlink" title="Notification API"></a>Notification API</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">structuralClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Notification(<span class="string">&#x27;&#x27;</span>, &#123;<span class="attr">data</span>: obj, <span class="attr">silent</span>: <span class="literal">true</span>&#125;).data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="keyword">const</span> clone = structuralClone(obj);</span><br></pre></td></tr></table></figure><p>特点：简洁、兼容性不佳（<code>safari</code> 全系列不支持）</p><h4 id="History-API"><a href="#History-API" class="headerlink" title="History API"></a>History API</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">structuralClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldState = history.state;</span><br><span class="line">  history.replaceState(obj, <span class="built_in">document</span>.title);</span><br><span class="line">  <span class="keyword">const</span> copy = history.state;</span><br><span class="line">  history.replaceState(oldState, <span class="built_in">document</span>.title);</span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="keyword">const</span> clone = structuralClone(obj);</span><br></pre></td></tr></table></figure><p>特点：<code>Safari</code> 对 <code>replaceState</code> 调用的限制数量为 30 秒内 100 次。</p><h2 id="深拷贝中其他类型的拷贝"><a href="#深拷贝中其他类型的拷贝" class="headerlink" title="深拷贝中其他类型的拷贝"></a>深拷贝中其他类型的拷贝</h2><h3 id="拷贝-Symbol"><a href="#拷贝-Symbol" class="headerlink" title="拷贝 Symbol"></a>拷贝 Symbol</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接 迭代递归法</span></span><br><span class="line"><span class="keyword">let</span> symKeys = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"><span class="keyword">if</span> (symKeys.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  symKeys.forEach(<span class="function">(<span class="params">symKey</span>) =&gt;</span> &#123;</span><br><span class="line">    cloneObj[symKey] = isObject(obj[symKey]) ? deepClone(obj[symKey]) : obj[symKey];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拷贝原型上的属性"><a href="#拷贝原型上的属性" class="headerlink" title="拷贝原型上的属性"></a>拷贝原型上的属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cloneObj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj));</span><br></pre></td></tr></table></figure><h3 id="拷贝不可枚举的属性"><a href="#拷贝不可枚举的属性" class="headerlink" title="拷贝不可枚举的属性"></a>拷贝不可枚举的属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cloneObj = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj), <span class="built_in">Object</span>.getOwnPropertyDescriptors());</span><br></pre></td></tr></table></figure><h3 id="拷贝-Map-Set"><a href="#拷贝-Map-Set" class="headerlink" title="拷贝 Map,Set"></a>拷贝 Map,Set</h3><h3 id="拷贝原始值和包装类"><a href="#拷贝原始值和包装类" class="headerlink" title="拷贝原始值和包装类"></a>拷贝原始值和包装类</h3><h4 id="等号直接赋值"><a href="#等号直接赋值" class="headerlink" title="等号直接赋值"></a>等号直接赋值</h4><h4 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h4><h3 id="拷贝-Date-对象"><a href="#拷贝-Date-对象" class="headerlink" title="拷贝 Date 对象"></a>拷贝 Date 对象</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(<span class="keyword">new</span> <span class="built_in">Date</span>().valueOf());</span><br></pre></td></tr></table></figure><h3 id="拷贝正则"><a href="#拷贝正则" class="headerlink" title="拷贝正则"></a>拷贝正则</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reFlags = <span class="regexp">/\w*$/</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cloneRegExp</span>(<span class="params">regexp</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回当前匹配的文本</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> regexp.constructor(regexp.source, reFlags.exec(regexp));</span><br><span class="line">  <span class="comment">// 下一次匹配的起始索引</span></span><br><span class="line">  result.lastIndex = regexp.lastIndex;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拷贝函数，Err"><a href="#拷贝函数，Err" class="headerlink" title="拷贝函数，Err"></a>拷贝函数，Err</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cloneObj = <span class="built_in">eval</span>(obj[k].toString());</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">cloneObj = obj[k].bind();</span><br></pre></td></tr></table></figure><h3 id="拷贝-Map-WeakMap-Set-WeakSet"><a href="#拷贝-Map-WeakMap-Set-WeakSet" class="headerlink" title="拷贝 Map,WeakMap,Set,WeakSet"></a>拷贝 Map,WeakMap,Set,WeakSet</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采用遍历for...of 或者 forEach</span></span><br><span class="line"><span class="comment">//如果是Map,WeakMap</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> newS = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">s.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  newS.add(item);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是Set,WeakSet</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">&#x27;x&#x27;</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">&#x27;y&#x27;</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">&#x27;z&#x27;</span>],</span><br><span class="line">]);</span><br><span class="line"><span class="keyword">let</span> newM = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">m.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> &#123;</span><br><span class="line">  newM.set(key, value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="更多参考-lodash"><a href="#更多参考-lodash" class="headerlink" title="更多参考 lodash"></a>更多参考 lodash</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xvZGFzaC9sb2Rhc2gvYmxvYi9tYXN0ZXIvLmludGVybmFsL2Jhc2VDbG9uZS5qcw==">链接<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> FE Code </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS Grid布局</title>
      <link href="353.html"/>
      <url>353.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是-grid"><a href="#什么是-grid" class="headerlink" title="什么是 grid"></a>什么是 grid</h2><p>网格布局（<code>Grid</code>）是最强大的 <code>CSS</code> 布局方案。它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。浏览器支持程度<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2FuaXVzZS5jb20vI3NlYXJjaD1ncmlk">查阅<i class="fa fa-external-link-alt"></i></span>。</p><p>设为网格布局以后，容器子元素的 <code>float</code>、<code>display: inline-block</code>、<code>display: table-cell</code>、<code>vertical-align</code> 和 <code>column-*</code>等设置都将失效。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">display</span>: inline-grid; <span class="comment">/* 行内元素 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><p>以下属性设置在 <code>grid</code> 布局中的父元素（即设有 <code>display:grid</code> 的元素），用来控制内部子元素的行为。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  grid-template-<span class="attribute">columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  grid-template-rows: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>grid-template-columns/grid-template-rows</code> 定义每一列的列宽/每一行的行宽</p><ul><li><code>none</code> 所有的列和其大小都将由 <code>grid-auto-columns</code> 属性隐式的指定。</li><li><code>fr</code> 表示比例关系,按比例分配剩余的可用空间</li><li><code>auto</code> 由浏览器自己决定长度</li><li><code>&lt;length&gt;</code> 非负值的长度大小</li><li><code>&lt;percentage&gt;</code> 非负值且相对于网格容器的百分比</li><li><code>repeat(&lt;number&gt;|auto-fill|auto-fit,value)</code> 重复设置。第一个参数是重复次数，第二个参数是重复的值。<code>auto-fill</code>指容纳尽可能多的子元素。</li><li><code>minmax(min, max)</code> 表示长度范围</li></ul></li><li><p><code>column-gap/row-gap/gap</code> 定义列间距/行间距/两者合并简写(<code>&lt;row-gap&gt; &lt;column-gap&gt;</code>,简写若省略第二个值，即表示跟第一个值一样)</p><ul><li><code>&lt;length&gt;</code> 非负值的长度大小</li><li><code>&lt;percentage&gt;</code> 非负值列之间的间隔大小</li></ul></li><li><p><code>grid-auto-flow</code> 定义子元素排列顺序是先行后列还是先列后行</p><ul><li><code>row(默认)</code> 先行后列</li><li><code>column</code> 先列后行</li><li><code>row dense</code> 先行后列,并且尽量填满空格</li><li><code>column dense</code> 先列后行,并且尽量填满空格</li></ul></li><li><p><code>justify-items/align-items/place-items</code> 定义子元素内容水平位置（左中右）/垂直位置（上中下）/两者合并简写（<code>&lt;align-items&gt; &lt;justify-items&gt;</code>,简写若省略第二个值，即表示跟第一个值一样）</p><ul><li><code>stretch(默认)</code> 拉伸，占满单元格的整个宽度</li><li><code>start</code> 对齐单元格的起始边缘</li><li><code>end</code> 对齐单元格的结束边缘</li><li><code>center</code> 单元格内部居中</li></ul></li><li><p><code>justify-content/align-content/place-content</code> 定义整个内容在容器里的水平位置（左中右）/垂直位置（上中下）/两者合并简写（<code>&lt;align-content&gt; &lt;justify-content&gt;</code>简写若省略第二个值，即表示跟第一个值一样）</p><ul><li><code>start</code> 对齐容器的起始边框</li><li><code>end</code> 对齐容器的结束边框</li><li><code>center</code> 容器内部居中</li><li><code>stretch</code> 项目大小没有指定时，拉伸占据整个网格容器</li><li><code>space-around</code> 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍</li><li><code>space-between</code> 项目与项目的间隔相等，项目与容器边框之间没有间隔</li><li><code>space-evenly</code> 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔</li></ul></li><li><p><code>grid-auto-columns/grid-auto-rows</code> 定义浏览器自动创建的多余网格的列宽和行高，取值与<code>grid-template-columns/grid-template-rows</code>相同。</p></li><li><p><code>grid-template-areas</code> 定义区域，一个区域由单个或多个单元格组成。如果某些区域不需要利用，则使用”点”（<code>.</code>）表示。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grid-template-areas:</span><br><span class="line">  <span class="string">&#x27;header header header&#x27;</span></span><br><span class="line">  <span class="string">&#x27;main main sidebar&#x27;</span></span><br><span class="line">  <span class="string">&#x27;footer footer footer&#x27;</span>;</span><br></pre></td></tr></table></figure><p>区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</p></li></ul><h2 id="容器内子元素的属性"><a href="#容器内子元素的属性" class="headerlink" title="容器内子元素的属性"></a>容器内子元素的属性</h2><ul><li><p><code>grid-column-start/grid-column-end/grid-row-start/grid-row-end</code> 定义子元素的<code>左边框/右边框/上边框/下边框</code>的网格线。</p><ul><li><code>&lt;number&gt;</code> 指定第几根网格线</li><li><code>&lt;网格线名字&gt;</code> 直接指定网格线名字如（<code>区域名-start</code>）</li><li><code>span &lt;number&gt;</code> 指跨越多少个网格</li></ul></li><li><p><code>grid-column/grid-row</code> 分别是<code>grid-column-start,grid-column-end</code>,<code>grid-row-start,grid-row-end</code>的合并简写（<code>&lt;start&gt; / &lt;end&gt;</code>）,斜杠以及后面的部分可以省略，默认跨越一个网格。</p></li><li><p><code>grid-area</code> 指定子元素放在哪一个区域。也作为<code>grid-row-start、grid-column-start、grid-row-end、grid-column-end</code>的合并简写:<code>grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;</code></p></li><li><p><code>justify-self/align-self/place-self</code>定义某个单独的子元素内容水平位置（左中右）/垂直位置（上中下）/两者合并简写（<code>&lt;align-items&gt; &lt;justify-items&gt;</code>,简写若省略第二个值，即表示跟第一个值一样）。</p><ul><li>用法取值跟<code>justify-items/align-items/place-items</code>一样，只是作用于单个子元素。</li></ul></li></ul><blockquote><p>参考：<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTkvMDMvZ3JpZC1sYXlvdXQtdHV0b3JpYWwuaHRtbA==">CSS Grid 网格布局教程<i class="fa fa-external-link-alt"></i></span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> FE Css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）chrome provisional headers are shown 是什么意思</title>
      <link href="352.html"/>
      <url>352.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载来源 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzAwOTgwNzUxODgyNTE4ODA1YWRkODM=">provisional headers are shown 知多少<i class="fa fa-external-link-alt"></i></span></p></blockquote><p>启发的一篇文章(<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjExNzczODcvY2F1dGlvbi1wcm92aXNpb25hbC1oZWFkZXJzLWFyZS1zaG93bi1pbi1jaHJvbWUtZGVidWdnZXI=">详情点击<i class="fa fa-external-link-alt"></i></span>)。</p><p>摘抄部分如下：</p><blockquote><p>The resource could be being blocked by an extension (AdBlock in my case).The message is there because the request to retrieve that resource was never made, so the headers being shown are not the real thing. As explained in the issue you referenced, the real headers are updated when the server responds, but there is no response if the request was blocked.</p></blockquote><p>资源可能被一些扩展程序拦截 。</p><p>另外还有一句：</p><blockquote><p>I believe it happens when the actual request is not sent. Usually happens when you are loading a cached resource.</p></blockquote><p>真正请求并未被发送，当使用缓存时经常发生。</p><p>之所以会出现这个信息是因为获取相关资源的请求并没有发出，所以 <code>headers</code> 被展示并不是真正的信息。</p><p>就像提到的那样，真正的 <code>header</code> 只有在服务端返回的时候会更新。当请求被拦截后，并没有返回。</p><p>基于这个情况开始猜测原因所在：</p><h3 id="猜测一、请求跨域被拦截"><a href="#猜测一、请求跨域被拦截" class="headerlink" title="猜测一、请求跨域被拦截"></a>猜测一、请求跨域被拦截</h3><p>虽然现在网站的静态资源都会存在专门的静态域名下面，和 <code>html</code> 域名可能不一致。</p><p>但是基本都是基于 <code>CORS</code> 来解决这个问题，所以不存在这个问题。</p><p>再有就是，我们这种情况首次请求的时候不会发生，如果有跨域，应该都被 <code>block</code>。</p><p>另外如果是被拦截，那么请求应该不会被响应的，我们这里显然得到了正确的响应。<br>这种被排除。</p><h3 id="猜测二、服务器未及时响应"><a href="#猜测二、服务器未及时响应" class="headerlink" title="猜测二、服务器未及时响应"></a>猜测二、服务器未及时响应</h3><p>这种猜测和一差不多，特定情况下才会出现，跟服务器关联不大。</p><h3 id="猜测三、被扩展程序拦截"><a href="#猜测三、被扩展程序拦截" class="headerlink" title="猜测三、被扩展程序拦截"></a>猜测三、被扩展程序拦截</h3><p>作为一个开发人员，大家的 <code>chrome</code> 上肯定装了不少的插件。这种原因还是有可能的。</p><p>我们可以通过 <code>chrome://net-export/</code> 来根据关键字查找相关请求，然后具体去看相关状态。</p><h3 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h3><p>结合上面的分析，我们可以缩小到缓存上面。冲着这个目标，我们继续去看下相关资料。</p><p>最后在一篇<span class="exturl" data-url="aHR0cHM6Ly9kaWQybWVtby5uZXQvMjAxNy8wMS8yMy9jaHJvbWUtZGV2dG9vbHMtcHJvdmlzaW9uYWwtaGVhZGVycy1hcmUtc2hvd24v">日文资料<i class="fa fa-external-link-alt"></i></span>里找到了相关解释。</p><p>似乎只从缓存中获得的通信显示为“显示临时标题”（或“执行”）。</p><p>因为该文件是从缓存中获取的，并且未进行通信。</p><p>所以详细标头并不会显示。</p><h3 id="原因：未与服务端正确通信"><a href="#原因：未与服务端正确通信" class="headerlink" title="原因：未与服务端正确通信"></a>原因：未与服务端正确通信</h3><p>回过头来看，前面提到的那么多情况其实都是与服务器没有进行或者完成正确的通信，所以只展示临时信息。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>provisional headers are shown</code> 出现的情况有这么几种：</p><ul><li>跨域，请求被浏览器拦截</li><li>请求被浏览器插件拦截</li><li>服务器出错或者超时，没有真正的返回</li><li>强缓存 <code>from disk cache</code> 或者 <code>from memory cache</code>，此时也不会显示</li></ul>]]></content>
      
      
      <categories>
          
          <category> FE Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JS遍历对象的方式</title>
      <link href="351.html"/>
      <url>351.html</url>
      
        <content type="html"><![CDATA[<h2 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for..in 循环"></a>for..in 循环</h2><ul><li>返回的是所有 <code>可枚举</code> 的属性，包括 <code>实例</code> 和 <code>原型</code> 上的属性。</li><li>如果只需要获取对象的实例属性，可以联合使用 <code>hasOwnProperty()</code> 进行过滤（过滤后等价 <code>Object.keys()</code>）。</li><li>不建议用来遍历 <code>数组</code> <span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTAwNTA0L3doeS1pcy11c2luZy1mb3ItaW4td2l0aC1hcnJheS1pdGVyYXRpb24tYS1iYWQtaWRlYQ==">查阅<i class="fa fa-external-link-alt"></i></span></li><li>注意 <code>for</code> 中的闭包问题</li></ul><h2 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h2><ul><li>返回的<code>实例</code>里<code>可枚举</code>的<code>属性</code>的<code>数组</code>，不包括 <code>原型</code>。</li><li><code>Object.values()</code> 返回<code>实例</code>里<code>可枚举</code>的<code>属性值</code>的<code>数组</code>，不包括<code>原型</code>。</li><li><code>Object.entries()</code> 返回<code>实例</code>里<code>可枚举</code>的<code>键值对</code>的<code>数组</code>，不包括<code>原型</code>。</li></ul><h2 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h2><ul><li>返回的<code>实例</code>里<code>所有</code>属性的数组，包括不可枚举属性，但不包括<code>Symbol</code>(注：<code>Symbol</code>可枚举)，但不会获取原型上的属性。</li><li><code>Object.getOwnPropertySymbols()</code> 返回自身的<code>Symol</code>属性。</li></ul><h2 id="Reflect-ownKeys"><a href="#Reflect-ownKeys" class="headerlink" title="Reflect.ownKeys()"></a>Reflect.ownKeys()</h2><ul><li>返回的<code>实例</code>里<code>所有</code>属性的数组，包括不可枚举属性和<code>Symbol</code>。但不会获取原型上的属性。</li><li>基本等于 <code>Object.getOwnPropertySymbols</code>+<code>Object.getOwnPropertyNames</code></li></ul><h2 id="题外话：for-of"><a href="#题外话：for-of" class="headerlink" title="题外话：for..of"></a>题外话：for..of</h2><ul><li>适用范围：<code>iterable</code>（<code>Array, Map, Set, arguments</code> 等）</li><li>返回迭代器<code>属性值</code></li><li>扩展运算符<code>（...）</code>内部使用 <code>for...of</code> 循环</li></ul>]]></content>
      
      
      <categories>
          
          <category> FE Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>babel7.4配置总结</title>
      <link href="350.html"/>
      <url>350.html</url>
      
        <content type="html"><![CDATA[<h2 id="本文适用版本"><a href="#本文适用版本" class="headerlink" title="本文适用版本"></a>本文适用版本</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot;@babel/core&quot;: &quot;^7.4.4&quot;,</span><br><span class="line">&quot;@babel/plugin-transform-runtime&quot;: &quot;^7.4.4&quot;,</span><br><span class="line">&quot;@babel/preset-env&quot;: &quot;^7.4.5&quot;,</span><br><span class="line">&quot;@babel/runtime&quot;: &quot;^7.4.5&quot;,</span><br><span class="line">&quot;@babel/runtime-corejs2&quot;: &quot;^7.4.5&quot;,</span><br><span class="line">&quot;@babel/runtime-corejs3&quot;: &quot;^7.4.5&quot;,</span><br><span class="line">&quot;babel-loader&quot;: &quot;^8.0.6&quot;,</span><br><span class="line">&quot;core-js&quot;: &quot;^3.1.4&quot;,</span><br><span class="line">&quot;regenerator-runtime&quot;: &quot;^0.13.2&quot;,</span><br><span class="line">&quot;webpack&quot;: &quot;^4.17.1&quot;,</span><br><span class="line">&quot;webpack-cli&quot;: &quot;^3.1.0&quot;</span><br></pre></td></tr></table></figure><h2 id="什么是-babel"><a href="#什么是-babel" class="headerlink" title="什么是 babel"></a>什么是 babel</h2><p><code>babel</code> 把 <code>JavaScript</code> 中 <code>es2015/2016/2017/2046</code> 的新语法转化为 <code>es5</code>，让低端运行环境(如浏览器和 <code>node</code>)能够认识并执行。</p><h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><p><code>babel</code> 总共分为三个阶段：解析，转换，生成。</p><p><code>babel</code> 本身不具有任何转化功能，它把转化的功能都分解到一个个 <code>plugin</code> 里面。因此当我们不配置任何插件时，经过 <code>babel</code> 的代码和输入是相同的。</p><h2 id="Plugin"><a href="#Plugin" class="headerlink" title="Plugin"></a>Plugin</h2><ol><li>语法插件(<code>@babel/parser</code>):使得 <code>babel</code> 能够解析更多的语法。</li><li>转译插件:源码转换并输出。</li></ol><h2 id="Preset"><a href="#Preset" class="headerlink" title="Preset"></a>Preset</h2><p><code>preset</code> 即一组官方推荐的预设插件的集合。目前推荐使用 <code>@babel/preset-env</code>。</p><h2 id="Plugin-和-Preset-执行顺序"><a href="#Plugin-和-Preset-执行顺序" class="headerlink" title="Plugin 和 Preset 执行顺序"></a>Plugin 和 Preset 执行顺序</h2><ul><li><code>Plugin</code> 会运行在 <code>Preset</code> 之前。</li><li><code>Plugin</code> 会从前到后顺序执行。</li><li><code>Preset</code> 的顺序则 刚好相反(从后向前)。</li></ul><h2 id="browserslist"><a href="#browserslist" class="headerlink" title="browserslist"></a>browserslist</h2><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Jyb3dzZXJzbGlzdC9icm93c2Vyc2xpc3Q=">browserslist<i class="fa fa-external-link-alt"></i></span> 是在不同的前端工具之间共用目标浏览器和 <code>node</code> 版本的配置工具,中文<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YjhjZmYzMjZmYjlhMDE5ZmQxNDc0ZDY=">参阅<i class="fa fa-external-link-alt"></i></span>。浏览器特性支持可查询<span class="exturl" data-url="aHR0cHM6Ly9jYW5pdXNlLmNvbS8=">caniuse<i class="fa fa-external-link-alt"></i></span>。</p><p>eg:package.json</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;browserslist&quot;: [</span><br><span class="line">  &quot;last 1 version&quot;,</span><br><span class="line">  &quot;&gt; 1%&quot;,</span><br><span class="line">  &quot;maintained node versions&quot;,</span><br><span class="line">  <span class="string">&quot;not dead&quot;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="各-babel-包介绍"><a href="#各-babel-包介绍" class="headerlink" title="各 babel 包介绍"></a>各 babel 包介绍</h2><h3 id="babel-core"><a href="#babel-core" class="headerlink" title="@babel/core"></a>@babel/core</h3><p><code>babel</code> 的编译核心包，内置 <code>helpers</code> 插件模块，是语法转换的主要辅助工具，所谓 <code>babel</code> 版本多少就是指这个包的版本多少。</p><h3 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h3><p><code>webpack</code> 中使用 <code>babel</code> 加载文件。</p><h3 id="babel-preset-env"><a href="#babel-preset-env" class="headerlink" title="@babel/preset-env"></a>@babel/preset-env</h3><ol><li>文档<span class="exturl" data-url="aHR0cHM6Ly9iYWJlbGpzLmlvL2RvY3MvZW4vbmV4dC9iYWJlbC1wcmVzZXQtZW52">查阅<i class="fa fa-external-link-alt"></i></span></li><li><code>@babel/preset-env</code> 是一个智能预设，集合了一系列常用插件，会根据 <code>browserslist</code> 设置的目标浏览器，自动将代码中的新特性转换成目标浏览器支持的代码。</li><li>默认的 <code>@babel/preset-env</code> 是无法转换新的 <code>API</code>，比如 <code>Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise</code> 等全局对象，以及一些定义在全局对象上的方法(比如 <code>Object.assign</code>)都不会转码。需要根据需要添加 <code>core-js</code> 包和 <code>regenerator-runtime</code> 包支持。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i core-js egenerator-runtime</span><br></pre></td></tr></table></figure><p><code>babel.config.js</code>配置:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&#x27;@babel/env&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        targets: &#123;</span><br><span class="line">          browsers: [<span class="string">&#x27;&gt; 1%&#x27;</span>, <span class="string">&#x27;last 2 versions&#x27;</span>, <span class="string">&#x27;not dead&#x27;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        modules: <span class="literal">false</span>, <span class="comment">//取值可以是 amd, umd, systemjs, commonjs 和 false,为false时可以用于webpack做tree shaking。</span></span><br><span class="line">        useBuiltIns: <span class="string">&#x27;usage&#x27;</span>, <span class="comment">// usage-按需引入 entry-入口引入（代码里需手动引入core-js） false-不引入</span></span><br><span class="line">        corejs: <span class="number">3</span>, <span class="comment">// 2-corejs@2  3-corejs@3</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="core-js"><a href="#core-js" class="headerlink" title="core-js"></a>core-js</h3><ol><li>文档<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi9tYXN0ZXIvZG9jcy8yMDE5LTAzLTE5LWNvcmUtanMtMy1iYWJlbC1hbmQtYS1sb29rLWludG8tdGhlLWZ1dHVyZS5tZA==">查阅<i class="fa fa-external-link-alt"></i></span></li><li><code>JavaScript</code> 标准库的 <code>polyfill</code>，目前提供 <code>core-js</code>，<code>core-js-pure</code>，<code>core-js-bundle</code> 3 个版本。</li><li>可直接项目里引用各种 <code>polyfill</code>。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// polyfill all `core-js` features:</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;core-js&#x27;</span>;</span><br><span class="line"><span class="comment">// polyfill only stable `core-js` features - ES and web standards:</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;core-js/stable&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="regenerator-runtime"><a href="#regenerator-runtime" class="headerlink" title="regenerator-runtime"></a>regenerator-runtime</h3><ol><li><code>regenerator-runtime</code> 模块来自 <code>facebook</code> 的 <code>regenerator</code> 模块。</li><li>生成器函数、<code>async</code>、<code>await</code> 函数经 <code>babel</code> 编译后，<code>regenerator-runtime</code> 模块用于提供功能实现。</li><li>源码<span class="exturl" data-url="aHR0cHM6Ly9zY2hpZnJlZC5pdGV5ZS5jb20vYmxvZy8yMzY5MzIw">查阅<i class="fa fa-external-link-alt"></i></span></li></ol><h3 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="@babel/polyfill"></a>@babel/polyfill</h3><p><code>babel</code> 7.4 版本已<span class="exturl" data-url="aHR0cHM6Ly9iYWJlbGpzLmlvL2RvY3MvZW4vYmFiZWwtcG9seWZpbGw=">废弃<i class="fa fa-external-link-alt"></i></span>，因为他仅仅依赖了 <code>core-js</code> 和 <code>regenerator-runtime</code>,安装这两个就可以了。</p><h3 id="babel-runtime-babel-runtime-corejs2-babel-runtime-corejs3"><a href="#babel-runtime-babel-runtime-corejs2-babel-runtime-corejs3" class="headerlink" title="@babel/runtime/@babel/runtime-corejs2/@babel/runtime-corejs3"></a>@babel/runtime/@babel/runtime-corejs2/@babel/runtime-corejs3</h3><ol><li><code>@babel/runtime</code> 提供 <code>helpers</code> 函数，并会去安装 <code>regenerator-runtime</code> 包，只做语法转换(<code>helpers</code> 和 <code>regenerator</code>)， 没有新 <code>api</code> 的实现。</li><li><code>@babel/runtime-corejs2</code> 包含 <code>@babel/runtime</code> 的全部并额外安装 <code>core-js@2</code></li><li><code>@babel/runtime-corejs3</code> 包含 <code>@babel/runtime</code> 的全部并额外安装 <code>core-js-pure@3</code></li><li>相比之下 <code>@babel/runtime-corejs3</code> 支持更多，包括实例，api 等。</li><li>三者均需要与 <code>@babel/plugin-transform-runtime</code> 搭配使用（但 <code>@babel/plugin-transform-runtime</code> 不一定要和他们用）。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [<span class="string">&#x27;@babel/env&#x27;</span>],</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&#x27;@babel/plugin-transform-runtime&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        corejs: <span class="number">3</span>, <span class="comment">//为false就安装 npm i @babel/runtime,为2就安装@babel/runtime-corejs2，为3就安装@babel/runtime-corejs3</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="babel-plugin-transform-runtime"><a href="#babel-plugin-transform-runtime" class="headerlink" title="@babel/plugin-transform-runtime"></a>@babel/plugin-transform-runtime</h3><ol><li>对 <code>Babel</code> 编译过程中产生的 <code>helper</code> 方法进行重新利用(聚合)，以达到减少打包体积的目的.</li><li>避免全局补丁污染，对打包过的 <code>bundler</code> 提供”沙箱”式的补丁。</li><li>文档<span class="exturl" data-url="aHR0cHM6Ly9iYWJlbGpzLmlvL2RvY3MvZW4vbmV4dC9iYWJlbC1wbHVnaW4tdHJhbnNmb3JtLXJ1bnRpbWU=">查阅<i class="fa fa-external-link-alt"></i></span></li></ol><h2 id="两种最优方案"><a href="#两种最优方案" class="headerlink" title="两种最优方案"></a>两种最优方案</h2><h3 id="使用-corejs-useBuiltIns"><a href="#使用-corejs-useBuiltIns" class="headerlink" title="使用 corejs+useBuiltIns"></a>使用 corejs+useBuiltIns</h3><p><code>npm</code> 安装：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i @babel/core @babel/preset-env @babel/plugin-transform-runtime -D</span><br><span class="line">npm i core-js regenerator-runtime</span><br></pre></td></tr></table></figure><p><code>babel.config.js</code> 配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&#x27;@babel/env&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        targets: &#123;</span><br><span class="line">          browsers: [<span class="string">&#x27;&gt; 1%&#x27;</span>, <span class="string">&#x27;last 2 versions&#x27;</span>, <span class="string">&#x27;not dead&#x27;</span>],</span><br><span class="line">        &#125;,</span><br><span class="line">        useBuiltIns: <span class="string">&#x27;usage&#x27;</span>,</span><br><span class="line">        corejs: <span class="number">3</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">  plugins: [[<span class="string">&#x27;@babel/plugin-transform-runtime&#x27;</span>]],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>该方案支持所有，包括转译语法，<code>API</code> 及实例方法的 <code>polyfill</code>。</li><li>该方案会污染全局。</li></ol><h3 id="使用-runtime-corejs3"><a href="#使用-runtime-corejs3" class="headerlink" title="使用 runtime-corejs3"></a>使用 runtime-corejs3</h3><p><code>npm</code> 安装：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i @babel/core @babel/preset-env @babel/plugin-transform-runtime -D</span><br><span class="line">npm i @babel/runtime-corejs3</span><br></pre></td></tr></table></figure><p><code>babel.config.js</code> 配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&#x27;@babel/env&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        targets: &#123;</span><br><span class="line">          browsers: [<span class="string">&#x27;&gt; 1%&#x27;</span>, <span class="string">&#x27;last 2 versions&#x27;</span>, <span class="string">&#x27;not dead&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  plugins: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&#x27;@babel/plugin-transform-runtime&#x27;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        corejs: <span class="number">3</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li>该方案支持所有，包括转译语法，<code>API</code> 及实例方法的 <code>polyfill</code>。</li><li>该方案不会污染全局。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><code>Babel</code> 版本号&lt; 7.4.0<ul><li>开发类库：<code>@babel/runtime</code></li><li>内部项目：@babel/polyfill</li></ul></li><li><code>Babel</code> 版本号&gt;= 7.4.0<ul><li><code>@babel/runtime-corejs3</code></li></ul></li><li>这文档都是坑爹的,网上的各种经验也都是之前的某个版本的总结，<code>babel</code> 包变化很快，最好的还是去看源码，和多测试不同包的效果，自己摸索体验。</li></ol>]]></content>
      
      
      <categories>
          
          <category> FE Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>var let const fn变量提升</title>
      <link href="349.html"/>
      <url>349.html</url>
      
        <content type="html"><![CDATA[<p><code>JS</code> 变量的声明分为 <code>创建create</code>、<code>初始化initialize</code> 和 <code>赋值assign</code>。</p><h2 id="var-声明的过程"><a href="#var-声明的过程" class="headerlink" title="var 声明的过程"></a>var 声明的过程</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><ol><li>进入 <code>fn</code>，为 <code>fn</code> 创建一个环境。</li><li>找到 <code>fn</code> 中所有用 <code>var</code> 声明的变量，在这个环境中「创建」这些变量（即 <code>x</code> 和 <code>y</code>）。</li><li>将这些变量「初始化」为 <code>undefined</code>。</li><li>开始执行代码</li><li><code>x = 1</code> 将 <code>x</code> 变量「赋值」为 <code>1</code></li><li><code>y = 2</code> 将 <code>y</code> 变量「赋值」为 <code>2</code></li></ol><h3 id="var-例-1"><a href="#var-例-1" class="headerlink" title="var 例 1"></a>var 例 1</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;zky&#x27;</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> name === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&#x27;xq&#x27;</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>, name);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><ol><li>在自执行的 <code>function</code> 里的 <code>var</code> 经过变量提升，先初始化 <code>name</code> 为 <code>undefined</code>。</li><li>然后在第二步则打印 <code>1，xq</code>。</li></ol><h2 id="function-声明过程"><a href="#function-声明过程" class="headerlink" title="function 声明过程"></a>function 声明过程</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">fn2()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>找到所有用 <code>function</code> 声明的变量，在环境中「创建」这些变量。</li><li>将这些变量「初始化」并「赋值」为 <code>function()&#123; console.log(2) &#125;</code>。</li><li>开始执行代码 <code>fn2()</code></li></ol><h2 id="let-声明过程"><a href="#let-声明过程" class="headerlink" title="let 声明过程"></a>let 声明过程</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">  x = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>找到所有用 <code>let</code> 声明的变量，在环境中「创建」这些变量</li><li>开始执行代码（注意现在还没有初始化）</li><li>执行 <code>x = 1</code>，将 <code>x</code> 「初始化」为 1（这并不是一次赋值，如果代码是 <code>let x</code>，就将 <code>x</code> 初始化 <code>4</code>.为 <code>undefined</code>）</li><li>执行 <code>x = 2</code>，对 <code>x</code> 进行「赋值」</li></ol><h3 id="例-1"><a href="#例-1" class="headerlink" title="例 1"></a>例 1</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="string">&#x27;global&#x27;</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">// Uncaught ReferenceError: x is not defined</span></span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>console.log(x)</code> 中的 <code>x</code> 指的是下面的 <code>x</code>，而不是全局的 <code>x</code></li><li>执行 <code>log</code> 时 <code>x</code> 还没「初始化」，所以不能使用（也就是所谓的暂时死区）</li></ol><h3 id="例-2"><a href="#例-2" class="headerlink" title="例 2"></a>例 2</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> liList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;li&#x27;</span>); <span class="comment">// 共5个li</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; liList.length; i++) &#123;</span><br><span class="line">  liList[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>for( let i = 0; i&lt; 5; i++)</code> 这句话的圆括号之间，有一个隐藏的作用域</li><li><code>for( let i = 0; i&lt; 5; i++) &#123; 循环体 &#125;</code> 在每次执行循环体之前，<code>JS</code> 引擎会把 <code>i</code> 在循环体的上下文中重新声明及初始化一次（即 <code>let/const</code> 在与 <code>for</code> 一起用时，会有一个 <code>perIterationBindings</code> 的概念）。</li></ol><p>可理解为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> liList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;li&#x27;</span>); <span class="comment">// 共5个li</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; liList.length; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = 隐藏作用域中的i;</span><br><span class="line">  liList[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="例-3"><a href="#例-3" class="headerlink" title="例 3"></a>例 3</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = x; <span class="comment">// Uncaught ReferenceError: x is not defined</span></span><br><span class="line"><span class="keyword">let</span> x; <span class="comment">//Identifier &#x27;x&#x27; has already been declared</span></span><br></pre></td></tr></table></figure><ol><li>如果 <code>let x</code> 的初始化过程失败了,<code>x</code> 变量就将永远处于 <code>created</code> 状态。</li><li>无法再次对 <code>x</code> 进行初始化, <code>x</code> 永远处在暂时性死区.</li></ol><blockquote><p>当程序的控制流程在新的作用域（module function 或 block 作用域）进行实例化时，在此作用域中用 let/const 声明的变量会先在作用域中被创建出来，但因此时还未进行词法绑定，所以是不能被访问的，如果访问就会抛出错误。因此，在这运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时性死区。</p></blockquote><h2 id="const-声明过程"><a href="#const-声明过程" class="headerlink" title="const 声明过程"></a>const 声明过程</h2><p><code>const</code> 过程跟 <code>let</code> 一样，但 <code>const</code> 只有「创建」和「初始化」，没有「赋值」过程。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><code>let、const</code> 的「创建」过程被提升了，但是初始化没有提升。</li><li><code>var</code> 的「创建」和「初始化」都被提升了。</li><li><code>function</code> 的「创建」「初始化」和「赋值」都被提升了。</li></ol><p><img data-src="http://cdn.flqin.com/p349-1.jpg" alt="git命令总结"></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yODE0MDQ1MA==">我用了两个月的时间才理解 let<i class="fa fa-external-link-alt"></i></span></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> FE Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>amd,umd,commonJs,ES6模块的相关总结</title>
      <link href="348.html"/>
      <url>348.html</url>
      
        <content type="html"><![CDATA[<h2 id="AMD-CMD-模块（requireJS-seaJs）（即将退出历史舞台）"><a href="#AMD-CMD-模块（requireJS-seaJs）（即将退出历史舞台）" class="headerlink" title="AMD/CMD 模块（requireJS/seaJs）（即将退出历史舞台）"></a>AMD/CMD 模块（requireJS/seaJs）（即将退出历史舞台）</h2><ul><li><code>AMD</code>（<code>Asynchronous Module Definition</code> 异步模块定义）和 <code>CMD</code>（<code>Common Module Definition</code> 通用模块定义）是基于浏览器使用并且是<code>异步执行</code></li><li><code>AMD</code> 推崇依赖前置，在定义模块的时候就要声明其依赖的模块</li><li><code>CMD</code> 推崇就近依赖，只有在用到某个模块的时候再去 <code>require</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AMD</span></span><br><span class="line"><span class="comment">// 定义模块 myModule.js</span></span><br><span class="line">define([<span class="string">&#x27;dependency&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;Byron&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    printName: printName,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;myModule&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">my</span>) </span>&#123;</span><br><span class="line">  my.printName();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// CMD</span></span><br><span class="line"><span class="comment">// 定义模块  myModule.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;jquery.js&#x27;</span>);</span><br><span class="line">  $(<span class="string">&#x27;div&#x27;</span>).addClass(<span class="string">&#x27;active&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载模块</span></span><br><span class="line">seajs.use([<span class="string">&#x27;myModule.js&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">my</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><ul><li><code>AMD</code> 在加载模块完成后就会执行改模块，所有模块都加载执行完后会进入 <code>require</code> 的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行。</li><li><code>CMD</code> 加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到 <code>require</code> 语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。</li></ul><h2 id="commonJS-模块（nodejs）"><a href="#commonJS-模块（nodejs）" class="headerlink" title="commonJS 模块（nodejs）"></a>commonJS 模块（nodejs）</h2><ul><li>使用 <code>require</code> 来引入其他模块的代码，使用 <code>module.exports</code> 来引出。</li><li><code>exports</code> 与 <code>module.exports</code> 的初始指针相同，即 <code>module.exports === exports</code>,如果 <code>exports</code> 一旦指向了其他对象，即不能用于导出。</li><li>运行时加载，输出的是一个值的拷贝。</li></ul><h3 id="值的拷贝"><a href="#值的拷贝" class="headerlink" title="值的拷贝"></a>值的拷贝</h3><p><code>require</code> 引入的是值的拷贝(基本类型拷贝值，引用类型拷贝地址)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.js</span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">exports</span>.age = age;</span><br><span class="line"><span class="built_in">exports</span>.getAge = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  age = age + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">//1 原本的会改变</span></span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.js</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./4&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> age = a.age;</span><br><span class="line"><span class="keyword">var</span> getAge = a.getAge;</span><br><span class="line">getAge();</span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">//0 不会改变age，一旦生成缓存后就会从缓存里读这个值</span></span><br></pre></td></tr></table></figure><h3 id="commonjs-循环加载"><a href="#commonjs-循环加载" class="headerlink" title="commonjs 循环加载"></a>commonjs 循环加载</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;4开始执行&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">exports</span>.name = <span class="string">&#x27;qxq1&#x27;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">exports</span>.name = <span class="string">&#x27;qxq&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;4执行一半&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./5&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;in 4, b.done =&#x27;</span>, b.done);</span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;4执行结束&#x27;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//5.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;5开始执行&#x27;</span>);</span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./4&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;in 5, a.name =&#x27;</span>, a.name);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;in 5, a.done =&#x27;</span>, a.done);</span><br><span class="line"><span class="built_in">exports</span>.done = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;5执行结束&#x27;</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">666</span>, a);</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印结果</span></span><br><span class="line"><span class="number">4</span>开始执行</span><br><span class="line"><span class="number">4</span>执行一半</span><br><span class="line"><span class="number">5</span>开始执行</span><br><span class="line"><span class="keyword">in</span> <span class="number">5</span>, a.name = qxq</span><br><span class="line"><span class="keyword">in</span> <span class="number">5</span>, a.done = <span class="literal">undefined</span></span><br><span class="line"><span class="number">5</span>执行结束</span><br><span class="line"><span class="keyword">in</span> <span class="number">4</span>, b.done = <span class="literal">true</span></span><br><span class="line"><span class="number">4</span>执行结束</span><br><span class="line"><span class="number">666</span> <span class="built_in">Object</span> &#123;<span class="attr">name</span>: <span class="string">&quot;qxq1&quot;</span>, <span class="attr">done</span>: <span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>执行到 <code>require</code> 那行才会去加载该脚本</li><li><code>require</code> 命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象，本质就是一个一次性赋值操作。</li><li>再次执行 <code>require</code> 命令，也不会再次执行该模块，而是到缓存之中取值。</li><li>一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</li></ul><h2 id="ES6-模块"><a href="#ES6-模块" class="headerlink" title="ES6 模块"></a>ES6 模块</h2><ul><li><code>import/export</code> 命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，则会报错。</li><li><code>ES6</code> 模块输入是 <code>export</code> 的动态 <code>只读视图（live read-only views）</code></li></ul><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>使用 <code>import</code> 命令加载其他模块，<code>import</code> 命令输入的变量都是 <code>只读</code> 的，因为它的本质是 <code>输入接口</code>。</p><ol><li><p>语法<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvU3RhdGVtZW50cy9pbXBvcnQ=">查阅<i class="fa fa-external-link-alt"></i></span></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认导出的导入</span></span><br><span class="line"><span class="keyword">import</span> defaultExport <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整体导入</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导入单个接口</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">export</span> &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重命名接口</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">export</span> <span class="keyword">as</span> alias &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入多个接口</span></span><br><span class="line"><span class="keyword">import</span> &#123; export1 , export2 &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; foo , bar &#125; <span class="keyword">from</span> <span class="string">&quot;module-name/path/to/specific/un-exported/file&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; export1 , export2 <span class="keyword">as</span> alias2 , [...] &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;个接口</span><br><span class="line"></span><br><span class="line"><span class="comment">//同时导入默认和多个接口</span></span><br><span class="line"><span class="keyword">import</span> defaultExport, &#123; <span class="keyword">export</span> [ , [...] ] &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> defaultExport, * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只运行模块代码不导入接口</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;module-name&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>如果多次重复执行同一句 <code>import</code> 语句，那么只会执行一次.</p></li><li><p><code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p></li></ol><h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><ol><li><p>使用 <code>export</code> 命令规定对外的 <code>接口</code>，必须与模块内部的变量建立一一对应关系。<code>export</code> 语句输出的接口，与其对应的值是 <code>动态绑定</code> 关系，即通过该接口，可以取到模块内部实时的值。</p></li><li><p>语法<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvU3RhdGVtZW50cy9leHBvcnQ=">查阅<i class="fa fa-external-link-alt"></i></span></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出单个特性</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name1, name2, …, nameN; <span class="comment">// also var, const</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name1 = …, name2 = …, …, nameN; <span class="comment">// also var, const</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">FunctionName</span>(<span class="params"></span>)</span>&#123;...&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导处列表</span></span><br><span class="line"><span class="keyword">export</span> &#123; name1, name2, …, nameN &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名导出</span></span><br><span class="line"><span class="keyword">export</span> &#123; variable1 <span class="keyword">as</span> name1, variable2 <span class="keyword">as</span> name2, …, nameN &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> expression;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">…</span>) </span>&#123; … &#125; <span class="comment">// also class, function*</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">name1</span>(<span class="params">…</span>) </span>&#123; … &#125; <span class="comment">// also class, function*</span></span><br><span class="line"><span class="keyword">export</span> &#123; name1 <span class="keyword">as</span> <span class="keyword">default</span>, … &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复合导出</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> …;</span><br><span class="line"><span class="keyword">export</span> &#123; name1, name2, …, nameN &#125; <span class="keyword">from</span> …;</span><br><span class="line"><span class="keyword">export</span> &#123; import1 <span class="keyword">as</span> name1, import2 <span class="keyword">as</span> name2, …, nameN &#125; <span class="keyword">from</span> …;</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> …;</span><br></pre></td></tr></table></figure></li><li><p>默认导出 <code>export default</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">let</span> k;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> k = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>因为 <code>export default</code> 命令的本质是将后面的值，赋给 <code>default</code> 变量，所以可以直接将一个值写在 <code>export default</code> 之后。</p></li></ol><h3 id="值的引用"><a href="#值的引用" class="headerlink" title="值的引用"></a>值的引用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//4.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; age, getAge &#125; <span class="keyword">from</span> <span class="string">&#x27;./5.js&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">//原本为0</span></span><br><span class="line">getAge();</span><br><span class="line"><span class="built_in">console</span>.log(age); <span class="comment">//因为是值的引用，所以要变，为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> age = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  age = age + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(age); <span class="comment">//要变，为1</span></span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><h3 id="ES6-循环加载"><a href="#ES6-循环加载" class="headerlink" title="ES6 循环加载"></a>ES6 循环加载</h3><ul><li><code>import</code> 命令会被 JavaScript 引擎静态分析，具有提升效果，会提升到整个模块的头部，首先执行。</li><li><code>export</code> 命令会有变量声明提前的效果。</li><li><code>ES6</code> 模块遇到模块加载命令 <code>import</code> 时，不会去执行模块，而是只生成一个 <code>引用</code>。等到真的需要用到时，再到模块里面去取值。</li><li><code>ES6</code> 根本不会关心是否发生了”循环加载”，只是生成一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</li><li>通常存在强耦合，应避免出现。</li></ul><h4 id="例-1"><a href="#例-1" class="headerlink" title="例 1"></a>例 1</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a.js&#x27;</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bar = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bar2 = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;bar2&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bar3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;bar3&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> a <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="comment">// 注意函数表达式和函数声明的区别（提升）</span></span><br></pre></td></tr></table></figure><h4 id="例-2"><a href="#例-2" class="headerlink" title="例 2"></a>例 2</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a starting&#x27;</span>);</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;in b, foo:&#x27;</span>, foo);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> bar = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a done&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b starting&#x27;</span>);</span><br><span class="line"><span class="keyword">import</span> &#123; bar &#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;in a, bar:&#x27;</span>, bar);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;in a, setTimeout bar:&#x27;</span>, bar);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b done&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// babel-node a.js</span></span><br><span class="line"><span class="comment">// 执行结果：</span></span><br><span class="line"><span class="comment">// b starting</span></span><br><span class="line"><span class="comment">// in a, bar: undefined</span></span><br><span class="line"><span class="comment">// b done</span></span><br><span class="line"><span class="comment">// a starting</span></span><br><span class="line"><span class="comment">// in b, foo: foo</span></span><br><span class="line"><span class="comment">// a done</span></span><br><span class="line"><span class="comment">// in a, setTimeout bar: 2</span></span><br><span class="line"><span class="comment">// 注意该例不能用const或let，否则报错:Cannot access &#x27;bar&#x27; before initialization 暂时性死区</span></span><br><span class="line"><span class="comment">// export变量声明提升</span></span><br></pre></td></tr></table></figure><h3 id="高版本浏览器可以直接使用-es6-module"><a href="#高版本浏览器可以直接使用-es6-module" class="headerlink" title="高版本浏览器可以直接使用 es6 module"></a>高版本浏览器可以直接使用 es6 module</h3><p><span class="exturl" data-url="aHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPW1vZHVsZQ==">点此查询版本支持<i class="fa fa-external-link-alt"></i></span></p><ol><li><p><code>script</code> 标签加 <code>type=&#39;module&#39;</code> 属性启动支持</p></li><li><p>支持相对路径和绝对路径</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; getName &#125; <span class="keyword">from</span> <span class="string">&#x27;utils.js&#x27;</span>; <span class="comment">// error</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; getName &#125; <span class="keyword">from</span> <span class="string">&#x27;./utils.js&#x27;</span>; <span class="comment">// right</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>nomodule</code> 向下兼容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;module.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">&quot;fallback.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因老版本不识别 <code>type=&quot;module&quot;</code> 即不会执行 <code>module.js</code>，同时不识别 <code>nomodule</code> 即忽略该属性 <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvSFRNTC9FbGVtZW50L3NjcmlwdA==">参考<i class="fa fa-external-link-alt"></i></span></p></li><li><p>加载方式默认使用 <code>defer</code></p></li><li><p>只执行一次</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1.js 只会被加载执行一次--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> <span class="string">&#x27;./1.js&#x27;</span>;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  普通JS 也只会被加载一次，但是会被执行多次--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;2.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>type=&quot;module&quot;</code> 默认不支持跨域,需要服务器设置 <code>cors</code></p></li><li><p>服务器必须要设置有效的 <code>MIME types</code>：<code>text/javascript</code></p></li></ol><h3 id="动态异步加载-import"><a href="#动态异步加载-import" class="headerlink" title="动态异步加载 import()"></a>动态异步加载 import()</h3><ul><li><code>import()</code>返回一个<code>promise对象</code>,可以用在任何地方，运行时加载</li><li>主要用在<code>按需加载</code>及<code>条件加载</code></li><li>使用 babel 编译时，需要添加<code>syntax-dynamic-import</code>插件</li></ul><h2 id="UMD-模块"><a href="#UMD-模块" class="headerlink" title="UMD 模块"></a>UMD 模块</h2><p>实际上就是 <code>amd/cmd + commonjs + 全局变量</code> 这三种风格的结合，对当前运行环境的判断，如果是 <code>Node</code> 环境 就是使用 <code>CommonJs</code> 规范， 如果不是就判断是否为 <code>AMD</code> 环境， 最后导出全局变量。（<code>AMD</code>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">global</span>, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">typeof</span> <span class="built_in">exports</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span> !== <span class="string">&#x27;undefined&#x27;</span> ? (<span class="built_in">module</span>.exports = factory()) : <span class="keyword">typeof</span> define === <span class="string">&#x27;function&#x27;</span> &amp;&amp; define.amd ? define(factory) : (<span class="built_in">global</span>.libName = factory());</span><br><span class="line">&#125;)(<span class="built_in">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FE Summary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>blog从wordpress迁移至hexo+next，并通过husky+Actions自动部署到ftp及github</title>
      <link href="346.html"/>
      <url>346.html</url>
      
        <content type="html"><![CDATA[<p>因 wordpress 后台臃肿反应慢，外加上本人作为前端代码狗，基于 nodejs 的 hexo 对我非常友好。所以花了 2 天时间终于把 blog 从 wordpress 迁移至 hexo， 通过直接在 md 里面来写博客，简直爽到飞起。特此记录一下我在迁移搭建中做了哪些操作，以便后面遗忘。</p><hr><p><strong>博客效果:</strong></p><ul><li><a href="https://blog.flqin.com/">blog</a></li><li><span class="exturl" data-url="aHR0cHM6Ly96aGFva3kuZ2l0aHViLmlvLw==">github.io<i class="fa fa-external-link-alt"></i></span></li></ul><hr><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>安装 node.js</li><li>安装 git</li><li>全局安装 Hexo-cli（生成 hexo 项目用）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="生成静态网站"><a href="#生成静态网站" class="headerlink" title="生成静态网站"></a>生成静态网站</h3><p>打开目标文件夹，执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init hexo-demo</span><br><span class="line"><span class="built_in">cd</span> hexo-demo</span><br><span class="line">yarn //也可以用npm i，个人喜好</span><br></pre></td></tr></table></figure><p>通过命令 <code>hexo s</code>可本地预览</p><p>通过命令 <code>hexo g</code>可本地生成建站资源 public 包，用来部署</p><p>相关文件夹的作用及配置<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvY29uZmlndXJhdGlvbg==">点此查阅<i class="fa fa-external-link-alt"></i></span>,<br>命令<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvY29tbWFuZHM=">点此查阅<i class="fa fa-external-link-alt"></i></span></p><h3 id="从-wordpress-迁移"><a href="#从-wordpress-迁移" class="headerlink" title="从 wordpress 迁移"></a>从 wordpress 迁移</h3><p>hexo-demo 里安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-migrator-wordpress -D</span><br></pre></td></tr></table></figure><p>同时在<code>WordPress仪表盘</code>中导出数据(“Tools” → “Export” → “WordPress”)</p><p>安装好后执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo migrate wordpress &lt;source&gt; #source为 WordPress 导出的文件路径或网址</span><br></pre></td></tr></table></figure><p>转换后再自己检查修改下就可以了，因为这个转换插件我只需要用一次，然后我就把<code>hexo-migrator-wordpress</code>删掉了。</p><h3 id="hexo-优化"><a href="#hexo-优化" class="headerlink" title="hexo 优化"></a>hexo 优化</h3><p>项目有两个_config.yml 文件，分别是<code>项目_config.yml</code>和<code>主题_config.yml</code>。</p><h4 id="项目增强"><a href="#项目增强" class="headerlink" title="项目增强"></a>项目增强</h4><ul><li>添加<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0VZSE4vaGV4by1oZWxwZXItbGl2ZTJk">页面 2d 萌宠<i class="fa fa-external-link-alt"></i></span>插件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-helper-live2d -D</span><br><span class="line">yarn add live2d-widget-model-koharu -D</span><br></pre></td></tr></table></figure><p><code>项目config</code>添加配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">live2d:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">scriptFrom:</span> <span class="string">jsdelivr</span> <span class="comment"># 默认</span></span><br><span class="line">  <span class="attr">pluginRootPath:</span> <span class="string">live2dw/</span> <span class="comment"># 插件在站点上的根目录(相对路径)</span></span><br><span class="line">  <span class="attr">pluginJsPath:</span> <span class="string">lib/</span> <span class="comment"># 脚本文件相对与插件根目录路径</span></span><br><span class="line">  <span class="attr">pluginModelPath:</span> <span class="string">assets/</span> <span class="comment"># 模型文件相对与插件根目录路径</span></span><br><span class="line">  <span class="attr">tagMode:</span> <span class="literal">false</span> <span class="comment"># 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中</span></span><br><span class="line">  <span class="attr">debug:</span> <span class="literal">false</span> <span class="comment"># 调试, 是否在控制台输出日志</span></span><br><span class="line">  <span class="attr">model:</span></span><br><span class="line">    <span class="attr">use:</span> <span class="string">live2d-widget-model-koharu</span> <span class="comment"># npm-module package name</span></span><br><span class="line">    <span class="attr">scale:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">hHeadPos:</span> <span class="number">0.5</span></span><br><span class="line">    <span class="attr">vHeadPos:</span> <span class="number">0.618</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">superSample:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">width:</span> <span class="number">125</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">150</span></span><br><span class="line">    <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">    <span class="attr">hOffset:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">vOffset:</span> <span class="number">-5</span></span><br><span class="line">  <span class="attr">mobile:</span></span><br><span class="line">    <span class="attr">show:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">scale:</span> <span class="number">0.05</span></span><br><span class="line">  <span class="attr">react:</span></span><br><span class="line">    <span class="attr">opacityDefault:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">opacityOnHover:</span> <span class="number">0.2</span></span><br></pre></td></tr></table></figure><ul><li>添加<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3d6cGFuL2hleG8tZ2VuZXJhdG9yLXNlYXJjaA==">搜索功能<i class="fa fa-external-link-alt"></i></span></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-generator-search -D</span><br></pre></td></tr></table></figure><p><code>项目config</code> 设置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p><code>主题config</code> 设置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by1maWx0ZXItKipvcHRpbWl6ZSoq">页面加载优化<i class="fa fa-external-link-alt"></i></span></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-filter-optimize -D</span><br></pre></td></tr></table></figure><p>配置见作者说明。</p><ul><li>注意插件与 next font-awesome 本地库有冲突，需要把<code>主题config</code>里的<code>fontawesome</code>替换为线上 CDN。<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by1maWx0ZXItb3B0aW1pemUvaXNzdWVzLzI=">详见<i class="fa fa-external-link-alt"></i></span></li><li>在本地 sever 的时候很慢，建议只在发布部署的时候使用。（用<code>sed -i</code>在 travis 构建里开启）</li></ul><h4 id="主题相关"><a href="#主题相关" class="headerlink" title="主题相关"></a>主题相关</h4><p>采用了 star 最多的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0">hexo<i class="fa fa-external-link-alt"></i></span>，官方文档<span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZy9kb2NzLw==">查阅<i class="fa fa-external-link-alt"></i></span>。设置方式：修改<code>项目config</code>里的 <code>theme</code> 为 <code>next</code>即可。</p><h5 id="主题优化（以下配置均在主题config）"><a href="#主题优化（以下配置均在主题config）" class="headerlink" title="主题优化（以下配置均在主题config）"></a>主题优化（以下配置均在<code>主题config</code>）</h5><ul><li>生成缓存： <code>cache.enable:true</code></li><li>修改网站 favicon： <code>favicon</code></li><li>页脚修改： <code>footer</code></li><li>右上角 github banner 生成： <code>github_banner</code></li><li>设置导航： <code>menu</code></li><li>选择主题 Pisces：<code>scheme: Pisces</code></li><li>设置概览信息：<code>social social_icons</code></li><li>设置头像相关：<code>avatar</code></li><li>代码风格：<code>highlight_theme</code></li><li>设置百度统计：<code>baidu_analytics</code></li><li>设置显示加载更多：<code>scroll_to_more</code></li><li>保存滚动位置：<code>save_scroll</code></li><li>添加打赏：<code>reward_settings reward</code></li><li>拷贝<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvdGhlbWUtbmV4dC1yZWFkaW5nLXByb2dyZXNz">滑动进度条<i class="fa fa-external-link-alt"></i></span>并设置：<code>reading_progress</code></li><li>拷贝<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvdGhlbWUtbmV4dC1wYWNl">加载进度条<i class="fa fa-external-link-alt"></i></span>并设置：<code>pace pace_theme</code></li><li>拷贝<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvdGhlbWUtbmV4dC1jYW52YXMtbmVzdA==">页面 3D 背景<i class="fa fa-external-link-alt"></i></span>并设置<code>canvas_nest</code></li><li>拷贝<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvdGhlbWUtbmV4dC1mYW5jeWJveDM=">fancyBox<i class="fa fa-external-link-alt"></i></span>并设置<code>fancybox</code></li><li>拷贝<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by1zeW1ib2xzLWNvdW50LXRpbWU=">字数统计插件<i class="fa fa-external-link-alt"></i></span>并设置（需同时设置两个<code>_onfig</code>,并在项目 yarn add 该插件）：<code>symbols_count_time</code></li></ul><h4 id="SEO-优化"><a href="#SEO-优化" class="headerlink" title="SEO 优化"></a>SEO 优化</h4><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly96aXl1YW4uYmFpZHUuY29tLw==">百度站长平台<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9zZWFyY2guZ29vZ2xlLmNvbS9zZWFyY2gtY29uc29sZQ==">谷歌站长平台<i class="fa fa-external-link-alt"></i></span></p></li><li><p>通过在搜索引擎输入:<code>site: blog.flqin.com</code>测试是否被收录</p></li><li><p>未被收录的话，在站长平台添加。</p></li><li><p>提交链接：包括<code>主动推送</code>，<code>自动推送</code>，<code>sitemap</code>,效率:<code>主动推送&gt;自动推送&gt;sitemap</code>,可同时配合使用:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-generator-sitemap hexo-generator-baidu-sitemap hexo-baidu-url-submit -D</span><br></pre></td></tr></table></figure><p>并设置<code>项目config</code>:<code>url</code>,<code>permalink</code>,<code>sitemap</code>,<code>baidusitemap</code>,<code>baidu_url_submit</code>,<code>deploy</code></p></li></ul><h3 id="husky-Actions-持续部署到-ftp-和-gitlab-io"><a href="#husky-Actions-持续部署到-ftp-和-gitlab-io" class="headerlink" title="husky+Actions 持续部署到 ftp 和 gitlab.io"></a>husky+Actions 持续部署到 ftp 和 gitlab.io</h3><h4 id="部署到-ftp"><a href="#部署到-ftp" class="headerlink" title="部署到 ftp"></a>部署到 ftp</h4><p>安装 <code>husky</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i husky -D</span><br></pre></td></tr></table></figure><p>package.json 添加：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;husky&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;pre-push&quot;</span>: <span class="string">&quot;blog&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 blog 是本地 shell 命令，主要功能是将 hexo 构建后的代码传到 ftp。</p><blockquote><p>为什么不用 <code>hexo-deployer-ftpsync</code> 直接上传？因为使用 github actions 的服务器构建上传到国内会出现墙的问题。只能手动本地上传。</p></blockquote><h4 id="部署到-github-io"><a href="#部署到-github-io" class="headerlink" title="部署到 github.io"></a>部署到 github.io</h4><p>添加部署相关插件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add hexo-deployer-git -D</span><br></pre></td></tr></table></figure><p>部署的<code>项目config</code>配置(详细配置<span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL3poLWNuL2RvY3MvZGVwbG95bWVudA==">查阅<i class="fa fa-external-link-alt"></i></span>)</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:zhaoky/zhaoky.github.io.git</span></span><br></pre></td></tr></table></figure><p>ci 配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">       <span class="attr">uses:</span> <span class="string">sma11black/hexo-action@v1.0.4</span></span><br><span class="line">       <span class="attr">with:</span></span><br><span class="line">         <span class="attr">deploy_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">         <span class="attr">user_name:</span> <span class="string">zhaoky</span></span><br><span class="line">         <span class="attr">user_email:</span> <span class="number">623212389</span><span class="string">@qq.com</span></span><br></pre></td></tr></table></figure><p>其中 DEPLOY_KEY 为私钥，而公钥则部署到 zhaoky.github.io 仓库的<code>deploy key</code>。</p><h4 id="action-的配置文件"><a href="#action-的配置文件" class="headerlink" title="action 的配置文件"></a>action 的配置文件</h4><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Action</span> <span class="string">CI</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">run:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Run</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">nodejs</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v2-beta</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;12&#x27;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">yarn</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">Env</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">BAIDU_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.BAIDU_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">sed</span> <span class="string">-i</span> <span class="string">&quot;s/BAIDU_TOKEN/$BAIDU_TOKEN/g&quot;</span> <span class="string">./_config.yml</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">sma11black/hexo-action@v1.0.4</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">deploy_key:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">user_name:</span> <span class="string">zhaoky</span></span><br><span class="line">          <span class="attr">user_email:</span> <span class="number">623212389</span><span class="string">@qq.com</span></span><br></pre></td></tr></table></figure><hr><h3 id="以下为原-Travis-的配置"><a href="#以下为原-Travis-的配置" class="headerlink" title="以下为原 Travis 的配置"></a>以下为原 Travis 的配置</h3><h4 id="git-部署相关设置"><a href="#git-部署相关设置" class="headerlink" title="git 部署相关设置"></a>git 部署相关设置</h4><p>github 部署采用 ssh 的通讯加密方式，首先在 github 上建一个命名为 zhaoky.github.io(zhaoky 替换成 github 名)的仓库，然后本地本地生成一对公私钥（运行<code>ssh-keygen -t rsa -C youremail@example.com</code>生成）,将.pub 公钥配置在 zhaoky.github.io 仓库的 <code>deploy key</code>，把私钥和 ssh-config 发到 travis 的构建服务器里。私钥为了保证安全性，本地通过 travis 命令加密，然后在 travis 构建时再解密，这样就能自动发布了。</p><h4 id="本地-travis-命令如何加密"><a href="#本地-travis-命令如何加密" class="headerlink" title="本地 travis 命令如何加密"></a>本地 travis 命令如何加密</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gem install travis</span><br><span class="line">travis login --com #如果仍在使用travis-ci.org，则需要使用--org</span><br><span class="line">travis encrypt-file id_rsa --add --pro #使用--add自动添加到travis.yml,--pro将生成的加密环境变量添加到travis项目后台管理中</span><br></pre></td></tr></table></figure><p>这样就生成了一个加密后的.enc 的文件了</p><h4 id="ssh-config-怎么配置"><a href="#ssh-config-怎么配置" class="headerlink" title="ssh/config 怎么配置"></a>ssh/config 怎么配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    StrictHostKeyChecking no</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa</span><br><span class="line">    IdentitiesOnly yes</span><br></pre></td></tr></table></figure><p>我的做法是在项目里建了一个.travis 的文件夹，将加密后的.enc 文件和 ssh-config 放进去，在 travis 构建的时候发到构建的机器上。</p><h4 id="我的-travis-yml-的配置"><a href="#我的-travis-yml-的配置" class="headerlink" title="我的.travis.yml 的配置"></a>我的.travis.yml 的配置</h4><p>直接看配置就明白了。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">language:</span> <span class="string">node_js</span></span><br><span class="line"><span class="attr">node_js:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&#x27;10&#x27;</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">directories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules</span></span><br><span class="line"><span class="attr">branches:</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">openssl</span> <span class="string">aes-256-cbc</span> <span class="string">-K</span> <span class="string">$encrypted_43f9974e8d06_key</span> <span class="string">-iv</span> <span class="string">$encrypted_43f9974e8d06_iv</span></span><br><span class="line">    <span class="string">-in</span> <span class="string">.travis/id_rsa.enc</span> <span class="string">-out</span> <span class="string">~/.ssh/id_rsa</span> <span class="string">-d</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cp</span> <span class="string">.travis/ssh_config</span> <span class="string">~/.ssh/config</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">&#x27;korey&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">&#x27;keyu.zhao@foxmail.com&#x27;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">add</span> <span class="string">hexo-cli</span> <span class="string">-g</span></span><br><span class="line"><span class="attr">install:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">bash</span> <span class="string">sed.sh</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">yarn</span> <span class="string">run</span> <span class="string">deploy</span> <span class="comment">#hexo clean &amp;&amp; hexo g -d</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FE Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git命令总结</title>
      <link href="347.html"/>
      <url>347.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装-git"><a href="#安装-git" class="headerlink" title="安装 git"></a>安装 git</h2><p>当前用户的 <code>Git</code> 配置文件放在用户主目录下的一个隐藏文件 <code>.gitconfig</code> 中，里面可配置 <code>git</code> 相关的全局信息。</p><h3 id="安装好后，最后一步设置"><a href="#安装好后，最后一步设置" class="headerlink" title="安装好后，最后一步设置"></a>安装好后，最后一步设置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;korey&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xxx@163.com&quot;</span></span><br><span class="line">git config --global alias.st status <span class="comment">#设置别名</span></span><br></pre></td></tr></table></figure><h3 id="大小写敏感"><a href="#大小写敏感" class="headerlink" title="大小写敏感"></a>大小写敏感</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config core.ignorecase <span class="literal">false</span></span><br></pre></td></tr></table></figure><h4 id="如果已经在远程仓库出现文件重复的情况"><a href="#如果已经在远程仓库出现文件重复的情况" class="headerlink" title="如果已经在远程仓库出现文件重复的情况"></a>如果已经在远程仓库出现文件重复的情况</h4><ol><li><code>git config core.ignorecase false</code></li><li>修改文件夹名称为目标名称，然后 <code>push</code>，远程仓库出现文件重复的情况。</li><li><code>git rm --cached src/components/Header -rf</code></li><li>再次 <code>add-&gt;commit-&gt;push</code> 即可</li></ol><h3 id="列举所有配置"><a href="#列举所有配置" class="headerlink" title="列举所有配置"></a>列举所有配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -l</span><br></pre></td></tr></table></figure><h3 id="查看系统-config"><a href="#查看系统-config" class="headerlink" title="查看系统 config"></a>查看系统 config</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --system --list</span><br></pre></td></tr></table></figure><h3 id="查看当前用户（global）配置"><a href="#查看当前用户（global）配置" class="headerlink" title="查看当前用户（global）配置"></a>查看当前用户（global）配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure><h3 id="查看当前仓库配置信息"><a href="#查看当前仓库配置信息" class="headerlink" title="查看当前仓库配置信息"></a>查看当前仓库配置信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">local</span>  --list</span><br></pre></td></tr></table></figure><h3 id="删除某个配置"><a href="#删除某个配置" class="headerlink" title="删除某个配置"></a>删除某个配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> user.emaill</span><br></pre></td></tr></table></figure><p>全局的通过 <code>vim ~/.gitconfig</code> 来查看 局部的通过当前路径下的 <code>.git/config</code> 文件来查看</p><h2 id="创建版本库（仓库）"><a href="#创建版本库（仓库）" class="headerlink" title="创建版本库（仓库）"></a>创建版本库（仓库）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir aaa</span><br><span class="line"><span class="built_in">cd</span> aaa</span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure><h2 id="三态转换"><a href="#三态转换" class="headerlink" title="三态转换"></a>三态转换</h2><h3 id="查看仓库状态"><a href="#查看仓库状态" class="headerlink" title="查看仓库状态"></a>查看仓库状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><ul><li><code>工作区 Working tree</code>：即文件目录内容</li><li><code>暂存区 index</code>：目录 <code>.git</code> 内的 <code>stage/index</code> (已 <code>add</code> 未 <code>commit</code>)</li><li><code>版本库 repo</code>：文件 <code>.git</code> 新修改的文件 (工作区) <code>（untracked）→ 通过 add→ 暂存区 → 通过 commit→ 版本库</code></li></ul><h3 id="工作区-gt-暂存区"><a href="#工作区-gt-暂存区" class="headerlink" title="工作区-&gt;暂存区"></a>工作区-&gt;暂存区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure><h3 id="暂存区-gt-版本库"><a href="#暂存区-gt-版本库" class="headerlink" title="暂存区-&gt;版本库"></a>暂存区-&gt;版本库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git commit &lt;file&gt;</span><br><span class="line">git commit .</span><br><span class="line">git commit -a</span><br><span class="line">git commit -amend  <span class="comment">#修改最后一次提交</span></span><br><span class="line">git commit -m “xxx”</span><br></pre></td></tr></table></figure><h3 id="撤销工作区的修改"><a href="#撤销工作区的修改" class="headerlink" title="撤销工作区的修改"></a>撤销工作区的修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout --  &lt;file&gt;</span><br><span class="line">git checkout .</span><br></pre></td></tr></table></figure><p><code>checkout</code> 还可以检出提交，查看某个版本的代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout 5aab391 <span class="comment">#跳到该commit快照</span></span><br><span class="line">git checkout - <span class="comment">#回到当前</span></span><br></pre></td></tr></table></figure><h3 id="已暂存撤销到工作区-git-不再跟踪"><a href="#已暂存撤销到工作区-git-不再跟踪" class="headerlink" title="已暂存撤销到工作区(git 不再跟踪)"></a>已暂存撤销到工作区(git 不再跟踪)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git rm -- cached &lt;file&gt;</span><br><span class="line">git reset &lt;file&gt;</span><br><span class="line">git reset .   <span class="comment">#--mixed 为默认参数 意思是把变更放在工作区</span></span><br><span class="line">git reset --hard <span class="comment">#工作区和暂存区都撤销</span></span><br></pre></td></tr></table></figure><h3 id="文件改名"><a href="#文件改名" class="headerlink" title="文件改名"></a>文件改名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv oldName newName</span><br></pre></td></tr></table></figure><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;file&gt;</span><br></pre></td></tr></table></figure><h2 id="比较-diff"><a href="#比较-diff" class="headerlink" title="比较 diff"></a>比较 diff</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git diff                <span class="comment">#比较Working tree和index之间的差异</span></span><br><span class="line">git diff &lt;file&gt;      <span class="comment">#比较Working tree和index之间的差异</span></span><br><span class="line">git diff --cached 或 <span class="variable">$git</span> diff --staged    <span class="comment">#两个都是比较index和版本库的差异</span></span><br><span class="line">git diff HEAD <span class="comment"># 查看Working tree和版本库的差异</span></span><br><span class="line">git diff &lt;<span class="variable">$id1</span>&gt; &lt;<span class="variable">$id2</span>&gt;  <span class="comment">#比较两次提交之间的差异</span></span><br><span class="line">git diff &lt;branch1&gt;..&lt;branch2&gt; <span class="comment">#在两个分支之间比较</span></span><br><span class="line">git diff --name-only HEAD src <span class="comment">#显示当前分支最新的提交与工作区或暂存区的比较，只显示文件名</span></span><br></pre></td></tr></table></figure><h2 id="和-的区别"><a href="#和-的区别" class="headerlink" title="^和~的区别"></a>^和~的区别</h2><ul><li><code>^</code>代表父提交,当一个提交有多个父提交时，可以通过在<code>^</code>后面跟上一个数字，表示第几个父提交，<code>^</code>相当于<code>^1</code>。</li><li><code>~&lt;n&gt;</code>表示第 n 个祖先提交，相当于连续的 n 个<code>^</code>。如<code>HEAD~3</code>即 HEAD 的父提交的父提交的父提交。如要取 merge 的第二个父提交的父提交:<code>HEAD^2~1</code></li></ul><h2 id="查看历史记录"><a href="#查看历史记录" class="headerlink" title="查看历史记录"></a>查看历史记录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span>                      <span class="comment">#第一行为commit ID</span></span><br><span class="line">git <span class="built_in">log</span>  -p &lt;file&gt;  <span class="comment">#查看指定文件的提交历史</span></span><br><span class="line">git blame  &lt;file&gt; <span class="comment">#以列表方式查看指定文件的提交历史</span></span><br><span class="line">git reflog show master | head  <span class="comment">#显示所有的版本记录</span></span><br></pre></td></tr></table></figure><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>这里收集了 <code>四种</code> 方式实现版本回退，通过<code>git reflog</code>可以查看操作记录。</p><h3 id="暴力-reset-回退"><a href="#暴力-reset-回退" class="headerlink" title="暴力 reset 回退"></a>暴力 reset 回退</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git pull</span><br><span class="line">git reset --hard &lt;commit&gt;</span><br><span class="line">git push origin master -f</span><br></pre></td></tr></table></figure><p>该方式会<code>改变历史进程</code>，多人开发时会混乱,非常不推荐。</p><h3 id="使用-revert-生成一个新-commit"><a href="#使用-revert-生成一个新-commit" class="headerlink" title="使用 revert 生成一个新 commit"></a>使用 revert 生成一个新 commit</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git revert 5aab391 <span class="comment">#回滚某次commit</span></span><br><span class="line">git revert -n 5aab391..1hd2d72 <span class="comment">#回滚从5aab391到1hd2d72，但中间如果有merge等则不适用</span></span><br><span class="line">git revert -m 1 5aab391 <span class="comment">#回滚某次merge的commit -m 1是选择保留1，抛弃2，这个1，2的定义在git log中的merge那行顺序为准</span></span><br></pre></td></tr></table></figure><p>该方法<code>不会改变历史进程</code>，适用于单个回滚或者多个无 merge 的回滚。</p><h3 id="使用-reset-–head-–soft"><a href="#使用-reset-–head-–soft" class="headerlink" title="使用 reset –head –soft"></a>使用 reset –head –soft</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 5aab391</span><br><span class="line">git reset --soft 1hd2d72 <span class="comment">#5aab391到1hd2d72之前的放到了暂存区 ？</span></span><br><span class="line">git commit -m <span class="string">&#x27;生成一个新提交，回滚5aab391到1hd2d72的内容&#x27;</span></span><br><span class="line">git push xxx</span><br></pre></td></tr></table></figure><p>该方法<code>不会改变历史进程</code>，生成一个新的 commit 来覆盖之前的内容达到回滚，推荐。</p><h3 id="使用-s-ours-master"><a href="#使用-s-ours-master" class="headerlink" title="使用 -s ours master"></a>使用 -s ours master</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b v2 4a50c9f <span class="comment">#切一个新分支并使用历史安全版本</span></span><br><span class="line">git merge -s ours master</span><br><span class="line">git push origin master <span class="comment">#等价于git push origin v2:master</span></span><br></pre></td></tr></table></figure><p>该方法<code>不会改变历史进程</code>，生成一个新的 commit 来覆盖之前的内容达到回滚，墙裂推荐。</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@git ….</span><br></pre></td></tr></table></figure><h3 id="创建-SSH-Key"><a href="#创建-SSH-Key" class="headerlink" title="创建 SSH Key"></a>创建 SSH Key</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -c <span class="string">&quot;623212389@qq.com&quot;</span></span><br></pre></td></tr></table></figure><p>用户主目录下 →.ssh→id_rsa（私钥）+id_rsa.pub（公钥）或<code>\$cat ~/.ssh/id-rsa.pub</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">git remote -v     <span class="comment">#查看远程服务器地址和仓库名称</span></span><br><span class="line">git remote show origin   <span class="comment">#查看远程服务器仓库状态</span></span><br><span class="line">git remote add origin git@git……    <span class="comment">#添加远程仓库地址</span></span><br><span class="line">git remote set-url origin git@git……    <span class="comment">#修改远程地址</span></span><br><span class="line">git remote rm    <span class="comment">#删除远程创库地址</span></span><br><span class="line"></span><br><span class="line">git pull  <span class="comment"># =git fetch + git merge</span></span><br><span class="line">git fetch <span class="comment">#拉取</span></span><br><span class="line">git merge <span class="comment">#合并</span></span><br><span class="line">git push <span class="comment"># push所有分支</span></span><br><span class="line">git push origin master           <span class="comment"># 将本地主分支推到远程主分支</span></span><br><span class="line">git push -u origin master       <span class="comment"># 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)</span></span><br><span class="line">git push origin &lt;local_branch&gt;   <span class="comment"># 创建远程分支， origin是远程仓库名</span></span><br><span class="line">git push origin &lt;local_branch&gt;:&lt;remote_branch&gt;  <span class="comment"># 创建远程分支</span></span><br><span class="line">git push origin :&lt;remote_branch&gt;  <span class="comment">#先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支</span></span><br><span class="line"></span><br><span class="line">git rebase</span><br><span class="line"></span><br><span class="line">git remote update origin --prune  <span class="comment">#更新远程分支信息</span></span><br></pre></td></tr></table></figure><h2 id="分支相关"><a href="#分支相关" class="headerlink" title="分支相关"></a>分支相关</h2><h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><h3 id="查看远程分支"><a href="#查看远程分支" class="headerlink" title="查看远程分支"></a>查看远程分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -r</span><br></pre></td></tr></table></figure><h3 id="查看所有分支"><a href="#查看所有分支" class="headerlink" title="查看所有分支"></a>查看所有分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -a <span class="comment">#远程分支用的红色</span></span><br></pre></td></tr></table></figure><h3 id="查看已经被合并到当前分支的分支"><a href="#查看已经被合并到当前分支的分支" class="headerlink" title="查看已经被合并到当前分支的分支"></a>查看已经被合并到当前分支的分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --merged</span><br></pre></td></tr></table></figure><h3 id="查看未被合并到当前分支的分支"><a href="#查看未被合并到当前分支的分支" class="headerlink" title="查看未被合并到当前分支的分支"></a>查看未被合并到当前分支的分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --no-merged</span><br></pre></td></tr></table></figure><h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch xxx</span><br></pre></td></tr></table></figure><h3 id="切换分支或标签"><a href="#切换分支或标签" class="headerlink" title="切换分支或标签"></a>切换分支或标签</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout xxx/tag</span><br></pre></td></tr></table></figure><h3 id="创建加切换"><a href="#创建加切换" class="headerlink" title="创建加切换"></a>创建加切换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b xxx</span><br></pre></td></tr></table></figure><h3 id="重命名本地分支"><a href="#重命名本地分支" class="headerlink" title="重命名本地分支"></a>重命名本地分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -m old new</span><br></pre></td></tr></table></figure><h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d xxx   <span class="comment">#-D为强制删除</span></span><br></pre></td></tr></table></figure><h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete &lt;branchName&gt;</span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">git push origin  :&lt;branchName&gt;  <span class="comment">#推送一个空分支到远程</span></span><br></pre></td></tr></table></figure><h2 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h2><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>将 <code>feature</code> 分支合到 <code>master</code>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge feature</span><br><span class="line">// 此时如果有冲突，修改冲突后</span><br><span class="line">git a</span><br><span class="line">git commit -m <span class="string">&#x27;merge&#x27;</span></span><br></pre></td></tr></table></figure><p>此时会将 <code>feature</code> 和 <code>master</code> 分支融合到一起，其中：</p><ul><li>如果 <code>feature</code> 的提交全部在 <code>master</code> 提交时间之后，那么直接将指针移到最后即可，<code>master</code> 分支线只有一条，<code>feature</code> 分支信息不保留，如果想保留则执行 <code>git merge feature --no-ff</code>；</li><li>如果 <code>feature</code> 和 <code>master</code> 提交时间交替，那么会多一次冲突提交，<code>master</code> 分支线有 <code>feature</code> 汇入，提交的时序以各自分支的时间为准（即交替）；</li><li>如果在合并分支时想同时合并 <code>feature</code> 的 <code>commit</code>，则执行：<code>git merge feature --squash</code>；</li><li>撤销合并： <code>git merge --abort</code>；</li></ul><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><p>将 <code>feature</code> 分支合到 <code>master</code>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase master</span><br><span class="line">// 将 master 作为 基底，此时会将feature上的所有后于master的提交全部转化为一个个的补丁，往master上应用，如果有冲突，修改冲突后</span><br><span class="line">git a</span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br><span class="line">// 然后进入下一个补丁应用，补丁打完后，执行</span><br><span class="line">git checkout master</span><br><span class="line">git rebase/merge feature</span><br></pre></td></tr></table></figure><ul><li><code>rebase</code> 的好处是分支线将只有一个，没有多余的 <code>feature</code> 分支线，也没有多余的提交历史，提交的时序也发生改变，以打补丁的时间为准（即先是 <code>master</code> 的提交，后是补丁的提交）</li><li>撤销合并： <code>git rebase --abort</code>；</li></ul><h3 id="merge-和-rebase-区别"><a href="#merge-和-rebase-区别" class="headerlink" title="merge 和 rebase 区别"></a><code>merge</code> 和 <code>rebase</code> 区别</h3><ul><li><code>rebase</code> 可以尽可能保持 <code>master</code> 分支干净整洁，但会丢失分支信息 （推荐）</li><li><code>merge</code> 不能保持 <code>master</code> 分支干净，但是保持了所有的 <code>commit history</code></li></ul><p><strong>注意 分支 merge 到 master 后，只有一个 commit 即提交解决冲突的 commit。</strong></p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC83NTQ5OTg3MQ==">git merge 和 git rebase 的区别<i class="fa fa-external-link-alt"></i></span></p></blockquote><h2 id="合并提交（commit）"><a href="#合并提交（commit）" class="headerlink" title="合并提交（commit）"></a>合并提交（commit）</h2><p>假如有 6 次提交 commit 从旧到新依次是:<code>master1, master2, master3, master4, master5, master6</code>，目标合并 <code>master3, master4, master5, master6</code>,最终效果为 <code>master1, master2, masterN</code></p><h3 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD~4 //前4次提交</span><br><span class="line">git a</span><br><span class="line">git commit -m <span class="string">&#x27;masterN&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="reabse"><a href="#reabse" class="headerlink" title="reabse"></a>reabse</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~4</span><br><span class="line">// 修改 后3个 pick 为 s，即以第一个pick为基点合并</span><br><span class="line">// pick 91a5777 master3</span><br><span class="line">// s dcecb67 master4</span><br><span class="line">// s 5ac7381 master5</span><br><span class="line">// s c032d0b master6</span><br><span class="line">-----</span><br><span class="line">// 然后再删除其他无用的commit信息,重写 1st commit message</span><br><span class="line"><span class="comment"># This is the 1st commit message:</span></span><br><span class="line">// masterN</span><br><span class="line"><span class="comment"># This is the commit message #2:</span></span><br><span class="line"><span class="comment"># master4</span></span><br><span class="line"><span class="comment"># This is the commit message #3:</span></span><br><span class="line"><span class="comment"># master5</span></span><br><span class="line"><span class="comment"># This is the commit message #4:</span></span><br><span class="line"><span class="comment"># master6</span></span><br></pre></td></tr></table></figure><h3 id="合并中间部分提交"><a href="#合并中间部分提交" class="headerlink" title="合并中间部分提交"></a>合并中间部分提交</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b 分支T &lt;终点提交&gt; // 基于需要被合并的提交段的终点提交创建新的临时分支T</span><br><span class="line">git reset HEAD~4 //前4次提交</span><br><span class="line">git a</span><br><span class="line">git commit -m <span class="string">&#x27;masterN&#x27;</span></span><br><span class="line">git checkout origin</span><br><span class="line">git rebase --onto 分支T &lt;终点提交&gt;</span><br></pre></td></tr></table></figure><h2 id="暂存管理"><a href="#暂存管理" class="headerlink" title="暂存管理"></a>暂存管理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git stash  <span class="comment">#将工作区做的修改暂存到一个git栈中</span></span><br><span class="line">git stash list <span class="comment">#查看栈中所有暂存</span></span><br><span class="line">git stash apply &lt;暂存编号&gt;  <span class="comment">#回复对应编号暂存到工作区，如果不指定编号为栈顶的，注意：这些暂存还在栈中</span></span><br><span class="line">git stash pop <span class="comment">#将栈顶的暂存，恢复到工作区，并从栈中弹出</span></span><br><span class="line">git stash clear <span class="comment">#清空暂存栈</span></span><br></pre></td></tr></table></figure><h2 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0.0 <span class="comment">#id</span></span><br><span class="line">git tag -a v1.0.0 -m <span class="string">&quot;你的附注信息&quot;</span> <span class="comment">#id</span></span><br><span class="line">git tag</span><br><span class="line">git show v1.0.0</span><br><span class="line">git tag -d v1.0.0</span><br><span class="line">git push origin :refs/tags/v1.0.0</span><br><span class="line">git push --tags <span class="comment">#上传所有标签</span></span><br></pre></td></tr></table></figure><h2 id="挑拣提交"><a href="#挑拣提交" class="headerlink" title="挑拣提交"></a>挑拣提交</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick 1hs73hds <span class="comment">#直接在该分支应用任意其他分支的commit即可</span></span><br></pre></td></tr></table></figure><h2 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h2><p>使用 Windows 的童鞋注意了，如果你在资源管理器里新建一个 <code>.gitignore</code> 文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为 <code>.gitignore</code> 了。</p><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><p>在 <code>GitHub</code> 上，可以任意 <code>Fork</code> 开源仓库； 自己拥有 <code>Fork</code> 后的仓库的读写权限； 可以推送 <code>pull request</code> 给官方仓库来贡献代码。</p><h2 id="总览图"><a href="#总览图" class="headerlink" title="总览图"></a>总览图</h2><p><img data-src="http://cdn.flqin.com/p347-1.png" alt="git命令总结"></p>]]></content>
      
      
      <categories>
          
          <category> FE Summary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）cookie浅析</title>
      <link href="340.html"/>
      <url>340.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接：<code>https://segmentfault.com/a/1190000004556040</code></p></blockquote><h2 id="我们看到的-cookie"><a href="#我们看到的-cookie" class="headerlink" title="我们看到的 cookie"></a>我们看到的 cookie</h2><p>在 <code>chrome</code> 浏览器中打开这个网站，进入开发者模式，点击 <code>Resources 栏</code> -&gt; 选择 <code>cookies</code>，我们会看到如下图所示的界面：</p><p><img data-src="http://cdn.flqin.com/p340-1.png" alt="chrome resources"></p><p>在这个网页 <code>http://ppsc.sankuai.com</code> 中我设置了几个<code>cookie</code>：<code>JSSESSIONID，PA_VTIME，skmtutc，test</code>。</p><p>解释一下：左边栏 <code>Cookies</code> 下方会列举当前网页中设置过 <code>cookie</code> 的域都有哪些。上图中只有一个域，即“<code>ppsc.sankuai.com</code>”。而右侧区域显示的就是某个域下具体的 <code>cookie</code> 列表，对应上图就是“<code>ppsc.sankuai.com</code>”域下设置的 4 个 <code>cookie</code>。</p><p>在这个网页中我往 <code>http://ppsc.sankuai.com/getList</code> 接口发了一个 <code>Ajax</code> 请求，<code>request header</code> 如下图所示：</p><p><img data-src="http://cdn.flqin.com/p340-2.png" alt="request header"></p><p>从上图中我们会看到 <code>request header</code> 中自动添加了 <code>Cookie</code> 字段（我并没有手动添加这个字段哦~），<code>Cookie</code> 字段的值其实就是我设置的那 4 个 <code>cookie</code>。这个请求最终会发送到 <code>http://ppsc.sankuai.com</code> 这个服务器上，这个服务器就能从接收到的 <code>request header</code> 中提取那 4 个 <code>cookie</code>。</p><p>上面两张图展示了 <code>cookie</code> 的基本通信流程：<code>设置 cookie</code> =&gt; <code>cookie 被自动添加到 request header 中</code> =&gt; <code>服务端接收到 cookie</code>。这个流程中有几个问题需要好好研究：</p><ul><li>什么样的数据适合放在 <code>cookie</code> 中？</li><li><code>cookie</code> 是怎么设置的？</li><li><code>cookie</code> 为什么会自动加到 <code>request header</code> 中？</li><li><code>cookie</code> 怎么增删查改？</li></ul><p>我们要带着这几个问题继续往下阅读。</p><h2 id="cookie-是怎么工作的"><a href="#cookie-是怎么工作的" class="headerlink" title="cookie 是怎么工作的"></a>cookie 是怎么工作的</h2><p>首先必须明确一点，存储 <code>cookie</code> 是浏览器提供的功能。<code>cookie</code> 其实是存储在浏览器中的纯文本，浏览器的安装目录下会专门有一个 <code>cookie</code> 文件夹来存放各个域下设置的 <code>cookie</code>。</p><p>当网页要发 <code>http</code> 请求时，浏览器会先检查是否有相应的 <code>cookie</code>，有则自动添加在 <code>request header</code> 中的 <code>cookie</code> 字段中。这些是浏览器自动帮我们做的，而且每一次 <code>http</code> 请求浏览器都会自动帮我们做。这个特点很重要，因为这关系到“什么样的数据适合存储在 <code>cookie</code> 中”。</p><p>存储在 <code>cookie</code> 中的数据，每次都会被浏览器自动放在 <code>http</code> 请求中，如果这些数据并不是每个请求都需要发给服务端的数据，浏览器这设置自动处理无疑增加了网络开销；但如果这些数据是每个请求都需要发给服务端的数据（比如身份认证信息），浏览器这设置自动处理就大大免去了重复添加操作。所以对于那设置“每次请求都要携带的信息（最典型的就是身份认证信息）”就特别适合放在 <code>cookie</code> 中，其他类型的数据就不适合了。</p><p>但在 <code>localStorage</code> 出现之前，<code>cookie</code> 被滥用当做了存储工具。什么数据都放在 <code>cookie</code> 中，即使这些数据只在页面中使用而不需要随请求传送到服务端。当然 <code>cookie</code> 标准还是做了一些限制的：每个域名下的 <code>cookie</code> 的大小最大为 4KB，每个域名下的 <code>cookie</code> 数量最多为 20 个（但很多浏览器厂商在具体实现时支持大于 20 个）。</p><h2 id="cookie-的格式"><a href="#cookie-的格式" class="headerlink" title="cookie 的格式"></a>cookie 的格式</h2><h3 id="document-cookie"><a href="#document-cookie" class="headerlink" title="document.cookie"></a>document.cookie</h3><p><code>JS</code> 原生的 <code>API</code> 提供了获取 <code>cookie</code> 的方法：<code>document.cookie</code>（注意，这个方法只能获取非 <code>HttpOnly</code> 类型的 <code>cookie</code>）。在 <code>console</code> 中执行这段代码可以看到结果如下图：</p><p><img data-src="http://cdn.flqin.com/p340-3.png" alt="document.cookie"></p><p>打印出的结果是一个字符串类型，因为 <code>cookie</code> 本身就是存储在浏览器中的字符串。但这个字符串是有格式的，由键值对 <code>key=value</code> 构成，键值对之间由一个分号和一个空格隔开。</p><h3 id="cookie-的属性选项"><a href="#cookie-的属性选项" class="headerlink" title="cookie 的属性选项"></a>cookie 的属性选项</h3><p>每个 <code>cookie</code> 都有一定的属性，如什么时候失效，要发送到哪个域名，哪个路径等等。这些属性是通过 <code>cookie</code> 选项来设置的，<code>cookie</code> 选项包括：<code>expires、domain、path、secure、HttpOnly</code>。在设置任一个 <code>cookie</code> 时都可以设置相关的这些属性，当然也可以不设置，这时会使用这些属性的默认值。在设置这些属性时，属性之间由一个分号和一个空格隔开。代码示例如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;key=name; expires=Thu, 25 Feb 2016 04:18:00 GMT; domain=ppsc.sankuai.com; path=/; secure; HttpOnly&quot;</span></span><br></pre></td></tr></table></figure><h4 id="expires"><a href="#expires" class="headerlink" title="expires"></a>expires</h4><p><code>expires</code> 选项用来设置 <code>cookie</code> 什么时间内有效”。已被 <code>max-age</code> 代替。<code>expires</code> 其实是 <code>cookie</code> 失效日期，<code>expires</code> 必须是 <code>GMT</code> 格式的时间（可以通过 <code>new Date().toGMTString()</code>或者 <code>new Date().toUTCString()</code> 来获得）。</p><p>如 <code>expires=Thu, 25 Feb 2016 04:18:00 GMT</code> 表示 <code>cookie</code> 将在 <code>2016 年 2 月 25 日 4:18 分</code> 之后失效，对于失效的 <code>cookie</code> 浏览器会清空。如果没有设置该选项，则默认有效期为 <code>session</code>，即会话 <code>cookie</code>。这种 <code>cookie</code> 在浏览器关闭后就没有了。</p><blockquote><p>expires 是 http/1.0 协议中的选项，在新的 http/1.1 协议中 expires 已经由 max-age 选项代替，两者的作用都是限制 cookie 的有效时间。expires 的值是一个时间点（cookie 失效时刻= expires），而 max-age 的值是一个以秒为单位时间段（cookie 失效时刻= 创建时刻+ max-age）。 另外，max-age 的默认值是 -1(即有效期为 session )；若 max-age 有三种可能值：负数、0、正数。负数：有效期 session；0：删除 cookie；正数：有效期为创建时刻+ max-age</p></blockquote><h4 id="domain-和-path"><a href="#domain-和-path" class="headerlink" title="domain 和 path"></a>domain 和 path</h4><p><code>domain</code> 是域名，<code>path</code> 是路径，两者加起来就构成了 <code>URL</code>，<code>domain</code> 和 <code>path</code> 一起来限制 <code>cookie</code> 能被哪些 <code>URL</code> 访问。</p><p>一句话概括：某 <code>cookie</code> 的 <code>domain</code> 为 <code>baidu.com</code>, <code>path</code> 为 <code>/</code>，若请求的 <code>URL</code> (<code>URL</code> 可以是 <code>js/html/img/css</code> 资源请求，但不包括 <code>XHR</code> 请求)的域名是 <code>baidu.com</code> 或其子域如 <code>api.baidu.com</code>、<code>dev.api.baidu.com</code>，且 <code>URL</code> 的路径是<code>/</code> 或子路径<code>/home</code>、<code>/home/login</code>，则浏览器会将此 <code>cookie</code> 添加到该请求的 <code>cookie</code> 头部中。</p><p>所以 <code>domain</code> 和 <code>path2</code> 个选项共同决定了 <code>cookie</code> 何时被浏览器自动添加到请求头部中发送出去。如果没有设置这两个选项，则会使用默认值。<code>domain</code> 的默认值为设置该 <code>cookie</code> 的网页所在的域名，<code>path</code> 默认值为设置该 <code>cookie</code> 的网页所在的目录。</p><p><code>domain</code> 属性可以使多个 <code>web</code> 服务器共享 <code>cookie</code>。<code>domain</code> 属性的默认值是创建 <code>cookie</code> 的网页所在服务器的主机名。不能将一个 <code>cookie</code> 的域设置成服务器所在的域之外的域。</p><p>例如让位于 <code>order.example.com</code> 的服务器能够读取 <code>catalog.example.com</code> 设置的 <code>cookie</code> 值。如果 <code>catalog.example.com</code> 的页面创建的 <code>cookie</code> 把自己的 <code>path</code> 属性设置为 <code>“/”</code>，把 <code>domain</code> 属性设置成 <code>“.example.com”</code>，那么所有位于 <code>catalog.example.com</code> 的网页和所有位于 <code>orlders.example.com</code> 的网页，以及位于 <code>example.com</code> 域的其他服务器上的网页都可以访问这个 <code>cookie</code>。</p><blockquote><p><strong>特别说明 1：</strong><br>发生跨域 xhr 请求时，即使请求 URL 的域名和路径都满足 cookie 的 domain 和 path，默认情况下 cookie 也不会自动被添加到请求头部中。若想知道原因请阅读本文最后一节）<br><strong>特别说明 2：</strong><br>domain 是可以设置为页面本身的域名（本域），或页面本身域名的父域，但不能是公共后缀 public suffix。举例说明下：如果页面域名为 <span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb20v">www.baidu.com<i class="fa fa-external-link-alt"></i></span>, domain 可以设置为“<span class="exturl" data-url="aHR0cDovL3d3dy5iYWlkdS5jb23igJ0s5Lmf5Y+v5Lul6K6+572u5Li64oCcYmFpZHUuY29t4oCdLOS9huS4jeiDveiuvue9ruS4uuKAnC5jb23igJ3miJbigJxjb23igJ0uLw==">www.baidu.com”，也可以设置为“baidu.com”，但不能设置为“.com”或“com”。<i class="fa fa-external-link-alt"></i></span></p></blockquote><h4 id="secure"><a href="#secure" class="headerlink" title="secure"></a>secure</h4><p><code>secure</code> 选项用来设置 <code>cookie</code> 只在确保安全的请求中才会发送。当请求是 <code>HTTPS</code> 或者其他安全协议时，包含 <code>secure</code> 选项的 <code>cookie</code> 才能被发送至服务器。</p><p>默认情况下，<code>cookie</code> 不会带 <code>secure</code> 选项(即为空)。所以默认情况下，不管是 <code>HTTPS</code> 协议还是 <code>HTTP</code> 协议的请求，<code>cookie</code> 都会被发送至服务端。但要注意一点，<code>secure</code> 选项只是限定了在安全情况下才可以传输给服务端，但并不代表你不能看到这个 <code>cookie</code>。</p><p>下面我们设置一个 <code>secure</code> 类型的 <code>cookie</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;name=huang; secure&#x27;</span>;</span><br></pre></td></tr></table></figure><p>之后你就能在控制台中看到这个 <code>cookie</code> 了，如下图所示：</p><p><img data-src="http://cdn.flqin.com/p340-4.png" alt="cookie"></p><blockquote><p>这里有个坑需要注意下： 如果想在客户端即网页中通过 js 去设置 secure 类型的 cookie，必须保证网页是 https 协议的。在 http 协议的网页中是无法设置 secure 类型 cookie 的。</p></blockquote><h4 id="httpOnly"><a href="#httpOnly" class="headerlink" title="httpOnly"></a>httpOnly</h4><p>这个选项用来设置 <code>cookie</code> 是否能通过 <code>js</code> 去访问。默认情况下，<code>cookie</code> 不会带 <code>httpOnly</code> 选项(即为空)，所以默认情况下，客户端是可以通过 <code>js</code> 代码去访问（包括读取、修改、删除等）这个 <code>cookie</code> 的。当 <code>cookie</code> 带 <code>httpOnly</code> 选项时，客户端则无法通过 <code>js</code> 代码去访问（包括读取、修改、删除等）这个 <code>cookie</code>。</p><p>在客户端是不能通过 <code>js</code> 代码去设置一个 <code>httpOnly</code> 类型的 <code>cookie</code> 的，这种类型的 <code>cookie</code> 只能通过服务端来设置。</p><p>那我们在页面中怎么知道哪些 <code>cookie</code> 是 <code>httpOnly</code> 类型的呢？看下图：</p><p><img data-src="http://cdn.flqin.com/p340-5.png" alt="httpOnly"></p><p>凡是 <code>httpOnly</code> 类型的 <code>cookie</code>，其 <code>HTTP</code> 一列都会打上 <code>√</code>，如上图中的 <code>PA_VTIME</code>。你通过 <code>document.cookie</code> 是不能获取的，也不能修改 <code>PA_VTIME</code> 的。</p><blockquote><p>——httpOnly 与安全</p><p>从上面介绍中，大家是否会有这样的疑问：为什么我们要限制客户端去访问 cookie？其实这样做是为了保障安全。</p><p>试想：如果任何 cookie 都能被客户端通过 document.cookie 获取会发生什么可怕的事情。当我们的网页遭受了 XSS 攻击，有一段恶意的 script 脚本插到了网页中。这段 script 脚本做的事情是：通过 document.cookie 读取了用户身份验证相关的 cookie，并将这些 cookie 发送到了攻击者的服务器。攻击者轻而易举就拿到了用户身份验证信息，于是就可以摇摇大摆地冒充此用户访问你的服务器了（因为攻击者有合法的用户身份验证信息，所以会通过你服务器的验证）。</p></blockquote><h2 id="如何设置-cookie"><a href="#如何设置-cookie" class="headerlink" title="如何设置 cookie"></a>如何设置 cookie</h2><p>知道了 <code>cookie</code> 的格式，<code>cookie</code> 的属性选项，接下来我们就可以设置 <code>cookie</code> 了。首先得明确一点：<code>cookie</code> 既可以由服务端来设置，也可以由客户端来设置。</p><h3 id="服务端设置-cookie"><a href="#服务端设置-cookie" class="headerlink" title="服务端设置 cookie"></a>服务端设置 cookie</h3><p>不管你是请求一个资源文件（如 <code>html/js/css/图片</code>），还是发送一个 <code>ajax</code> 请求，服务端都会返回 <code>response</code>。而 <code>response header</code> 中有一项叫 <code>set-cookie</code>，是服务端专门用来设置 <code>cookie</code> 的。如下图所示，服务端返回的 <code>response header</code> 中有 5 个 <code>set-cookie</code> 字段，每个字段对应一个 <code>cookie</code>（注意不能将多个 <code>cookie</code> 放在一个 <code>set-cookie</code> 字段中），<code>set-cookie</code> 字段的值就是普通的字符串，每个 <code>cookie</code> 还设置了相关属性选项。</p><p><img data-src="http://cdn.flqin.com/p340-6.png" alt="set-Cookie"></p><p>注意：</p><ul><li>一个 <code>set-Cookie</code> 字段只能设置一个 <code>cookie</code>，当你要想设置多个 <code>cookie</code>，需要添加同样多的 <code>set-Cookie</code> 字段。</li><li>服务端可以设置 <code>cookie</code> 的所有选项：<code>expires、domain、path、secure、HttpOnly</code></li></ul><h3 id="客户端设置-cookie"><a href="#客户端设置-cookie" class="headerlink" title="客户端设置 cookie"></a>客户端设置 cookie</h3><p>在网页即客户端中我们也可以通过 <code>js</code> 代码来设置 <code>cookie</code>。如我当前打开的网址为<code>http://dxw.st.sankuai.com/mp/</code>，在控制台中我们执行了下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;name=Jonh; &#x27;</span>;</span><br></pre></td></tr></table></figure><p>查看浏览器 <code>cookie</code> 面板如下图所示，<code>cookie</code> 确实设置成功了，而且属性选项 <code>domain、path、expires</code> 都用了默认值。</p><p><img data-src="http://cdn.flqin.com/p340-7.png" alt="cookie"></p><p>再执行下面代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;age=12; expires=Thu, 26 Feb 2116 11:50:25 GMT; domain=sankuai.com; path=/&#x27;</span>;</span><br></pre></td></tr></table></figure><p>查看浏览器 <code>cookie</code> 面板，如下图所示，新的 <code>cookie</code> 设置成功了，而且属性选项 <code>domain、path、expires</code> 都变成了设定的值。</p><p><img data-src="http://cdn.flqin.com/p340-8.png" alt="cookie"></p><p>注意：</p><ul><li>客户端可以设置 <code>cookie</code> 的下列选项：<code>expires、domain、path、secure</code>（有条件：只有在 <code>https</code> 协议的网页中，客户端设置 <code>secure</code> 类型的 <code>cookie</code> 才能成功），但无法设置 <code>HttpOnly</code> 选项。</li></ul><h4 id="用-js-如何设置多个-cookie"><a href="#用-js-如何设置多个-cookie" class="headerlink" title="用 js 如何设置多个 cookie"></a>用 js 如何设置多个 cookie</h4><p>当要设置多个 <code>cookie</code> 时， <code>js</code> 代码很自然地我们会这么写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;name=Jonh; age=12; class=111&#x27;</span>;</span><br></pre></td></tr></table></figure><p>但你会发现这样写只是添加了第一个 <code>cookie</code>:<code>name=John</code>，后面的所有 <code>cookie</code> 都没有添加成功。所以最简单的设置多个 <code>cookie</code> 的方法就在重复执行 <code>document.cookie = &quot;key=name&quot;</code>，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;name=Jonh&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;age=12&#x27;</span>;</span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;class=111&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="如何修改、删除"><a href="#如何修改、删除" class="headerlink" title="如何修改、删除"></a>如何修改、删除</h2><h3 id="修改-cookie"><a href="#修改-cookie" class="headerlink" title="修改 cookie"></a>修改 cookie</h3><p>要想修改一个 <code>cookie</code>，只需要重新赋值就行，旧的值会被新的值覆盖。但要注意一点，在设置新 <code>cookie</code> 时，<code>path/domain</code> 这几个选项一定要旧 <code>cookie</code> 保持一样。否则不会修改旧值，而是添加了一个新的 <code>cookie</code>。</p><h3 id="删除-cookie"><a href="#删除-cookie" class="headerlink" title="删除 cookie"></a>删除 cookie</h3><p>删除一个 <code>cookie</code> 也挺简单，也是重新赋值，只要将这个新 <code>cookie</code> 的 <code>expires</code> 选项设置为一个过去的时间点就行了。但同样要注意，<code>path/domain/</code>这几个选项一定要旧 <code>cookie</code> 保持一样。</p><h2 id="cookie-编码"><a href="#cookie-编码" class="headerlink" title="cookie 编码"></a>cookie 编码</h2><p><code>cookie</code> 其实是个字符串，但这个字符串中逗号、分号、空格被当做了特殊符号。所以当 <code>cookie</code> 的 <code>key</code> 和 <code>value</code> 中含有这 3 个特殊字符时，需要对其进行额外编码，一般会用 <code>escape</code> 进行编码，读取时用 <code>unescape</code> 进行解码；当然也可以用 <code>encodeURIComponent/decodeURIComponent</code> 或者 <code>encodeURI/decodeURI</code>（三者的区别可以参考这篇文章）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> key = <span class="built_in">escape</span>(<span class="string">&#x27;name;value&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> value = <span class="built_in">escape</span>(<span class="string">&#x27;this is a value contain , and ;&#x27;</span>);</span><br><span class="line"><span class="built_in">document</span>.cookie = key + <span class="string">&#x27;=&#x27;</span> + value + <span class="string">&#x27;; expires=Thu, 26 Feb 2116 11:50:25 GMT; domain=sankuai.com; path=/&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="跨域请求中-cookie"><a href="#跨域请求中-cookie" class="headerlink" title="跨域请求中 cookie"></a>跨域请求中 cookie</h2><p>之前在介绍 <code>XHR</code> 的一篇文章里面提过：默认情况下，在发生跨域时，<code>cookie</code> 作为一种 <code>credential</code> 信息是不会被传送到服务端的。必须要进行额外设置才可以。具体原因和如何设置可以参考我的这篇文章：你真的会使用 <code>XMLHttpRequest</code> 吗？</p><p>另外，关于跨域资源共享 <code>CORS</code> 极力推荐大家阅读阮一峰老师的这篇 <span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTYvMDQvY29ycy5odG1s">跨域资源共享 CORS 详解<i class="fa fa-external-link-alt"></i></span>。</p><h2 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a>其他补充</h2><ol><li>什么时候 <code>cookie</code> 会被覆盖：<code>name/domain/path</code> 这 3 个字段都相同的时候；</li><li>关于 <code>domain</code> 的补充说明：</li></ol><ul><li>如果显式设置了 <code>domain</code>，则设置成什么，浏览器就存成什么；但如果没有显式设置，则浏览器会自动取 <code>url</code> 的 <code>host</code> 作为 <code>domain</code> 值；</li><li>新的规范中，显式设置 <code>domain</code> 时，如果 <code>value</code> 最前面带点，则浏览器处理时会将这个点去掉，所以最后浏览器存的就是没有点的（注意：但目前大多数浏览器并未全部这么实现）</li><li>前面带点‘.’和不带点‘.’有啥区别：<ul><li>带点：任何 <code>subdomain</code> 都可以访问，包括父 <code>domain</code></li><li>不带点：只有完全一样的域名才能访问，<code>subdomain</code> 不能（但在 <code>IE</code> 下比较特殊，它支持 <code>subdomain</code> 访问）</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> FE Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从输入URL到页面加载的过程所涉及到的知识点</title>
      <link href="336.html"/>
      <url>336.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文讲述了从输入 URL 到页面加载完成所涉及到的部分浏览器知识、网络知识、前端相关知识等，内容参考了若干大佬的文章，若有错误，烦请不吝赐教！</p></blockquote><h2 id="总览图"><a href="#总览图" class="headerlink" title="总览图"></a>总览图</h2><p><img data-src="http://cdn.flqin.com/p336-108.png" alt="从输入URL到页面加载的过程"></p><h2 id="浏览器基础"><a href="#浏览器基础" class="headerlink" title="浏览器基础"></a>浏览器基础</h2><h3 id="多进程浏览器"><a href="#多进程浏览器" class="headerlink" title="多进程浏览器"></a>多进程浏览器</h3><ul><li>1 个浏览器进程</li><li>多个渲染进程（<code>renderer</code>)</li><li>多个插件进程</li><li>1 个 <code>GPU</code> 进程</li><li>1 个网络进程</li></ul><p>多进程的好处可以避免单个 <code>page</code>、单个插件 <code>crash</code> 影响整个浏览器，也充分利用多核优势，提高浏览器稳定性，速度，安全性。</p><p>进程策略：多个 <code>tab</code> 同域名下可能会合并到一个渲染进程。通过<code>页面右上角的... -&gt; 更多工具 -&gt; 任务管理器</code>打开面板。</p><blockquote><p>进程是系统分配的独立资源，是 <code>CPU</code> 资源分配的基本单位，进程是由一个或者多个线程组成的。<br>线程是进程的执行流，是 <code>CPU</code> 调度和分派的基本单位，同个进程之中的多个线程之间是共享该进程的资源的。</p></blockquote><h3 id="进程间的交互（网页加载过程中）"><a href="#进程间的交互（网页加载过程中）" class="headerlink" title="进程间的交互（网页加载过程中）"></a>进程间的交互（网页加载过程中）</h3><ol><li><strong>浏览器进程</strong>接收到用户输入的 <code>URL</code> 请求，判断是关键词还是 <code>URL</code>(关键词则跳转默认搜索引擎搜索)，然后将该 <code>URL</code> 转发给<strong>网络进程</strong>发起真正的请求（进程间通信 <code>IPC</code>）。</li><li>得到请求来的数据后，<strong>网络进程</strong>解析响应头数据，并将数据转发给<strong>浏览器进程</strong>，进而<strong>浏览器进程</strong>发送 “确认导航” 消息到<strong>渲染进程</strong>。</li><li><strong>渲染进程</strong>收到消息后，与<strong>网络进程</strong>建立数据管道，开始准备接收 HTML 数据；准备就绪后，<strong>渲染进程</strong>向<strong>浏览器进程</strong>发送 “确认提交” 消息，浏览器开始移除旧文档，更新<strong>浏览器进程</strong>中的页面状态。</li><li>一旦文档被提交，<strong>渲染进程</strong>便开始页面解析和子资源加载，页面渲染完成后，<strong>渲染进程</strong>会发送一个消息给<strong>浏览器进程</strong>做完成处理。</li></ol><p><img data-src="http://cdn.flqin.com/p336-101.png" alt="进程间的交互"></p><h3 id="浏览器内核：渲染进程-排版引擎-浏览器引擎-页面渲染引擎-样板引擎-Blink-Webkit-等"><a href="#浏览器内核：渲染进程-排版引擎-浏览器引擎-页面渲染引擎-样板引擎-Blink-Webkit-等" class="headerlink" title="浏览器内核：渲染进程/排版引擎/浏览器引擎/页面渲染引擎/样板引擎 (Blink/Webkit 等)"></a>浏览器内核：渲染进程/排版引擎/浏览器引擎/页面渲染引擎/样板引擎 (Blink/Webkit 等)</h3><ul><li><code>GUI</code> 渲染线程<ul><li>负责渲染页面，解析 <code>HTML</code>，<code>CSS</code> 构成 <code>DOM</code> 树等，当页面重绘或者由于某种操作引起回流都会调起该线程</li><li>和 <code>JS</code> 引擎线程是互斥的，当 <code>JS</code> 引擎线程在工作的时候，<code>GUI</code> 渲染线程会被挂起，<code>GUI</code> 更新被放入在 <code>JS</code> 任务队列中，等待 <code>JS</code> 引擎线程空闲的时候继续执行</li></ul></li><li><code>JS</code> 引擎线程（如 <code>v8</code> 引擎等）<ul><li><strong>单线程工作</strong>，负责将 <code>JavaScript</code> 翻译成 CPU 指令（<code>机器码</code>）</li><li>和 <code>GUI</code> 渲染线程互斥，<code>JS</code> 运行耗时过长就会导致页面阻塞</li><li>一个浏览器 <code>Tab</code>（<code>renderer</code> 进程）只有一个 <code>js</code> 线程运行</li><li>更多见下文 v8 引擎工作原理</li></ul></li><li>事件触发线程<ul><li>控制<strong>事件循环</strong>，管理一个<strong>任务队列/事件队列</strong>，异步任务触发条件达成，将回调事件放到任务队列中</li><li>当事件符合触发条件被触发时，该线程会把对应的事件回调函数添加到<strong>任务队列</strong>的队尾，等待 <code>JS</code> 引擎处理</li></ul></li><li>定时器触发线程<ul><li><code>setInterval</code> 与 <code>setTimeout</code> 所在线程</li><li>之所以有单独的线程，是因为 <code>JS</code> 引擎阻塞会导致计时不准确</li><li>开启定时器触发线程来计时并触发计时，计时完成后会被添加到任务队列中，等待 <code>JS</code> 引擎处理</li></ul></li><li>异步 <code>http</code> 请求线程<ul><li>每次 <code>http</code> 请求的时候都会<strong>新开启一条请求线程</strong></li><li>请求完成有结果了之后，将请求的回调函数添加到任务队列中，等待 <code>JS</code> 引擎处理</li></ul></li><li>合成线程<ul><li>在 <code>GUI</code> 渲染线程后执行，将 <code>GUI</code> 渲染线程生成的待绘制列表转换为位图</li></ul></li><li>IO 线程<ul><li>用来和其他进程进行通信</li></ul></li></ul><p><code>浏览器内核</code>主要分为：</p><ul><li><code>Webkit内核</code>：苹果基于 KHTML 开发、开源的，用于 Safari，Google Chrome 之前也在使用，由 WebCore 和 JavaScriptCore 组成；</li><li><code>Blink内核</code>：是 Webkit 的一个分支，Google 开发，目前应用于 Google Chrome、Edge、Opera 等；</li></ul><p><code>JS 引擎</code>主要分为：</p><ul><li><code>SpiderMonkey</code>：第一款 JavaScript 引擎，由 Brendan Eich 开发（也就是 JavaScript 作者）</li><li><code>Chakra</code>：微软开发，用于 IT 浏览器</li><li><code>JavaScriptCore</code>：WebKit 中的 JavaScript 引擎，Apple 公司开发</li><li><code>V8</code>：Google 开发的强大 JavaScript 引擎，也帮助 Chrome 从众多浏览器中脱颖而出</li></ul><p><img data-src="http://cdn.flqin.com/p336-102.png" alt="浏览器进程与线程"></p><h3 id="web-workers"><a href="#web-workers" class="headerlink" title="web workers"></a>web workers</h3><ul><li>原理：<code>JS</code> 引擎向浏览器新申请开一个<strong>子线程</strong>，与子线程通过 <code>postMessage API</code> 通信，子线程完全受主线程控制</li><li>作用：后台运行计算，将结果发到主线程，解决单线程的 <code>JS</code> 引擎进行密集型计算会堵塞页面的问题</li><li>子线程不能影响用户界面，即不能操作 <code>dom</code> 等，在一个新的全局上下文</li><li>除了 <code>webworker</code>（属于 <code>renderer</code> 进程） 还有 <code>SharedWorker</code>（多个标签页、<code>iframe</code> 共享，不属于某个 <code>renderer</code> 进程，自己就是一个进程），<code>Service Workers</code>，<code>ChromeWorker</code> 等</li><li>更多<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvemgtQ04vZG9jcy9XZWIvQVBJL1dlYl9Xb3JrZXJzX0FQSQ==">查阅 1<i class="fa fa-external-link-alt"></i></span>,<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTgvMDcvd2ViLXdvcmtlci5odG1s">查阅 2<i class="fa fa-external-link-alt"></i></span></li></ul><h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><p><strong>用户输入网址，浏览器检查缓存后，发起 DNS 解析查询到对应 IP（应用层），根据 IP 协议找到目标服务器（网络层），通过 Mac 寻址找到服务器硬件接口（数据链路层），然后通过网线 wifi 等向服务器硬件接口传输比特信息（物理层），即开始建立 tcp 连接（传输层），如果是 HTTPS 则先建立 SSL（会话层、表示层），以上建立完成后，开始发送 HTTP 请求（应用层）。</strong></p><p>服务端的接收就是反过来的步骤。</p><h3 id="七层因特网协议栈（ISO）"><a href="#七层因特网协议栈（ISO）" class="headerlink" title="七层因特网协议栈（ISO）"></a>七层因特网协议栈（ISO）</h3><ol><li><strong>应用层(http,ftp,dns)</strong> 这一层为操作系统或网络应用程序提供访问网络服务的接口，如 DNS 解析成 IP 并发送 http 请求</li><li><strong>表示层(SSL 握手协议)</strong> 主要处理两个通信系统中交换信息的表示方式，包括数据格式交换，数据加密与解密，数据压缩与终端类型转换等</li><li><strong>会话层(SSL 记录协议)</strong> 这一层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话，如控制登陆和注销过程 (QoS)</li><li><strong>传输层(tcp,udp)</strong> 建立 tcp/udp 连接，数据的单位称为数据段（segment）（四层交换机）</li><li><strong>网络层(IP,ARP)</strong> IP 寻址，数据的单位称为数据包（packet）（路由器、三层交换机）</li><li><strong>数据链路层(PPP)</strong> 将 bit 流封装成 frame 帧（网桥、二层交换机，以太网）</li><li><strong>物理层(传输 bit 流)</strong> 物理传输（传输通过双绞线，电磁波，光纤，中继器，集线器，网线接口等各种介质）</li></ol><p><img data-src="http://cdn.flqin.com/p336-16.jpeg" alt="五层因特网协议栈"></p><ul><li><strong>ip 寻址</strong>算法包括：<strong>RIP 协议</strong>（IP 路由跳转的次数最小，适合小型网络），<strong>OSPF 协议</strong>（IP 路由跳转的速度最快，适合大型网络）。</li><li><strong>ARP 协议</strong> 是一个通过解析 <code>IP</code> 地址来找寻 <code>Mac</code> 地址的协议，<code>IP</code> 地址转换成 <code>Mac</code> 地址后，就能进行以太网数据传输了。</li><li><strong>以太网</strong>属于数据链路层，它主要负责相邻设备的通信。原理是通过查询交换机 <code>Mac</code> 表，找到通信双方的物理接口，进而开始通信。</li></ul><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p><code>URL</code> 一般包括几大部分：</p><ul><li><code>protocol</code>，协议头，譬如有 http，ftp 等</li><li><code>host</code>，主机域名或 IP 地址</li><li><code>port</code>，端口号</li><li><code>path</code>，目录路径</li><li><code>query</code>，即查询参数</li><li><code>fragment</code>，即<code>#</code>后的 hash 值，一般用来定位到某个位置</li></ul><blockquote><p><code>URI</code> 是统一资源标识符，而 <code>URL</code> 是统一资源定位符。每个 <code>URL</code> 都是 <code>URI</code>，但不一定每个 <code>URI</code> 都是 <code>URL</code>。 如 <code>URI</code>：<code>mailto：cay@horstman.com</code></p></blockquote><p>如果输入的是域名，需要进行 <code>DNS(Domain Name System，域名系统)</code> 解析成 <code>IP</code>，即<strong>域名解析</strong>。<code>DNS</code> 是一个将域名和 <code>IP</code> 地址相互映射的一个分布式数据库。根据以下优先级查找对应的 <code>IP</code> 地址：</p><ol><li>浏览器缓存</li><li>本机缓存（<code>host</code> 文件等）</li><li>本地域名解析服务器（电信，联通等运营商）</li><li><code>DNS</code> 根域名解析服务器、<code>DNS</code> 二根域名解析服务器</li></ol><blockquote><p>如果请求的是静态资源，那么流量有可能到达 CDN 服务器；如果请求的是动态资源，那么情况更加复杂，流量可能依次经过代理/网关、Web 服务器、应用服务器、数据库.</p></blockquote><p><code>dns</code> 解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑<code>dns-prefetch</code>优化。<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvbmV3cy8yMDAzMA==">减少域名 DNS 解析时间将网页加载速度提升新层次<i class="fa fa-external-link-alt"></i></span></p><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>有了 <code>IP</code> 地址之后，在 <code>http</code> 请求之前，客户端和服务器端先建立 <code>TCP</code> 连接。<strong>TCP 是一种全双工的、面向连接的、可靠的、基于字节流的传输层通信协议。</strong></p><h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><ul><li>SYN(synchronous 建立联机)同步序列号</li><li>ACK(acknowledgement 确认)应答码</li><li>PSH(push 传送)</li><li>FIN(finish 结束)</li><li>RST(reset 重置)</li><li>URG(urgent 紧急)</li><li>Sequence number(seq 顺序号码) 对方上次的 ack（首次发送时 seq 为系统随机生成）</li><li>Acknowledge number(ack 确认号码)对方的 seq+1（无数据传输时） 或者 seq+L（报文数据的长度 L）</li></ul><h4 id="三次握手的步骤"><a href="#三次握手的步骤" class="headerlink" title="三次握手的步骤"></a>三次握手的步骤</h4><p>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect() 时，将触发三次握手。</p><ol><li>客户端发送<code>SYN包</code>（SYN=1,seq=x,x 为随机数）的数据包到服务器，并进入<code>SYN_SEND</code>状态；</li><li>服务器收到<code>SYN包</code>后，发送一个<code>ACK包</code>（ACK number=x+1,ACK=1）确认，同时自己也发送一个<code>SYN包</code>（SYN=1，seq=y），即<code>SYN+ACK包</code>，此时服务器进入<code>SYN_RCVD</code>状态；</li><li>客户端收到<code>SYN＋ACK包</code>后，发送一个<code>ACK包</code>(ACK number=y+1，ACK=1)确认，发送完毕客户端进入<code>ESTABLISHED</code>状态，服务端收到包后也进入<code>ESTABLISHED</code>状态，完成三次握手</li></ol><p>建立连接成功后，接下来就正式传输数据。</p><p><img data-src="http://cdn.flqin.com/p336-22.png" alt="三次握手"></p><h4 id="四次挥手的步骤"><a href="#四次挥手的步骤" class="headerlink" title="四次挥手的步骤"></a>四次挥手的步骤</h4><p>客户端或服务器均可主动发起挥手动作，在 <code>socket</code> 编程中，任何一方执行 <code>close()</code> 操作即可产生挥手操作。假设客户端想关闭连接：</p><ol><li>客户端向服务器发送 <code>FIN=1，seq=x</code> 包，表示客户端主动要关闭连接，然后进入 <code>FIN_WAIT_1</code> 状态。（此后客户端不能再向服务器发送数据，但能读取数据。）</li><li>服务器收到 <code>FIN</code> 包后，向客户端发送 <code>ACK=1，ACKnum=x+1</code> 确认包，然后进入 <code>CLOSE_WAIT</code> 状态。（此后服务器不能再读取数据，但可以继续向客户端发送数据。同时客户端收到这个确认包后，进入 <code>FIN_WAIT_2</code> 状态）。</li><li><strong>服务器完成数据的发送后</strong>，向客户端发送 <code>FIN=1，seq=y</code> 包，然后进入 <code>LAST_ACK</code> 状态，等待客户端返回最后一个 <code>ACK</code> 包。此后服务器既不能读取数据，也不能发送数据。</li><li>客户端收到 <code>FIN</code> 包后，向服务器发送 <code>ACK=1，ACKnum=y+1</code> 确认包，然后进入 <code>TIME_WAIT</code> 状态，接着等待足够长的时间（<code>2MSL</code>），没有收到服务器端的 <code>ACK</code>，认为服务器端已经正常关闭连接，于是自己关闭链接进入 <code>CLOSED</code> 状态，释放网络资源。</li></ol><p>注：2，3 次挥手不会一起发送，当服务器收到 <code>FIN</code> 报文时，很可能并不会立即关闭 <code>SOCKET</code>，所以只能先回复一个 <code>ACK</code> 报文，告诉 <code>Client端</code>，”你发的 <code>FIN报文</code> 我收到了”。只有等到我服务器所有的报文都发送完了，我才能发送 <code>FIN报文</code>，因此不能一起发送。</p><p><img data-src="http://cdn.flqin.com/p336-23.png" alt="四次挥手"></p><h4 id="SYN-攻击"><a href="#SYN-攻击" class="headerlink" title="SYN 攻击"></a>SYN 攻击</h4><p>攻击客户端在短时间内伪造大量不存在的 IP 地址，向服务器不断地发送 SYN 包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 SYN 包将长时间占用未连接队列，正常的 SYN 请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。<strong>SYN 攻击是一种典型的 DoS/DDoS 攻击。</strong></p><p>防御：</p><ul><li>缩短超时（SYN Timeout）时间</li><li>增加最大半连接数</li><li>过滤网关防护</li><li>SYN cookies 技术</li></ul><h4 id="TCP-KeepAlive"><a href="#TCP-KeepAlive" class="headerlink" title="TCP KeepAlive"></a>TCP KeepAlive</h4><p>隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。</p><h4 id="tcp-ip-的并发限制"><a href="#tcp-ip-的并发限制" class="headerlink" title="tcp/ip 的并发限制"></a>tcp/ip 的并发限制</h4><ul><li>在 <code>HTTP/1.0</code> 中，一个服务器在发送完一个 <code>HTTP</code> 响应后，会断开 <code>TCP</code> 链接。但是这样每次请求都会重新建立和断开 <code>TCP</code> 连接，代价过大。</li><li>所以 <code>HTTP/1.1</code> 就把 Connection 头写进标准(<code>Connection: keep-alive</code>)，并且默认开启<code>持久连接</code>，除非请求中写明 <code>Connection: close</code>，那么浏览器和服务器之间是会维持一段时间的 <code>TCP</code> 连接，不会一个请求结束就断掉，这样 <code>SSL</code> 的开销也可以避免，故刷新页面也不会重新建立 <code>TCP 和 SSL</code>。（在 <code>chrome</code> 浏览器里通过 <code>network</code> 标签 -&gt; <code>connection ID</code>表示<code>TCP连接</code>的重用。）</li><li>在<code>HTTP/1.1</code>中，单个 <code>TCP连接</code> 在同一时刻只能处理一个请求，顺序处理多个请求； 在 <code>HTTP2</code> 中由于 <code>Multiplexing</code> 特点的存在，多个 <code>HTTP 请求</code> 可以在同一个 <code>TCP 连接</code> 中并行进行。</li><li>浏览器对同一域名下并发的 <code>TCP连接</code> 是有限制的（2-10 个不等），Chrome 最多允许对同一个 <code>Host</code> 建立六个 <code>TCP连接</code>。</li></ul><h4 id="get-和-post-的区别"><a href="#get-和-post-的区别" class="headerlink" title="get 和 post 的区别"></a>get 和 post 的区别</h4><ul><li><code>get</code> 安全幂等，从服务器获取资源；<code>post</code> 向 <code>URI</code> 指定的资源提交数据，数据就放在报文的 <code>body</code> 里；</li><li><code>get</code> 请求时，浏览器会把 <code>headers</code> 和 <code>data</code> 一起发送出去，服务器响应 200 返回数据（发送一个 <code>tcp</code> 数据包）；</li><li><code>post</code> 请求时，浏览器先发送<code>headers</code>，服务器响应 <code>100 continue</code>， 浏览器再发送 <code>data</code>，服务器响应 200 返回数据（发送两个 <code>tcp</code> 数据包）。</li></ul><h4 id="TCP-UDP-的区别"><a href="#TCP-UDP-的区别" class="headerlink" title="TCP/UDP 的区别"></a>TCP/UDP 的区别</h4><ul><li>TCP 是面向连接的，UDP 是面向无连接的。TCP 在通信之前必须通过三次握手机制与对方建立连接，而 UDP 通信不必与对方建立连接，不管对方的状态就直接把数据发送给对方</li><li>TCP 连接过程耗时，UDP 不耗时</li><li>TCP 连接过程中出现的延时增加了被攻击的可能，安全性不高，而 UDP 不需要连接，安全性较高</li><li>TCP 是可靠的，保证数据传输的正确性，不易丢包;UDP 是不可靠的，易丢包</li><li>TCP 传输速率较慢，实时性差，udp 传输速率较快。tcp 建立连接需要耗时，并且 tcp 首部信息太多，每次传输的有用信息较少，实时性差</li><li>TCP 是流模式，udp 是数据包模式。tcp 只要不超过缓冲区的大小就可以连续发送数据到缓冲区上，接收端只要缓冲区上有数据就可以读取，可以一次读取多个数据包，而 udp 一次只能读取一个数据包，数据包之间独立</li></ul><h4 id="TCP-可靠性的六大手段"><a href="#TCP-可靠性的六大手段" class="headerlink" title="TCP 可靠性的六大手段"></a>TCP 可靠性的六大手段</h4><ul><li><strong>顺序编号</strong>：tcp 在传输文件的时候，会将文件拆分为多个 tcp 数据包（http 请求消息太长），每个装满的数据包大小大约在 1k 左右，tcp 协议为保证可靠传输，会将这些数据包顺序编号</li><li><strong>确认机制</strong>：当数据包成功的被发送方发送给接收方，接收方会根据 tcp 协议反馈给发送方一个成功接收的 ACK 信号，信号中包含了当前包的序号（<strong>停止等待协议 ARQ</strong>）</li><li><strong>超时重传</strong>：当发送方发送数据包给接收方时，会为每一个数据包设置一个定时器，当在设定的时间内，发送方仍没有收到接收方的 ACK 信号，会再次发送该数据包，直到收到接收方的 ACK 信号或者连接已断开（<strong>停止等待协议 ARQ</strong>）</li><li><strong>校验信息</strong>：tcp 首部校验信息较多，udp 首部校验信息较少</li><li><strong>流量控制</strong>：如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。由滑动窗口协议（<strong>连续 ARQ 协议</strong>）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送</li><li><strong>拥塞控制</strong>：拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况；常用的方法就是：慢开始、拥塞避免；快重传、快恢复</li></ul><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p><code>TCP</code> 三次握手结束后，开始发送 <code>HTTP</code>（超文本传输协议，HyperText Transfer Protocol） 请求报文。</p><ul><li>HTTP 最凸出的优点是 <strong>简单、灵活和易于扩展、应用广泛和跨平台</strong>。</li><li>HTTP 最大双刃剑是 <strong>无状态、明文传输</strong>。</li><li>HTTP 最大缺点是 <strong>不安全</strong>。</li></ul><h4 id="HTTP-工作流程"><a href="#HTTP-工作流程" class="headerlink" title="HTTP 工作流程"></a>HTTP 工作流程</h4><ol><li>地址解析</li><li>封装 HTTP 请求数据包</li><li>封装成 TCP 包，建立 TCP 连接（TCP 的三次握手）</li><li>客户机发送请求命令</li><li>服务器响应</li><li>服务器关闭 TCP 连接</li></ol><p>客户机会将请求封装成 http 数据包–&gt;封装成 Tcp 数据包–&gt;封装成 Ip 数据包—&gt;封装成数据帧—&gt;硬件将帧数据转换成 bit 流（二进制数据）–&gt;最后通过物理硬件（网卡芯片）发送到指定地点。</p><p>服务器硬件首先收到 bit 流，然后转换为数据帧，然后转换成 ip 数据包。于是通过 ip 协议解析 Ip 数据包，然后又发现里面是 tcp 数据包，就通过 tcp 协议解析 Tcp 数据包，接着发现是 http 数据包通过 http 协议再解析 http 数据包得到数据。</p><h4 id="HTTP-报文结构"><a href="#HTTP-报文结构" class="headerlink" title="HTTP 报文结构"></a>HTTP 报文结构</h4><p>报文一般包括了：<code>通用头部(General)</code>，<code>请求/响应头部</code>，<code>请求/响应体</code></p><h5 id="通用头部"><a href="#通用头部" class="headerlink" title="通用头部"></a>通用头部</h5><ul><li><code>Request Url</code>: 请求的 web 服务器地址</li><li><code>Request Method</code>: 请求方式（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）</li><li><code>Status Code</code>: 请求的返回状态码，如 200 代表成功</li><li><code>Remote Address</code>: 请求的远程服务器地址（会转为 IP）</li><li><code>Referrer-Policy</code>: 控制请求头中 referrer 的内容 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81Y2Q4MWI1OTUxODgyNTY4NmEwNmZkMDU=">查阅<i class="fa fa-external-link-alt"></i></span></li></ul><p>在跨域拒绝时，可能是<code>method</code>为<code>options</code>，状态码为<code>404/405</code>等（当然，实际上可能的组合有很多）</p><p>其中，<code>Method</code>的话一般分为两批次：</p><ul><li><code>HTTP1.0</code>定义了三种请求方法：<code>GET, POST 和 HEAD方法</code>。以及几种<code>Additional Request Methods：PUT、DELETE、LINK、UNLINK</code></li><li><code>HTTP1.1</code>定义了八种请求方法：<code>GET、POST、HEAD、OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。</code></li></ul><p>列举下状态码不同范围状态的意义，更多<a href="https://blog.flqin.com/303.html">查阅</a>：</p><ul><li><code>1xx</code>——指示信息，表示请求已接收，继续处理</li><li><code>2xx</code>——成功，表示请求已被成功接收、理解、接受</li><li><code>3xx</code>——重定向，要完成请求必须进行更进一步的操作</li><li><code>4xx</code>——客户端错误，请求有语法错误或请求无法实现</li><li><code>5xx</code>——服务器端错误，服务器未能实现合法的请求</li></ul><h5 id="请求-响应头部"><a href="#请求-响应头部" class="headerlink" title="请求/响应头部"></a>请求/响应头部</h5><p>常用的请求头部（部分）：</p><ul><li><code>Accept</code>: 接收类型，表示浏览器支持的 MIME 类型，对应 <code>Content-Type</code></li><li><code>Accept-Encoding</code>：浏览器支持的压缩类型,如 gzip 等,超出类型不能接收</li><li><code>Content-Type</code>：客户端发送出去实体内容的类型</li><li><code>Cookie</code>: 有 cookie 并且同域访问时会自动带上</li><li><code>Connection</code>: 当浏览器与服务器通信时对于长连接如何进行处理,如 keep-alive</li><li><code>Host</code>：请求的服务器 URL</li><li><code>Origin</code>：最初的请求是从哪里发起的（只会精确到端口）,Origin 比 Referer 更尊重隐私</li><li><code>Referer</code>：该页面的来源 URL(适用于所有类型的请求，会精确到详细页面地址，csrf 拦截常用到这个字段)</li><li><code>User-Agent</code>：用户客户端的一些必要信息，如 UA 头部等</li><li><code>If-Modified-Since</code>：http1.0 弱缓存，对应 <code>Last-Modified</code></li><li><code>Expires</code>：http1.0 强缓存、</li><li><code>If-None-Match</code>：http1.1 弱缓存，对应 <code>ETag</code></li><li><code>Cache-Control</code>: http1.1 强缓存</li></ul><p>常用的响应头部（部分）：</p><ul><li><code>Access-Control-Allow-Headers</code>: 服务器端允许的请求 Headers</li><li><code>Access-Control-Allow-Methods</code>: 服务器端允许的请求方法</li><li><code>Access-Control-Allow-Origin</code>: 服务器端允许的请求 Origin 头部（譬如为*）</li><li><code>Content-Type</code>：服务端返回的实体内容的类型</li><li><code>Content-Length</code>：表明本次回应的数据长度</li><li><code>Content-Encoding</code>：表示服务器返回的数据使用了什么压缩格式</li><li><code>Date</code>：数据从服务器发送的时间</li><li><code>Set-Cookie</code>：设置和页面关联的 cookie，服务器通过这个头部把 cookie 传给客户端</li><li><code>Keep-Alive</code>：如果客户端有 keep-alive，服务端也会有响应（如 timeout=38）</li><li><code>Server</code>：服务器的一些相关信息</li><li><code>Cache-Control</code>：告诉浏览器或其他客户，什么环境可以安全的缓存文档</li><li><code>Last-Modified</code>：请求资源的最后修改时间</li><li><code>Expires</code>：应该在什么时候认为文档已经过期,从而不再缓存它</li><li><code>ETag</code>：请求变量的实体标签的当前值</li></ul><p>一般来说，请求头部和响应头部是匹配分析的。</p><ul><li>请求头部的<code>Accept</code>要和响应头部的<code>Content-Type</code>匹配，否则会报错</li><li>跨域请求时，请求头部的<code>Origin</code>要匹配响应头部的<code>Access-Control-Allow-Origin</code>，否则会报跨域错误</li><li>在使用缓存时，请求头部的<code>If-Modified-Since、If-None-Match</code>分别和响应头部的<code>Last-Modified、ETag</code>对应</li></ul><p><img data-src="http://cdn.flqin.com/p336-4.png" alt="http报文结构"></p><h5 id="请求-响应实体"><a href="#请求-响应实体" class="headerlink" title="请求/响应实体"></a>请求/响应实体</h5><ul><li>请求实体中会将一些需要的参数都放入进入（用于 post 请求）如实体中可以放参数的序列化形式（a=1&amp;b=2 这种），或者直接放表单对象（Form Data 对象，上传时可以夹杂参数以及文件）等等</li><li>响应实体中就是放服务端需要传给客户端的内容，一般现在的接口请求时，实体中就是对于的信息的 json 格式，而像页面请求这种，里面就是直接放了一个 html 字符串，然后浏览器自己解析并渲染。</li></ul><h4 id="Form-Data-与-Request-Payload"><a href="#Form-Data-与-Request-Payload" class="headerlink" title="Form Data 与 Request Payload"></a>Form Data 与 Request Payload</h4><p><code>post/put</code> 提交中：</p><ul><li><code>Content-Type: application/json</code> 时，为 <code>Request Payload</code> (<code>json</code>)</li><li><code>Content-Type: application/x-www-form-urlencoded</code> 或 <code>multipart/form-data</code> 时，为 <code>Form Data</code> （<code>string</code>，格式为 <code>key1=value1&amp;key2=value2</code>,类似 <code>GET</code> 请求的 <code>QueryString</code> 格式）</li></ul><p>他们只是因为 <code>Content-Type</code> 设置的不同，并不是数据提交方式的不同，这两种提交都会将数据放在 <code>message-body</code> 中。但是 <code>chrome</code> 浏览器的开发者工具会根据这个 <code>ContentType</code> 区分显示方式。</p><h4 id="CRLF"><a href="#CRLF" class="headerlink" title="CRLF"></a>CRLF</h4><p>CRLF（Carriage-Return Line-Feed），意思是回车换行，一般作为分隔符存在，请求头和实体消息之间有一个 CRLF 分隔，响应头部和响应实体之间用一个 CRLF 分隔</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CRLF-&gt;Windows-style</span><br><span class="line">LF-&gt;Unix Style</span><br><span class="line">CR-&gt;Mac Style</span><br></pre></td></tr></table></figure><h4 id="HTTP-1-1-性能瓶颈"><a href="#HTTP-1-1-性能瓶颈" class="headerlink" title="HTTP 1.1 性能瓶颈"></a>HTTP 1.1 性能瓶颈</h4><ul><li>请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 Body 的部分；</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li><li>串行的文件传输：服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；</li><li>没有请求优先级控制；</li><li>请求只能从客户端开始，服务器只能被动响应。</li></ul><h4 id="HTTP-与-TCP-IP-区别"><a href="#HTTP-与-TCP-IP-区别" class="headerlink" title="HTTP 与 TCP/IP 区别"></a>HTTP 与 TCP/IP 区别</h4><ul><li><code>TPC/IP</code> 协议是传输层协议，主要解决数据如何在网络中传输</li><li><code>HTTP</code> 是应用层协议，主要解决如何包装数据</li><li><code>WEB</code> 使用 <code>HTTP</code> 协议作应用层协议，以封装 <code>HTTP</code> 文本信息，然后使用 <code>TCP/IP</code> 做传输层协议将它发到网络上。</li></ul><h4 id="长连接与短连接"><a href="#长连接与短连接" class="headerlink" title="长连接与短连接"></a>长连接与短连接</h4><p><code>tcp/ip</code>层面：</p><ul><li>长连接：一个<code>tcp/ip</code>连接上可以连续发送多个数据包，在<code>tcp连接</code>保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持（类似于心跳包）</li><li>短连接：通信双方有数据交互时，就建立一个<code>tcp连接</code>，数据发送完成后，则断开此<code>tcp连接</code></li></ul><p><code>http</code> 层面：</p><ul><li><code>http1.0</code> 中，默认使用的是短连接，也就是说，浏览器每进行一次 <code>http</code> 操作，就建立一次连接，任务结束就中断连接，譬如每一个静态资源请求时都是一个单独的连接。</li><li><code>http1.1</code> 起，默认使用长连接，使用长连接会有这一行 <code>Connection: keep-alive</code>，在长连接的情况下，当一个网页打开完成后，客户端和服务端之间用于传输 <code>http</code> 的 <code>tcp连接</code> 不会关闭，如果客户端再次访问这个服务器的页面，会继续使用这一条已经建立的连接。</li></ul><p>注： <strong>keep-alive 不会永远保持，它有一个持续时间，一般在服务器中配置（如 apache），另外长连接需要客户端和服务器都支持时才有效。</strong></p><h4 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h4><ul><li><strong>多路复用</strong>（代替了 HTTP1.x 的序列和阻塞机制，同域名下所有通信都在单个 TCP 连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗；并且单个连接上可以并行交错请求和响应，之间互不干扰。很多<code>http1.1</code>中的优化方案就无需用到了（譬如打包成精灵图，静态资源多域名拆分等））</li><li><strong>首部压缩</strong>（<code>http</code>头部压缩（HPACK 算法），减少体积）</li><li><strong>二进制分帧</strong>（在应用层(HTTP/2)跟传输层(TCP or UDP)之间增加了一个二进制分帧层，改进传输性能，实现低延迟和高吞吐量）</li><li><strong>服务器端推送</strong>（也称为<strong>缓存推送 Push Cache</strong>，服务端可以对客户端的一个请求发出多个响应，可以主动通知客户端，当一个客户端请求资源 X，而服务器知道它很可能也需要资源 Z 的情况下，服务器可以在客户端发送请求前，主动将资源 Z 推送给客户端）</li><li><strong>请求优先级</strong>（如果数据流被赋予了优先级，它就会基于这个优先级来处理，由服务器决定需要多少资源来处理该请求。）</li></ul><h4 id="HTTP-3-0"><a href="#HTTP-3-0" class="headerlink" title="HTTP 3.0"></a>HTTP 3.0</h4><p><code>http2</code> 多路复用的关系，在出现丢包的情况下，整个 <code>TCP</code> 都要开始等待重传，也就导致了后面的所有数据都被阻塞，因此表现反而不如 <code>http1</code>，所以 Google 就更起炉灶搞了一个基于 <code>UDP</code> 协议的 <code>QUIC</code> 协议，即 <code>http3</code>。</p><p><code>QUIC</code> 新功能包括：</p><ul><li><strong>0-RTT</strong>：类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。</li><li><strong>真·多路复用</strong>：QUIC 是基于 UDP 的，一个连接上的多个 stream 之间没有依赖，不存在 TCP 队头阻塞。另外 QUIC 在移动端的表现也会比 TCP 好。因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是 QUIC 是通过 ID 的方式去识别一个连接，不管你网络环境如何变化，只要 ID 不变，就能迅速重连上。</li><li><strong>加密认证的报文</strong>：除了个别报文比如 PUBLIC_RESET 和 CHLO，所有报文头部都是经过认证的，报文 Body 都是经过加密的。</li><li><strong>向前纠错机制（FEC）</strong>：每个数据包除了它本身的内容之外，还包括了部分其他数据包的数据，因此少量的丢包可以通过其他包的冗余数据直接组装而无需重传。向前纠错牺牲了每个数据包可以发送数据的上限，但是减少了因为丢包导致的数据重传，因为数据重传将会消耗更多的时间。</li></ul><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p><code>https</code>与<code>http</code>的区别就是：在请求前，会建立<code>ssl链接</code>，确保接下来的通信都是加密的，无法被轻易截取分析。</p><h5 id="HTTPS-原理（SSL-四次握手）"><a href="#HTTPS-原理（SSL-四次握手）" class="headerlink" title="HTTPS 原理（SSL 四次握手）"></a>HTTPS 原理（SSL 四次握手）</h5><p>一般来说，主要关注的就是 <code>SSL/TLS</code> 的握手流程：</p><ol><li><p><strong>ClientHello</strong></p><p>浏览器发起 <code>https</code> 请求建立 <code>SSL链接</code>（服务器的 443 端口），并向服务端发送以下信息（第一次 <code>HTTP</code> 请求，即明文传输）：</p><ul><li>随机数 <code>Client random</code>，后面用于生成 <code>会话对称加密密钥</code></li><li>客户端支持的<code>加密方法</code>，比如 RSA 加密</li><li>客户端支持的 <code>SSL/TLS</code> 协议版本，如 TLS 1.2 版本</li></ul></li><li><p><strong>SeverHello</strong></p><p>服务器收到客户端请求后，向客户端发出响应，向客户端发送以下信息（明文传输）：</p><ul><li>随机数 <code>Server random</code>，后面用于生成 <code>会话对称加密密钥</code></li><li>确认的 <code>加密算法</code>与<code>Hash算法</code></li><li>确认 <code>SSL/ TLS</code> 协议版本，如果浏览器不支持，则关闭加密通信</li><li>服务器的<code>数字证书</code>（证书里包含了网站地址，非对称加密的公钥，以及证书颁发机构等信息）</li></ul></li><li><p><strong>浏览器回应</strong></p><blockquote><p><code>TLS</code> 来验证证书的合法性（通过浏览器或者操作系统中的 <code>CA</code> 公钥验证颁发机构是否合法，证书中包含的网址是否和正在访问的一样，过期时间等），如果证书信任则浏览器会显示一个小锁头，否则会弹出一个警告框提示证书存在问题。</p></blockquote><p>客户端接收证书后（不管信不信任），会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息（第二次 <code>HTTP</code> 请求）：</p><ul><li>新的随机数 <code>Premaster secret</code>，该随机数会被服务器公钥加密</li><li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li><li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</li></ul><p>利用 <code>Client random</code>、<code>Server random</code> 和 <code>Premaster secret</code> 通过双方协商的加密算法<strong>各自</strong>生成本次通信的 <strong>会话对称加密密钥</strong>。</p></li><li><p><strong>服务器的最后回应</strong></p><p>服务器收到客户端的第三个随机数 <code>Premaster secret</code> 之后，通过协商的加密算法计算出本次通信的 <strong>会话对称加密密钥</strong>。使用该密钥解密浏览器发来的握手消息，并验证<code>Hash</code>是否与浏览器发来的一致。然后向客户端发生最后的信息：</p><ul><li>加密通信算法改变通知，表示随后的信息都将用<strong>会话对称加密密钥</strong>加密通信。</li><li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</li></ul></li><li><p>浏览器解密并计算握手消息的 <code>HASH</code>，如果与服务端发来的 <code>HASH</code>一致，此时握手过程结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 <code>HTTP</code> 协议，只不过用<strong>会话对称加密密钥</strong>加密内容。</p></li></ol><h5 id="HTTPS-加密是在传输层"><a href="#HTTPS-加密是在传输层" class="headerlink" title="HTTPS 加密是在传输层"></a>HTTPS 加密是在传输层</h5><p><code>https</code> 报文在被包装成 <code>tcp</code> 报文的时候完成加密的过程，无论是 <code>https</code> 的 <code>header</code> 域也好，<code>body</code> 域也罢都是会被加密的。</p><p>当使用 <code>tcpdump</code> 或者 <code>wireshark</code> 之类的 <code>tcp</code> 层工具抓包，获取是加密的内容，而如果用应用层抓包，使用 <code>Charels(Mac)、Fildder(Windows)</code> 抓包工具，那当然看到是明文的。</p><h5 id="加密算法，信息摘要，数字签名，数字证书，CA"><a href="#加密算法，信息摘要，数字签名，数字证书，CA" class="headerlink" title="加密算法，信息摘要，数字签名，数字证书，CA"></a>加密算法，信息摘要，数字签名，数字证书，CA</h5><ul><li>对称加密算法：<code>AES，RC4，3DES</code>，</li><li>非对称加密算法：<code>RSA，DSA/DSS</code>，</li><li>摘要算法（哈希 <code>hash</code> 算法、散列算法）：<code>MD5，SHA1，SHA256</code>，加盐 <code>salt</code> 提升复杂度</li><li>信息摘要：通过信息摘要算法（HASH），将原信息摘要为一个固定长度的摘要</li><li>数字签名：信息摘要被私钥加密后的密文</li><li>数字证书：可以简单理解为 被 CA 承认且无法篡改的<strong>公钥</strong>，可用于验证网站是否可信（针对 <code>HTTPS</code>）、验证某文件是否可信（是否被篡改）等，也可以用一个证书来证明另一个证书是真实可信，最顶级的证书称为根证书。除了根证书（自己证明自己是可靠），其它证书都要依靠上一级的证书，来证明自己。</li><li><code>CA</code>：Certificate Authority 签发证书的权威机构</li><li>根 <code>CA``：CA</code> 的 <code>CA</code>，可以签发 <code>CA</code> 的证书</li><li>根证书：根 <code>CA</code> 的自签名证书，内置在操作系统和浏览器中</li></ul><h5 id="HTTPS-和-HTTP-的区别"><a href="#HTTPS-和-HTTP-的区别" class="headerlink" title="HTTPS 和 HTTP 的区别"></a>HTTPS 和 HTTP 的区别</h5><ol><li><code>http</code> 的信息是明文传输，连接简单无状态，<code>https</code> 则是安全性的加密传输。</li><li><code>http</code> 是直接与 <code>TCP</code> 进行数据传输，<code>https</code> 是经过一层 <code>SSL</code>（OSI 会话层），端口前者是 <code>80</code>，后者是 <code>443</code>。</li><li><code>https</code> 协议握手阶段比较费时，需要到 <code>ca</code> 申请证书或自制证书，会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电。</li><li><code>https</code> 连接缓存不如 <code>http</code> 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响。</li><li>谷歌曾在 2014 年 8 月份调整搜索引擎算法，并称“比起同等 <code>HTTP</code> 网站，采用 <code>HTTPS</code> 加密的网站在搜索结果中的排名将会更高”。</li></ol><h3 id="COOKIE"><a href="#COOKIE" class="headerlink" title="COOKIE"></a>COOKIE</h3><p><code>cookie</code>是浏览器的一种本地存储方式，一般用来帮助客户端和服务端通信的，常用来进行身份校验，结合服务端的 <code>session</code> 使用。</p><p>场景如下：</p><p>在登陆页面，用户登陆了,此时服务端会生成一个 session，session 中有对于用户的信息（如用户名、密码等），然后会有一个 sessionid（相当于是服务端的这个 session 对应的 key）。然后服务端在返回数据时，设置浏览器本地 cookie 值为:jsessionid=xxx。以后访问同域名下的页面时，自动带上 cookie 用于检验在有效时间内无需二次登陆。</p><p><a href="https://blog.flqin.com/340.html">cookie 浅析</a></p><h3 id="GZIP-压缩"><a href="#GZIP-压缩" class="headerlink" title="GZIP 压缩"></a>GZIP 压缩</h3><p>首先，明确<code>gzip</code>是一种压缩格式，需要浏览器支持才有效（不过一般现在浏览器都支持）， 而且<code>gzip</code>压缩效率很好（高达 70%左右）,一般是由<code>apache、tomcat</code>等<code>web</code>服务器开启，一般只需要在服务器上开启了<code>gzip</code>压缩，然后之后的请求就都是基于<code>gzip</code>压缩格式的，当然服务器除了<code>gzip</code>外，也还会有其它压缩格式（如 deflate，没有 gzip 高效，且不流行）。</p><h3 id="后台处理"><a href="#后台处理" class="headerlink" title="后台处理"></a>后台处理</h3><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>用户发起的请求都指向调度服务器（反向代理服务器，譬如安装了 nginx 控制负载均衡），然后调度服务器根据实际的调度算法，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器的 HTTP 响应，并将它反馈给用户。</p><h4 id="后台的处理"><a href="#后台的处理" class="headerlink" title="后台的处理"></a>后台的处理</h4><ul><li>容器接受到请求（如 tomcat 容器），经过统一的验证如安全拦截，跨域验证。如不符合规则就直接返回了相应的 http 报文（如拒绝请求等）</li><li>验证通过后，进入实际的后台代码（如 java 程序），此时程序接收到请求，然后执行（譬如查询数据库，大量计算等等）</li><li>等程序执行完毕后，就会返回一个 http 响应包（一般这一步也会经过多层封装）发送到前端，完成交互</li></ul><h2 id="前端缓存"><a href="#前端缓存" class="headerlink" title="前端缓存"></a>前端缓存</h2><p>对于一个数据请求来说，可以分为发起<code>网络请求、后端处理、浏览器响应</code>三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。</p><ul><li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li></ul><h3 id="缓存位置优先级"><a href="#缓存位置优先级" class="headerlink" title="缓存位置优先级"></a>缓存位置优先级</h3><ol><li><code>Service Worker</code></li><li><code>Memory Cache</code></li><li><code>Disk Cache（HTTP cache）</code></li><li><code>Push Cache</code></li></ol><p>都未取到则进行正式的网络请求请求最新数据。</p><h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><p><code>Service Worker</code> 是运行在浏览器背后的独立线程，传输协议必须为 <code>HTTPS</code>。他与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</p><p>实现步骤：</p><ol><li>注册 <code>Service Worker</code>，然后监听到 <code>install</code> 事件以后就可以缓存需要的文件</li><li>下次用户访问可以通过拦截请求的方式查询是否存在缓存，存在则直接读取缓存文件</li><li>如果没有命中缓存，则调用 <code>fetch</code> 函数按缓存优先级获取数据，无论此时从哪里来的数据 <code>netWork</code> 里 <code>size</code> 都将显示为 <code>Service Worker</code></li></ol><h4 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h4><ul><li>内存中的缓存，几乎所有的网络请求资源都会被浏览器自动加入到 <code>memory cache</code> 中，短期存储 (preload)</li><li>浏览器的 TAB 关闭后该次浏览的 <code>memory cache</code> 便失效</li><li>无视 HTTP 头信息，从 <code>memory cache</code> 获取缓存内容时，浏览器会忽视例如 max-age=0, no-cache 等头部配置</li><li>但 <code>Cache-control:no-store</code> 是例外，可以让 <code>memory cache</code> 失效</li></ul><h4 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h4><p><code>Disk Cache (HTTP cache)</code> 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 <code>Memory Cache</code> 胜在容量和存储时效性上。</p><h5 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h5><p><code>强制缓存（200 from cache）</code>，当客户端请求后，会先访问缓存数据库看缓存是否存在。如果存在则直接返回；不存在则请求真的服务器，响应后再写入缓存数据库。强制缓存直接减少请求数，是提升最大的缓存策略。</p><ul><li>http1.0: <code>Expires</code> 表示缓存到期时间（绝对时间），如：<code>Expires: Thu, 10 Nov 2017 08:45:11 GMT</code> (缺点：写法复杂；本地时间不准确会出现错误)</li><li>http1.1: <code>Cache-control</code> 表示缓存的最大有效时间（相对时间），如：<code>Cache-control: max-age=2592000</code> (其他值：<code>no-cache,no-store,public,private 等</code>)</li></ul><p>注：http1.0 若想实现 <code>no-cache</code>，使用 <code>Pragma: no-cache</code>，或者 <code>HTML</code> 的 <code>meta</code> 标签：<code>&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot; /&gt;</code></p><p>频繁变动的资源: <code>Cache-Control: no-cache</code><br>不常变化的资源: <code>Cache-Control: max-age=31536000</code></p><h5 id="弱缓存"><a href="#弱缓存" class="headerlink" title="弱缓存"></a>弱缓存</h5><p><code>协商缓存（304 Not Modified）、对比缓存</code>，强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。命中返回 <code>304 Not Modified</code>, 不命中返回 <code>200</code>，新资源和缓存标识存入浏览器缓存。在<strong>请求数</strong>上和没有缓存是一致的，只在响应体体积上有大幅度节省（304 时，Network size 指服务端通信报文的大小）。</p><ul><li>http1.0: <code>Last-Modified 和 If-Modified-Since</code> 根据文件修改时间判断是否过期，精确到秒。如：<code>Last-Modified: Mon, 10 Nov 2018 09:10:11 GMT</code></li><li>http1.1: <code>ETag 和 If-None-Match</code> 根据文件内容判断是否过期，如：<code>etag: &quot;FoWFkJxGtx5Edfyku7luLdv_wucA&quot;</code></li></ul><h4 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h4><p><code>Push Cache</code>（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在 Chrome 浏览器中只有 5 分钟左右，同时它也并非严格执行 HTTP 头中的缓存指令。</p><h3 id="缓存过程"><a href="#缓存过程" class="headerlink" title="缓存过程"></a>缓存过程</h3><ol><li>调用 <code>Service Worker</code> 的 <code>fetch</code> 事件响应</li><li>查看 <code>memory cache</code></li><li>查看 <code>disk cache</code><ol><li>如果有强制缓存且未失效，则使用强制缓存，不请求服务器。这时的状态码全部是 <code>200</code></li><li>如果有强制缓存但已失效，使用对比缓存，比较后确定 <code>304</code> 还是 <code>200</code></li></ol></li><li>发送网络请求，等待网络响应</li><li>把响应内容存入 <code>disk cache</code> (如果 <code>HTTP</code> 头信息配置可以存的话)</li><li>把响应内容的引用存入 <code>memory cache</code> (无视 <code>HTTP</code> 头信息的配置)</li><li>把响应内容存入 <code>Service Worker</code> 的 <code>Cache Storage</code> (如果 <code>Service Worker</code> 的脚本调用了 <code>cache.put()</code>)</li></ol><h3 id="浏览器行为"><a href="#浏览器行为" class="headerlink" title="浏览器行为"></a>浏览器行为</h3><ul><li>打开网页，地址栏输入地址： 查找 <code>disk cache</code> 中是否有匹配。如有则使用；如没有则发送网络请求。</li><li>普通刷新 (F5)：因为 TAB 并没有关闭，因此 <code>memory cache</code> 是可用的，会被优先使用(如果匹配的话)。其次才是 <code>disk cache</code>。</li><li>强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 <code>Cache-control: no-cache</code> (为了兼容，还带了 <code>Pragma: no-cache</code>),服务器直接返回 200 和最新内容。</li></ul><h2 id="页面渲染流程"><a href="#页面渲染流程" class="headerlink" title="页面渲染流程"></a>页面渲染流程</h2><p>浏览器获取到 <code>html</code> 等资源后，然后解析，渲染，通过 <code>chrome控制台-&gt;Performance-&gt;EventLog</code> 可看到解析流程。</p><h3 id="流程简述"><a href="#流程简述" class="headerlink" title="流程简述"></a>流程简述</h3><p><code>浏览器内核</code> 拿到内容后，渲染步骤分为以下几步：</p><ol><li>（<strong>DOM</strong>）解析 <code>HTML</code> 内容为 <code>DOM</code> 树</li><li>（<strong>Recalculate Style</strong>）将 <code>CSS</code>转换为 <code>styleSheets</code>，并计算出 <code>DOM</code> 节点的样式</li><li>（<strong>Layout Tree</strong>）生成布居树（渲染树），并计算元素的布局信息</li><li>（<strong>Layer Tree</strong>）对布局树进行分层（渲染层），生成图层树</li><li>（<strong>Paint</strong>）为每个图层生成绘制列表，并将其提交到合成线程</li><li>（<strong>Tiles/raster</strong>）将图层分成图块，并在光栅化线程池中将图块转换成位图</li><li>（<strong>Composite Layers</strong>）合并图层形成图片，存入 <code>GPU</code> 内存中</li><li>（<strong>DrawQuad</strong>）浏览器进程读取 <code>GPU</code> 内存，显示网页</li></ol><p>前五步在<strong>渲染线程</strong>，6，7 步在<strong>合成线程</strong>，最后一步在<strong>浏览器进程</strong>。</p><p><img data-src="http://cdn.flqin.com/p336-103.png" alt="页面渲染流程"></p><h4 id="HTML-解析，构建-DOM-树"><a href="#HTML-解析，构建-DOM-树" class="headerlink" title="HTML 解析，构建 DOM 树"></a>HTML 解析，构建 DOM 树</h4><p>即：<code>字节 -&gt; 字符 -&gt; 令牌 -&gt; 节点对象 -&gt; 对象模型</code>：</p><ul><li><strong>解码</strong>：浏览器将获得的 HTML 内容（Bytes）基于他的编码转换为单个字符</li><li><strong>令牌化</strong>：浏览器按照 HTML 规范标准将这些字符转换为不同的标记 token，每个 token 都有自己独特的含义以及规则集</li><li><strong>词法分析</strong>：生成的令牌转换成定义其属性和规则的对象（节点对象）</li><li><strong>DOM 构建</strong>：DOM 树构建完成，整个对象集合就像是一棵树形结构</li></ul><p><code>DOM</code> 树构建完成后，并且 <code>html</code> 所引用的内联外链 <code>js</code> 的同步代码都执行完毕后（不包括样式表，图片）触发 <code>DomContentLoaded</code> 事件。与 <code>async</code> 加载的脚本顺序无关，但一定加载在 <code>defer</code> 脚本执行完成之后。</p><blockquote><p>jQuery $(document).ready(()=&gt;{}); 即监听的 <code>DOMContentLoaded</code> 事件。</p></blockquote><h4 id="解析-CSS，进行样式计算"><a href="#解析-CSS，进行样式计算" class="headerlink" title="解析 CSS，进行样式计算"></a>解析 CSS，进行样式计算</h4><ul><li>格式化样式表：类似 HTML 解析，即：<code>Bytes → characters → tokens → nodes → CSSOM</code>，得到 <code>styleSheets（CSSOM）</code>。可通过 <code>document.styleSheets</code> 查看结果</li><li>标准化样式表：如 <code>em-&gt;px,red-&gt;rgba(255,0,0,0),bold-&gt;700</code></li><li>计算每个 <code>DOM</code> 节点具体样式：通过 <code>继承</code> 和 <code>层叠</code>，完成了 DOM 节点中每个元素的具体样式的计算。可通过 <code>window.getComputedStyle</code> 查看结果</li></ul><h4 id="生成布居树-Layout-Tree（渲染树-Render-Tree）"><a href="#生成布居树-Layout-Tree（渲染树-Render-Tree）" class="headerlink" title="生成布居树 Layout Tree（渲染树 Render Tree）"></a>生成布居树 Layout Tree（渲染树 Render Tree）</h4><ul><li>流览器布局系统需要额外去构建一棵只包含可见元素布局树 <strong>Layout Tree</strong>（在 DOM 树上不可见的、head、meta、display:none，最后都不会出现在布局树上）</li><li>计算布局树节点的坐标位置</li></ul><p><img data-src="http://cdn.flqin.com/p336-104.png" alt="生成布居树"></p><h4 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h4><ul><li><p>生成图层树（<code>Layer Tree</code>）</p><p>在 <code>DOM</code> 树中每个节点都会对应一个 <code>LayoutObject</code>，当他们的 <code>LayoutObject</code> 处于相同的坐标空间时，就会形成一个<code>渲染层（Render Layers）</code>。</p><blockquote><p><code>Chrome -&gt; More Tools -&gt; Layer</code> 查看层信息</p></blockquote><p><img data-src="http://cdn.flqin.com/p336-105.png" alt="布居树与图层树"></p></li><li><p>渲染引擎会为特定的节点创建单独的图层（<code>复合层/合成层</code>）</p><p>某些特殊的渲染层会被认为是<code>合成层（Compositing Layers）</code>，合成层拥有单独的 <code>图形层（GraphicsLayer）</code>，会单独分配资源，所以又称为<strong>开启 GPU 硬件加速</strong>。而其他不是合成层的渲染层，则和其第一个拥有 <code>GraphicsLayer</code> 父层公用一个。</p><ul><li>（显式合成）拥有<strong>层叠上下文</strong>属性的元素会被提升为单独一层：<code>HTML 根元素;opacity;isolation;will-change;video,canvas,iframe;position:fixed;3D transforms:translate3d、translateZ 等</code></li><li>（显式合成）需要裁剪(<code>clip</code>)的地方也会创建图层：比如一个标签很小，<code>50*50</code> 像素，你在里面放了非常多的文字，那么超出的文字部分就需要被剪裁;如果出现了滚动条，那么滚动条也会被单独提升为一个图层</li><li>（隐式合成）<code>z-index</code> 比较低的节点会提升为一个单独的图层，那么层叠等级比它高的节点都会成为一个独立的图层</li></ul><blockquote><p><code>Chrome -&gt; More Tools -&gt; Rendering -&gt; Layer borders</code>：黄色的就是复合图层信息。</p></blockquote></li></ul><p>合成层的优劣及建议：</p><ul><li>优：1.比 <code>cpu</code> 处理快（即<code>GPU 硬件加速</code>） 2.<code>repaint</code> 不会影响其他层 3.可以<a href="#%E7%9B%B4%E6%8E%A5%E5%90%88%E6%88%90">直接合成</a></li><li>劣：大量的合成层会使传输到 <code>GPU</code> 变慢，并且占用 <code>GPU</code> 和内存资源，还会出现<code>层爆炸</code></li><li>建议：动画使用 <code>transform</code> 实现; 减少隐式合成; 减小合成层的尺寸</li></ul><h4 id="图层绘制"><a href="#图层绘制" class="headerlink" title="图层绘制"></a>图层绘制</h4><p>完成了图层的构建，渲染引擎会把一个复杂的图层拆分为很小的绘制指令，然后再按照这些指令的顺序组成一个待绘制列表。</p><blockquote><p>在 <code>Chrome -&gt; More Tools -&gt; Layer-profiler</code> 可以看到绘制列表，右侧即为列表绘制过程。</p></blockquote><h4 id="栅格化"><a href="#栅格化" class="headerlink" title="栅格化"></a>栅格化</h4><p><strong>栅格化/光栅化（raster）</strong>：图块生成位图。</p><p>当图层的绘制列表准备好之后，<code>渲染线程</code>会把该绘制列表提交（commit）给<code>合成线程</code>。合成线程会将图层划分为<strong>图块 tile</strong>，按照视口附近的图块来优先生成位图。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行(这指在没有启用硬件加速的浏览器，即<strong>CPU 软件渲染</strong>)。</p><p><strong>快速栅格化、GPU 栅格化</strong>：通常，栅格化过程都会使用 <code>GPU</code> 来加速生成，渲染进程中通过 <code>GraphicsContext</code>（<code>GraphicsLayer</code> 都有一个 <code>GraphicsContext</code>）把生成位图的指令通过共享内存作为纹理上传到 <code>GPU</code> 交由 <code>GPU</code> 合成，生成的位图被保存在 <code>GPU</code> 内存中。属于<strong>GPU 硬件加速渲染</strong>.<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZGFzaG5vd29yZHMvcC8xMTg2MjgxNC5odG1s">更多介绍<i class="fa fa-external-link-alt"></i></span></p><p><img data-src="http://cdn.flqin.com/p336-106.png" alt="栅格化"></p><h4 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h4><blockquote><p>什么是合成？合成是一种将页面分成若干层，然后分别对它们进行光栅化，最后在一个单独的线程 - 合成线程（compositor thread）里面合并成一个页面的技术。当用户滚动页面时，由于页面各个层都已经被光栅化了，浏览器需要做的只是合成一个新的帧发送给 GPU 来展示滚动后的效果罢了。页面的动画效果实现也是类似，将页面上的层进行移动并构建出一个新的帧即可。</p></blockquote><p>当图层上面的图块都被栅格化后，合成线程会收集图块上面叫做<code>绘画四边形（draw quads）</code>的信息来构建一个<code>合成帧（compositor frame）</code>。</p><ul><li>绘画四边形：包含图块在内存的位置以及图层合成后图块在页面的位置之类的信息</li><li>合成帧：代表页面一个帧的内容的绘制四边形集合（60fps 指的就是这个）</li></ul><h4 id="显示"><a href="#显示" class="headerlink" title="显示"></a>显示</h4><p><strong>合成线程</strong>通过 IPC 向浏览器进程提交一个渲染帧。浏览器进程里<strong>viz 组件</strong>用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，合成帧都会被发送给 GPU 进行聚合并生成最终完整的合成表面，最后再将内存发送给显卡，最后显示在屏幕上。</p><blockquote><p>显卡：屏幕刷新频率为 60 帧，一张图片停留的时间约为 16.7 ms。而每次更新的图片都来自显卡的前缓冲区。而显卡接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到后缓冲区，然后系统自动将前缓冲区和后缓冲区对换位置，如此循环更新。如果某个动画逻辑占用大量内存，浏览器生成图像的时候会变慢，图像传送给显卡就会不及时，而显示器还是以不变的频率刷新，因此会出现卡顿，也就是明显的掉帧现象。</p></blockquote><h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><h4 id="回流（Reflow）"><a href="#回流（Reflow）" class="headerlink" title="回流（Reflow）"></a>回流（Reflow）</h4><p>也称为<code>重排（Layout）</code>。更新了元素的几何属性。需要更新完整的渲染流水线，是影响浏览器性能的关键因素。</p><ul><li>以下会触发回流：<ul><li>盒子模型相关属性会触发重布局(<code>width,height,padding,margin,display,border-width,border,min-height</code>)</li><li>定位属性及浮动也会触发重布局(<code>top,bottom,left,right,position,float,clear</code>)</li><li>改变节点内部文字结构也会触发重布局(<code>text-align,overflow-y,font-weight,overflow,font-family,line-height,vertival-align,white-space,font-size</code>)</li><li>获取某些属性也会引发回流：<ul><li><code>offset、scroll、client(Top/Left/Width/Height)</code></li><li><code>width,height</code></li><li>调用了<code>getComputedStyle()，getBoundingClientRect（）</code>或者 IE 的<code>currentStyle</code></li></ul></li></ul></li></ul><p>现代浏览器大多会对做优化都是通过<strong>队列机制来批量更新</strong>布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即 16.6ms）才会清空队列。当你获取布局信息的操作的时候，会<strong>强制队列刷新</strong>，因为队列中可能有会影响这些属性或方法返回值的操作，触发回流与重绘来确保返回正确的值。</p><h4 id="重绘（Repaint）"><a href="#重绘（Repaint）" class="headerlink" title="重绘（Repaint）"></a>重绘（Repaint）</h4><p>更新了元素的绘制属性：<code>color,border-style,border-radius,visibility,text-decoration,background,background-image,background-position,background-repeat,background-size,outline-color,outline,outline-style,outline-width,box-shadow</code>，渲染流水线直接从 <code>Paint</code> 阶段执行。</p><h4 id="直接合成"><a href="#直接合成" class="headerlink" title="直接合成"></a>直接合成</h4><p>如上面复合层已提到，使用 <code>transform</code> 实现动画效果，渲染流水线直接从 <code>tiles/raster</code> 开始，不占用渲染线程资源，大大提升绘制效率。这也是 CSS 动画比 JavaScript 动画高效的原因。（本质是利用 <code>GPU</code> 加速优先使用合成层合并属性）</p><h4 id="减少重绘与回流"><a href="#减少重绘与回流" class="headerlink" title="减少重绘与回流"></a>减少重绘与回流</h4><ul><li>用使用直接合成属性或重绘属性代替回流属性，如使用 <code>transform-&gt;top，left</code>，<code>visibility-&gt;display:none</code>等</li><li>将动画或频繁重绘回流的节点设置为单独图层，使用 <code>transform、opacity、filters、will-change</code> 触发 <code>GPU</code> 硬件加速直接合成</li><li>避免频繁操作 <code>DOM</code> 和样式，如将 <code>dom</code> 离线：<code>documentFragment</code>，<code>display:none</code>，<code>clone dom</code> 等，设置 <code>class</code> 类，一次更新</li><li>避免使用 <code>table</code> 布局，尽可能在 <code>DOM</code> 树的最末端改变 <code>class</code></li><li>避免频繁读取会引发回流/重绘的属性</li><li>避免设置多层内联样式，<code>css</code> 表达式</li></ul><h3 id="外链资源的下载"><a href="#外链资源的下载" class="headerlink" title="外链资源的下载"></a>外链资源的下载</h3><p>在解析 <code>html</code> 中会遇到一些资源连接，会单独开启一个下载线程去下载资源。</p><h4 id="遇到-CSS-样式资源"><a href="#遇到-CSS-样式资源" class="headerlink" title="遇到 CSS 样式资源"></a>遇到 CSS 样式资源</h4><ul><li><code>css</code> 加载不会阻塞 <code>DOM</code> 树解析（异步加载时 <code>DOM</code> 照常构建）</li><li>但会阻塞布局树渲染（渲染时需等 <code>css</code> 加载完毕，因为布局树需要 <code>css</code> 信息）</li><li>会阻塞后面 <code>js</code> 脚本的执行</li><li>例外：<code>media query</code>声明的<code>CSS</code>是不会阻塞渲染的</li></ul><h4 id="遇到-JS-脚本资源"><a href="#遇到-JS-脚本资源" class="headerlink" title="遇到 JS 脚本资源"></a>遇到 JS 脚本资源</h4><ul><li>阻塞浏览器的解析，当发现外链脚本时，需等待脚本下载完成并执行后才会继续解析 <code>HTML</code>，之前解析的 dom 不受影响，即 FP 可能会提前</li><li>如果是内联脚本，得等到页面所有脚本执行完后，才开始解析页面 dom</li><li>可以加上 <code>defer（延迟执行）</code> 或 <code>async（异步执行）</code>属性或 <code>document.createElement(&#39;script&#39;)</code> 来避免阻塞</li></ul><h4 id="遇到-img-图片类资源"><a href="#遇到-img-图片类资源" class="headerlink" title="遇到 img 图片类资源"></a>遇到 img 图片类资源</h4><ul><li>遇到图片等资源时，直接就是异步下载，不会阻塞解析，下载完毕后直接用图片替换原有 src 的地方。</li><li>当页面上所有的 DOM，样式表，脚本，图片都已经加载完成（包括异步），触发 <code>load</code> 事件。</li></ul><h2 id="JS-引擎解析过程"><a href="#JS-引擎解析过程" class="headerlink" title="JS 引擎解析过程"></a>JS 引擎解析过程</h2><p>前面有提到遇到 <code>JS</code> 脚本时，会等到它的执行。</p><h3 id="v8-引擎工作原理"><a href="#v8-引擎工作原理" class="headerlink" title="v8 引擎工作原理"></a>v8 引擎工作原理</h3><p>V8 是用<code>C++</code>编写的跨平台的 Google 开源高性能 JavaScript 和 WebAssembly 引擎，它用于 Chrome 和 Node.js 等，可以独立运行，也可以嵌入到任何<code>C++</code>应用程序中。</p><p><img data-src="http://cdn.flqin.com/p336-107.png" alt="v8流程图"></p><ol><li><code>js</code>源码通过<strong>词法分析</strong>(分词 tokenize)将代码分解成<strong>词元</strong>(token)，再通过<strong>语法分析</strong>(解析 parse)根据语法规则转为<strong>AST</strong>，生成抽象语法树（<code>AST</code>）和执行上下文。</li><li>通过<strong>解释器 Ignition</strong>根据<code>AST</code>生成<strong>字节码（ByteCode）</strong>（不直接转成机器码是因为其内存消耗大）</li><li>通过<strong>解释器 Ignition</strong>逐条解释执行执行字节码。如果有热点函数（函数被多次调用）就会经过<strong>编译器 TurboFan</strong>转换成优化的机器码，提高代码的执行性能。如果类型发生了变化，之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码。</li></ol><p>最终计算机执行的就是<code>CPU机器码</code>。</p><h4 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h4><p><strong>即时编译</strong>（JIT-Just In Time compiler）。解释器在解释执行字节码的同时将热点函数的字节码转换为机器码，并把转换后的机器码缓存起来。这样整个程序的运行速度能得到显著提升。</p><h3 id="JS-的执行环境"><a href="#JS-的执行环境" class="headerlink" title="JS 的执行环境"></a>JS 的执行环境</h3><p><strong>即执行上下文</strong>(execution context)。js 解释器运行阶段还会维护一个<code>环境栈(即执行栈/调用栈/栈空间 Call Stack)</code>，首次载入脚本，它将创建<code>全局执行上下文</code>，并压入环境栈栈顶（不可被弹出）。当执行流进入一个函数时，就会创建一个执行上下文，并把它压入环境栈的<code>顶部</code>，当函数执行完后会将其从环境栈<code>弹出</code>，并将控制权返回前一个执行环境。环境栈的顶端始终是当前正在执行的环境。</p><p>如果程序执行完毕被弹出执行栈，然后没有被引用（没有形成闭包），那么这个函数中用到的内存就会被垃圾处理器自动回收。</p><p>在 js 中，执行环境可以抽象的理解为一个 object，它由以下几个属性构成：</p><ul><li>作用域链(<code>Scope chain</code>)</li><li>变量对象(<code>Variable object</code>-<code>VO</code>)</li><li><code>this</code>（上下文对象）</li></ul><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>作用域链，它在解释器进入到一个执行环境时初始化完成并将其分配给当前执行环境。每个执行环境的作用域链由当前环境的<strong>变量对象</strong>及<strong>父级环境的作用域链</strong>构成。</p><p>流程简述：在函数上下文中，查找一个变量<code>foo</code>，如果函数的 <code>VO</code> 中找到了，就直接使用，否则去它的父级作用域链中（parent）找，如果父级中没找到，继续往上找，直到全局上下文中也没找到就报错。</p><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>作用域在于指定变量、函数的作用范围，即它们可以在什么范围内被访问到，也就是它们的可访问性。实际运行的时候，JS 内核通过一系列的 <code>VO/AO</code> 及其连接关系来解决变量、函数的作用域管理问题。</p><p>JavaScript 采用<strong>词法作用域(lexical scoping)，也就是静态作用域</strong>，作用域是由<strong>代码函数声明的位置</strong>来决定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global scope&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">&#x27;local scope&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br><span class="line"><span class="comment">//local scope</span></span><br></pre></td></tr></table></figure><h4 id="VO-与-AO"><a href="#VO-与-AO" class="headerlink" title="VO 与 AO"></a>VO 与 AO</h4><ul><li><p><strong>VO</strong>：每一个执行上下文都会分配一个<strong>变量对象(variable object)**，变量对象的属性由</strong>变量(variable)<strong>和</strong>函数声明(function declaration)<strong>构成。在函数上下文情况下，</strong>参数列表(parameter list)<strong>也会被加入到</strong>VO**中作为属性。变量对象与当前作用域息息相关，不同作用域的变量对象互不相同，它保存了当前作用域的所有函数和变量。</p></li><li><p><strong>AO</strong>：当函数被激活，那么一个<strong>活动对象(activation object)**就会被创建并且分配给执行上下文。活动对象由特殊对象</strong>arguments<strong>初始化而成。随后他被当做</strong>VO**用于变量初始化。</p></li><li><p>在函数上下文中：<code>VO === AO</code></p></li><li><p>在全局上下文中：<code>VO === this === global</code></p></li></ul><p>总的来说，<code>VO</code>中会存放一些变量信息（如声明的变量，函数，arguments 参数等等）</p><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2t1aXRvcy9rdWl0b3MuZ2l0aHViLmlvL2lzc3Vlcy8xOA==">一道 js 面试题引发的思考<i class="fa fa-external-link-alt"></i></span></p><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><p>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。</p><p><a href="https://blog.flqin.com/317.html">javascript 闭包概念及用法梳理</a></p><h4 id="this-指针"><a href="#this-指针" class="headerlink" title="this 指针"></a>this 指针</h4><p><strong>this 是执行上下文环境的一个属性</strong>，<a href="https://blog.flqin.com/240.html">Javascript 中神奇的 this</a></p><h3 id="回收机制"><a href="#回收机制" class="headerlink" title="回收机制"></a>回收机制</h3><p><a href="https://blog.flqin.com/259.html">V8 引擎的垃圾内存回收机制</a></p><h2 id="CSS-相关"><a href="#CSS-相关" class="headerlink" title="CSS 相关"></a>CSS 相关</h2><p>CSS 中规定每一个元素都有自己的盒子模型，然后按照规则摆放到页面上。</p><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p><a href="https://blog.flqin.com/224.html">BFC 等 Formatting Contexts 浅析</a></p><h3 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h3><p><a href="https://blog.flqin.com/208.html">css 居中完整版</a></p><h3 id="flex-amp-grid"><a href="#flex-amp-grid" class="headerlink" title="flex &amp; grid"></a>flex &amp; grid</h3><p><a href="https://blog.flqin.com/203.html">flex 布局总结</a><br><a href="https://blog.flqin.com/353.html">CSS Grid 布局</a></p><h3 id="一些属性"><a href="#一些属性" class="headerlink" title="一些属性"></a>一些属性</h3><h4 id="rem-em"><a href="#rem-em" class="headerlink" title="rem em"></a>rem em</h4><ul><li><code>em</code> 作为 <code>font-size</code> 的单位时，其代表父元素的字体大小，<code>em</code> 作为其他属性单位时，代表自身字体大小。</li><li><code>rem</code> 作用于根元素，相对于原始大小（16px），作用于非根元素，相对于根元素字体大小。</li></ul><h4 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h4><p>行高。取值包括：</p><ul><li><code>normal</code> 取决于元素的 font-family，约为 1.2</li><li><code>数字</code> 行高则为 <code>数字 * font-size</code></li><li><code>长度</code> 行高即为长度： 如 16px</li><li><code>百分比</code> 行高则为 <code>百分比 * font-size</code></li></ul><h4 id="padding-margin"><a href="#padding-margin" class="headerlink" title="padding/margin"></a>padding/margin</h4><p>内边距/外边距，取值除了普通长度（如 16px）之外，主要关注百分比：内边距/外边距即为 <code>百分比*父元素的宽度</code>，可用做高度自适应。</p><h4 id="position-fixed"><a href="#position-fixed" class="headerlink" title="position:fixed"></a>position:fixed</h4><p><code>fixed</code> 属性会创建新的层叠上下文。当元素祖先的 <code>transform</code>, <code>perspective</code> 或 <code>filter</code> 属性非 <code>none</code> 时，容器由视口改为该祖先。</p><h4 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">box-sizing</span>: content-box; <span class="comment">/*默认值，对应标准盒子模型 */</span></span><br><span class="line"><span class="attribute">box-sizing</span>: border-box; <span class="comment">/* 对应IE盒子模型，将 padding 和 border 被包含在定义的 width 和 height 之内 */</span></span><br><span class="line"><span class="attribute">box-sizing</span>: inherit; <span class="comment">/* 规定应从父元素继承 box-sizing 属性 */</span></span><br></pre></td></tr></table></figure><h4 id="CSS3-多列"><a href="#CSS3-多列" class="headerlink" title="CSS3 多列"></a>CSS3 多列</h4><ul><li><code>column-count</code></li><li><code>column-gap</code></li><li><code>column-rule</code></li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li><a href="https://blog.flqin.com/277.html">JS 原型与原型链详解</a></li><li><a href="https://blog.flqin.com/391.html">10 种常见的前端跨域解决方案</a></li><li><a href="https://blog.flqin.com/390.html">前端安全汇总</a></li><li><a href="https://blog.flqin.com/359.html">事件循环(Event Loop)</a></li><li><a href="https://blog.flqin.com/358.html">promise 实现</a></li><li><a href="https://blog.flqin.com/218.html">移动端前端适配方案总结</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> FE Summary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）深入理解“连等赋值”问题</title>
      <link href="333.html"/>
      <url>333.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接：<code>https://segmentfault.com/a/1190000004224719</code></p></blockquote><p>有这样一个热门问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">n</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a.x = a = &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;;</span><br><span class="line">alert(a.x); <span class="comment">// --&gt; undefined</span></span><br><span class="line">alert(b.x); <span class="comment">// --&gt; &#123;n: 2&#125;</span></span><br></pre></td></tr></table></figure><p>其实这个问题很好理解，关键要弄清下面两个知识点：</p><ul><li><code>JS</code> 引擎对赋值表达式的处理过程</li><li>赋值运算的右结合性</li></ul><h3 id="一-赋值表达式"><a href="#一-赋值表达式" class="headerlink" title="一. 赋值表达式"></a>一. 赋值表达式</h3><p>形如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A = B;</span><br></pre></td></tr></table></figure><p>的表达式称为<strong>赋值表达式</strong>。其中 <code>A</code> 和 <code>B</code> 又分别可以是表达式。<code>B</code> 可以是任意表达式，但是 <code>A</code> 必须是一个<strong>左值</strong>。</p><p>所谓左值，就是可以被赋值的表达式，在 <code>ES</code> 规范中是用内部类型引用(<code>Reference</code>)描述的。例如：</p><ul><li>表达式 <code>foo.bar</code> 可以作为一个左值，表示对 <code>foo</code> 这个对象中 <code>bar</code> 这个名称的引用；</li><li>变量 <code>email</code> 可以作为一个左值，表示对当前执行环境中的环境记录项 <code>envRec</code> 中 <code>email</code> 这个名称的引用</li><li>同样地，函数名 <code>func</code> 可以做左值，然而函数调用表达式 <code>func(a, b)</code>不可以。</li></ul><p>那么 <code>JS</code> 引擎是怎样计算一般的赋值表达式 <code>A = B</code> 的呢？简单地说，按如下步骤：</p><ol><li>计算表达式 <code>A</code>，得到一个引用 <code>refA</code>；</li><li>计算表达式 <code>B</code>，得到一个值 <code>valueB</code>；</li><li>将 <code>valueB</code> 赋给 <code>refA</code> 指向的名称绑定；</li><li>返回 <code>valueB</code>。</li></ol><h3 id="二-结合性"><a href="#二-结合性" class="headerlink" title="二. 结合性"></a>二. 结合性</h3><p>所谓结合性，是指表达式中同一个运算符出现多次时，是左边的优先计算还是右边的优先计算。 赋值表达式是右结合的。这意味着：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A1 = A2 = A3 = A4;</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A1 = A2 = A3 = A4;</span><br></pre></td></tr></table></figure><h3 id="三-连等的解析"><a href="#三-连等的解析" class="headerlink" title="三. 连等的解析"></a>三. 连等的解析</h3><p>好了，有了上面两部分的知识。下面来看一下 <code>JS</code> 引擎是怎样运算连等赋值表达式的。</p><p>以下面的式子为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exp1 = Exp2 = Exp3 = Exp4;</span><br></pre></td></tr></table></figure><p>首先根据右结合性，可以转换成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exp1 = Exp2 = Exp3 = Exp4;</span><br></pre></td></tr></table></figure><p>然后，我们已经知道对于单个赋值运算，<code>JS</code> 引擎总是先计算左边的操作数，再计算右边的操作数。所以接下来的步骤就是：</p><ol><li>计算 <code>Exp1</code>，得到 <code>Ref1</code>；</li><li>计算 <code>Exp2</code>，得到 <code>Ref2</code>；</li><li>计算 <code>Exp3</code>，得到 <code>Ref3</code>；</li><li>计算 <code>Exp4</code>，得到 <code>Value4</code>。</li></ol><p>现在变成了这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ref1 = Ref2 = Ref3 = Value4;</span><br></pre></td></tr></table></figure><p>接下来的步骤是：</p><ol><li>将 <code>Value4</code> 赋给 <code>Exp3</code>；</li><li>将 <code>Value4</code> 赋给 <code>Exp2</code>；</li><li>将 <code>Value4</code> 赋给 <code>Exp1</code>；</li><li>返回表达式最终的结果 <code>Value4</code>。</li></ol><p>注意：这几个步骤体现了右结合性。</p><p>总结一下就是：</p><blockquote><p>先从左到右解析各个引用，然后计算最右侧的表达式的值，最后把值从右到左赋给各个引用。</p></blockquote><h3 id="四-问题的解决"><a href="#四-问题的解决" class="headerlink" title="四. 问题的解决"></a>四. 问题的解决</h3><p>现在回到文章开头的问题。</p><p>首先前两个 <code>var</code> 语句执行完后，<code>a</code> 和 <code>b</code> 都指向同一个对象 {<code>n: 1&#125;</code> (为方便描述，下面称为对象 <code>N1</code>)。然后来看</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.x = a = &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><p>根据前面的知识，首先依次计算表达式 <code>a.x</code> 和 <code>a</code>，得到两个引用。其中 <code>a.x</code> 表示对象 <code>N1</code> 中的 <code>x</code>，而 <code>a</code> 相当于 <code>envRec.a</code>，即当前环境记录项中的 <code>a</code>。所以此时可以写出如下的形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[N1]].x = [[encRec]].a = &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure><p>其中，<code>[[]]</code> 表示引用指向的对象。</p><p>接下来，将 <code>&#123;n: 2&#125;</code> 赋值给 <code>[[encRec]].a</code>，即将 <code>&#123;n: 2&#125;</code> 绑定到当前上下文中的名称 <code>a</code>。</p><p>接下来，将同一个 <code>&#123;n: 2&#125;</code> 赋值给 <code>[[N1]].x</code>，即将 <code>&#123;n: 2&#125;</code> 绑定到 <code>N1</code> 中的名称 <code>x</code>。</p><p>由于 <code>b</code> 仍然指向 <code>N1</code>，所以此时有</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b &lt;=&gt; N1 &lt;=&gt; &#123;<span class="attr">n</span>: <span class="number">1</span>, <span class="attr">x</span>: &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>而 <code>a</code> 被重新赋值了，所以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a &lt;=&gt; &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>并且</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a === b.x;</span><br></pre></td></tr></table></figure><h3 id="五-最后的最后"><a href="#五-最后的最后" class="headerlink" title="五. 最后的最后"></a>五. 最后的最后</h3><p>如果你明白了上面所有的内容，应该会明白 <code>a.x = a = &#123;n:2&#125;;</code> 与 <code>b.x = a = &#123;n:2&#125;;</code> 是完全等价的。因为在解析 <code>a.x</code> 或 <code>b.x</code> 的那个时间点。<code>a</code> 和 <code>b</code> 这两个名称指向同一个对象，就像 <code>C++</code> 中同一个对象可以有多个引用一样。而在这个时间点之后，不论是 <code>a.x</code>还是 <code>b.x</code>，其实早就不存在了，它已经变成了 <code>那个内存中的对象.x</code> 了。</p><p>最后用一张图表示整个表达式的运算过程：</p><p><img data-src="http://cdn.flqin.com/p333-1.png" alt="连等赋值"></p>]]></content>
      
      
      <categories>
          
          <category> FE Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数去抖（debounce）与 函数节流（throttle）</title>
      <link href="325.html"/>
      <url>325.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>以下场景往往由于事件频繁被触发，因而频繁执行 <code>DOM</code> 操作、资源加载等重行为，导致 <code>UI</code> 停顿甚至浏览器崩溃。</p><ul><li><code>window</code> 对象的 <code>resize</code>、<code>scroll</code> 事件</li><li>拖拽时的 <code>mousemove</code> 事件</li><li>射击游戏中的 <code>mousedown</code>、<code>keydown</code> 事件</li><li>文字输入、自动完成的 <code>keyup</code> 事件</li></ul><p>实际上对于 <code>window</code> 的 <code>resize</code> 事件，实际需求大多为停止改变大小 <code>n</code> 毫秒后执行后续处理；而其他事件大多的需求是以一定的频率执行后续处理。针对这两种需求就出现了 <code>debounce</code> 和 <code>throttle</code> 两种解决办法。</p><h2 id="什么是-debounce（去抖）"><a href="#什么是-debounce（去抖）" class="headerlink" title="什么是 debounce（去抖）"></a>什么是 debounce（去抖）</h2><h3 id="debounce-定义"><a href="#debounce-定义" class="headerlink" title="debounce 定义"></a>debounce 定义</h3><p>如果用手指一直按住一个弹簧，它将不会弹起直到你松手为止。</p><p>也就是说当调用动作 <code>n</code> 毫秒后，才会执行该动作，若在这 <code>n</code> 毫秒内又调用此动作则将重新计算执行时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 idle，action 才会执行</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>idle   &#123;number&#125;    空闲时间，单位毫秒</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>action &#123;function&#125;  请求关联函数，实际应用需要调用的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;function&#125;</span>    </span>返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">debounce(idle, action);</span><br></pre></td></tr></table></figure><h3 id="debounce-简单实现"><a href="#debounce-简单实现" class="headerlink" title="debounce 简单实现"></a>debounce 简单实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> debounce = <span class="function"><span class="keyword">function</span> (<span class="params">idle, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> last;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ctx = <span class="built_in">this</span>,</span><br><span class="line">      args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(last);</span><br><span class="line">    last = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      action.apply(ctx, args);</span><br><span class="line">    &#125;, idle);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="如果需要立即执行一次"><a href="#如果需要立即执行一次" class="headerlink" title="如果需要立即执行一次"></a>如果需要立即执行一次</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">event, time, flag</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer);</span><br><span class="line">    <span class="keyword">if</span> (flag &amp;&amp; !timer) &#123;</span><br><span class="line">      event.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      event.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是-throttle（节流）"><a href="#什么是-throttle（节流）" class="headerlink" title="什么是 throttle（节流）"></a>什么是 throttle（节流）</h2><h3 id="throttle-定义"><a href="#throttle-定义" class="headerlink" title="throttle 定义"></a>throttle 定义</h3><p>如果将水龙头拧紧直到水是以水滴的形式流出，那你会发现每隔一段时间，就会有一滴水流出。</p><p>也就是会说预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个新周期。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 频率控制 返回函数连续调用时，action 执行频率限定为 次 / delay</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>delay  &#123;number&#125;    延迟时间，单位毫秒</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>action &#123;function&#125;  请求关联函数，实际应用需要调用的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;function&#125;</span>    </span>返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">throttle(delay, action);</span><br></pre></td></tr></table></figure><h3 id="throttle-简单实现"><a href="#throttle-简单实现" class="headerlink" title="throttle 简单实现"></a>throttle 简单实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//时间戳实现：第一次事件肯定触发，最后一次不会触发</span></span><br><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">delay, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> last = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Date</span>.now() - last &gt; delay) &#123;</span><br><span class="line">      last = <span class="built_in">Date</span>.now();</span><br><span class="line">      action.apply(<span class="built_in">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定时器实现：第一次事件不会触发，最后一次一定触发</span></span><br><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">event, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">      timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">        event.apply(<span class="built_in">this</span>, args);</span><br><span class="line">      &#125;, time);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>underscore 里有该实现，可以多多参考一下。</strong></p>]]></content>
      
      
      <categories>
          
          <category> FE Code </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）javascript闭包概念及用法梳理</title>
      <link href="317.html"/>
      <url>317.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接: <code>https://www.tangshuang.net/2368.html</code></p></blockquote><h3 id="函数内部的函数：私有函数"><a href="#函数内部的函数：私有函数" class="headerlink" title="函数内部的函数：私有函数"></a>函数内部的函数：私有函数</h3><p>首先，我们从这个内部函数去说开，因为这个是形式上的，如果一开始讲作用域，有点故意。闭包在形式上就是函数内部的函数，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = add(<span class="number">5</span>)(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>这是一个很奇怪的用法，第一次看到有 <code>function()()</code> 这样的用法？请阅读<span class="exturl" data-url="aHR0cHM6Ly93d3cudGFuZ3NodWFuZy5uZXQvMjAyMC5odG1s">这篇文章<i class="fa fa-external-link-alt"></i></span>。当执行 <code>add(5)</code> 的时候，返回的结果其实是一个函数，而再执行这个函数，需要再传入一个参数，所以就有了 <code>add(5)(10)</code> 这样的用法。当然，这是一个极端的例子，出现的太早，我们来看下最常见的一种用法吧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jQuery(<span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">message</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    alert(msg);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ($(<span class="built_in">window</span>).width() &gt; <span class="number">1000</span>) message(<span class="string">&#x27;window宽度大于1000&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果你用 <code>jquery</code>，这段代码应该经常使用吧。如果你仔细去观察就会发现，第一个 <code>function</code> 被作为参数，传给了 <code>jQuery()</code> 这个函数，而在 <code>function</code> 内，又有一个 <code>message()</code> 函数。所有的 <code>jQuery</code> 代码被放在第一个 <code>function</code> 中去处理。第二个函数就是函数体内部的函数，这个函数在函数体内声明，一旦外层函数执行完毕，那么这个函数就失去了作用，在 <code>jQuery()</code> 外无法使用 <code>message()</code>，因此，<code>message()</code> 是第一个函数内部的私有函数。</p><h3 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h3><p>函数内部的变量有两种，一种是局部变量，一种是全局变量。局部变量只在当前函数体内有效，出了函数体，就回到全局变量的范围，局部变量无效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> age + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">_age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> age + _age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params">_age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">11</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age + _age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> add();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(a(<span class="number">9</span>)); <span class="comment">// 10 : 9 + 1</span></span><br><span class="line">alert(b(<span class="number">2</span>)); <span class="comment">// 12 : 10 + 2</span></span><br><span class="line">alert(c(<span class="number">5</span>)); <span class="comment">// 16 : 11 + 5</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们看 <code>b</code> 和 <code>c</code> 函数。<code>b</code> 函数中的 <code>age</code> 直接引用了全局变量 <code>age（10</code>），而 <code>c</code> 函数中重新声明了局部变量 <code>age</code>，因此，全局变量 <code>age</code> 在 <code>c</code> 函数中无效。</p><p>但是在 <code>c</code> 中，函数内部有一个函数 <code>add()</code>，它的函数体内的 <code>age</code> 是指 <code>c</code> 中声明的局部变量，而非全局变量 <code>age</code>。从这个例子里，反映出了变量的作用域，函数内的函数体里，如果没有声明局部变量，就会承认其父级甚至祖先级函数的变量，以及全局变量。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>怎么样才算是一个闭包呢？我们来看下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> age = a();</span><br><span class="line">alert(age()); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>按照我们前面说的作用域，在上面这段代码中 <code>age</code> 是 <code>a()</code> 的局部变量，按道理出了函数就不能被访问了。但是，<code>a()</code> 返回了一个私有函数，个这个函数返回了 <code>age</code>，这导致我们可以在 <code>a()</code> 外部，仍然可以访问到本来是局部变量的 <code>age</code>，这个时候，我们就把这个内部函数称为<strong>闭包</strong>。它的原理就是<strong>函数内部的函数可以访问父函数的局部变量</strong>。</p><p>综合上面的阐述，我们要这样去理解闭包：</p><ul><li>闭包是一个函数，它使用了自己之外的变量。</li><li>闭包是一个作用域。</li><li>闭包是“由函数和与其相关的引用环境组合而成的实体”。</li><li>严格的讲，闭包常常表现为一个函数内部的函数，它使用了非自己定义的、自己所在作用域内的变量，并且使这些变量突破了作用域的限制。</li></ul><p>所以，我们文章最开头的那段代码，也有一个闭包。</p><p>一个典型的闭包：</p><ul><li>函数内的函数</li><li>这个内部函数引用了父函数的局部变量</li><li>这个内部函数使引用的变量突破了作用域限制</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">alert(fun());</span><br></pre></td></tr></table></figure><p>这也可以算作一个闭包，<code>a()</code>引用了它之外定义的变量。但是这不算严格的闭包，因为它没有在突破作用域的这个点上表现出来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + ++b;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = fun();</span><br><span class="line">alert(c()); <span class="comment">// 4</span></span><br><span class="line">alert(c()); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>这就是一个非常典型的闭包了。而且为什么 <code>alert(c())</code> 两次的值不同，我们还会在下面解释到。</p><p>为了让你更加明晰的和你曾经开发过的案例联系在一起，我们来看我们曾经做过的这样的事：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">grow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    age++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    age: getAge,</span><br><span class="line">    grow: grow,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这是我们在 <code>require.js</code> 中的一种写法，把它还原为我们熟悉的闭包模式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">10</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">grow</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    age++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    ageAge: getAge,</span><br><span class="line">    grow: grow,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cat = Cat();</span><br><span class="line"><span class="keyword">var</span> age = cat.getAge();</span><br><span class="line">alert(age); <span class="comment">// 10</span></span><br><span class="line">cat.grow();</span><br><span class="line">age = cat.getAge();</span><br><span class="line">alert(age); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><h3 id="从内存看闭包"><a href="#从内存看闭包" class="headerlink" title="从内存看闭包"></a>从内存看闭包</h3><p>现在，我们就要来解释为什么上面的 <code>alert()</code> 两次的结果不同的原因了。</p><p>首先，我们来看下普通的函数声明和使用过程中内存的变化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">alert(fun(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">alert(fun(<span class="number">3</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>上面是我们没有遇到闭包的情况，内存我们这样来画（注意，我这里只是抽象的画出内存变化，而不是真实的 <code>javascript</code> 内存机制。）</p><p><img data-src="http://cdn.flqin.com/p317-1.png" alt="闭包内存"></p><p>在每一次执行完 <code>fun()</code> 之后，<code>fun()</code>函数的执行环境被释放（回收机制）。</p><p>接下来我们来看一个闭包：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add = fun(<span class="number">2</span>);</span><br><span class="line">alert(add(<span class="number">2</span>));</span><br><span class="line">alert(add(<span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>上面就出现闭包了，注意，我们这里出现了一个 <code>add</code> 变量。</p><p><img data-src="http://cdn.flqin.com/p317-2.png" alt="闭包内存2"></p><p>在后两步中，实际上 <code>fun(2)</code> 部分没有任何变化，所变的，则是在内部函数所对应的内存区域中有变化。细心的你，可能会发现这里面的问题所在，当执行完 <code>add(2)</code> <code>之后，fun</code> 对应的内存没有被释放掉，而它的内部函数，也就是 <code>function(2)</code> 被释放掉了，在执行 <code>add(4)</code> 的时候，仅仅重新运行了内部函数。如果连 <code>fun()</code> 对应的内存出现了变化怎么办？我们来看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + ++b;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = fun();</span><br><span class="line">alert(c(<span class="number">1</span>)); <span class="comment">// 4</span></span><br><span class="line">alert(c(<span class="number">1</span>)); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>注意，这可是个非常典型的闭包的例子，它有一个局部变量 <code>b</code>，我们来看它的内存图。</p><p><img data-src="http://cdn.flqin.com/p317-3.png" alt="闭包内存3"></p><p>注意第 2、3、4 步中内存的变化。第 2 步时，我们仅仅将 <code>fun()</code> 赋给变量 <code>c</code>，这个时候，内部函数 <code>function(a)</code> 并没有被执行，所以 <code>++b</code> 也没有被执行，<code>b</code> 的值还是 2。但是第 3 步开始，<code>++b</code> 被先执行，<code>++b</code> 的意思是先自加，再进行运算，和 <code>b++</code> 是不同的，如果是 <code>b++</code>，虽然 <code>c(1)</code> 的最终结果还是为 4，但是在 <code>c(1)</code> 执行开始时，<code>b</code> 应该为 2，执行完之后才是 3。</p><p>奇妙的事情发生了，在内部函数中，<code>++b</code> 导致了局部变量值发生了变化，<code>b</code> 从 2 变成了 3，而且，内存并没有被释放，<code>fun()</code> 的执行环境没有被销毁，<code>b</code> 还被保存在内存中。到第 4 步时，b 的初始值是 3，经过 <code>++b</code> 之后，变成了 4。</p><p>这个内存分析非常形象的把闭包概念中，关于“突破作用域限制”这个点描述的非常清楚，原本按照作用域的限制，函数的局部变量不能被外部环境访问，更不能被修改，但是闭包却使得外部环境不仅可以读取到局部变量的内容，甚至可以修改它，深入一点就是：<strong>闭包会导致闭包函数所涉及到的非自身定义的变量一直保存在内存中，包括其父函数在内的相关环境都不会被销毁。</strong></p><h3 id="闭包到底有什么用"><a href="#闭包到底有什么用" class="headerlink" title="闭包到底有什么用"></a>闭包到底有什么用</h3><p>说了这么多，那闭包到底有什么用，我们为什么要使用闭包呢？从上面的阐述中，你应该已经知道了闭包的唯一作用：突破作用域限制。那如何使用这个作用为程序服务呢？</p><p>常驻内存，意味着读取速度快，（当然，内存花销也大，导致内存溢出）。常驻内存，意味着一旦初始化以后，就可以反复使用同一个内存中的某个对象，而无需再次运行程序。而这一点，是很多插件、模块的设计思想。</p><p>最好的例子就是上文我举得那个 <code>define()</code> 的例子，后面用我们今天所了解的形式去实践之后，你就会发现原来可以把 <code>function</code> 当做一个其他语言中的 <code>class</code> 来对待，<code>cat.getAge()</code>, <code>cat.grow()</code> 这样的操作是不是很符合我们在编程中的使用习惯呢？一旦一个产生之后，这个 <code>cat</code> 就一直在内存中，随时可以拿出来就用，它就是一个实例化对象。</p><p>为了更形象，我们来创建一个简单的代码块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">this</span>.weight = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.age;</span><br><span class="line">    &#125;,</span><br><span class="line">    getWeight: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.weight;</span><br><span class="line">    &#125;,</span><br><span class="line">    grow: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.age++;</span><br><span class="line">      <span class="built_in">this</span>.weight = <span class="built_in">this</span>.age * <span class="number">10</span> * <span class="number">0.8</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cat = <span class="keyword">new</span> Animal(); <span class="comment">// 继承</span></span><br><span class="line">  cat.grow = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    cat.age++;</span><br><span class="line">    cat.weight = cat.age * <span class="number">10</span> * <span class="number">0.6</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> cat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat();</span><br><span class="line">alert(cat1.getAge());</span><br><span class="line">cat1.grow();</span><br><span class="line">alert(cat1.getAge());</span><br></pre></td></tr></table></figure><p>为什么要举这个例子呢，因为我想让你想象这样一种场景，如果没有闭包怎么办？</p><p>没有闭包是这样的一种状态：函数无法访问自己父级（祖先，全局）对象的变量。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++a; <span class="comment">// 如果没有闭包机制，会undefined报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况怎么办？必须以参数的形式传入到函数中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++a;</span><br><span class="line">&#125;</span><br><span class="line">alert(add(a)); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>如果是这样，就很麻烦了，你需要在每一个函数中传入变量。而更麻烦的是，没有了作用域的突破，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  age = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">grow</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    age++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    getAge: getAge,</span><br><span class="line">    grow: grow,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line">cat.grow();</span><br><span class="line">alert(cat.getAge()); <span class="comment">// 1，没有被修改</span></span><br></pre></td></tr></table></figure><p>这种情况下，我们无论如何都无法使用这种办法来实现我们的目的。唯一能够实现的，就是按照下面这种方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = &#123;</span><br><span class="line">  age: <span class="number">1</span>,</span><br><span class="line">  weight: <span class="number">10</span>,</span><br><span class="line">  grow: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.age++;</span><br><span class="line">    <span class="built_in">this</span>.weight += <span class="number">3</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> cat1 = cat;</span><br><span class="line">alert(cat1.age);</span><br><span class="line">cat1.grow();</span><br><span class="line">alert(cat1.age);</span><br></pre></td></tr></table></figure><p>我们聪明的使用到了 <code>this</code> 关键字，但是这样一个坏处是，<code>age</code>, <code>weight</code> 这些属性直接暴露给外部，我们只需要执行 <code>cat1.age = 12</code>; 就可以马上让 <code>cat</code> 长到 <code>12</code> 岁，而体重却没任何变化。</p><p>总结而言，闭包可以带来这么几个方面的应用优势：</p><ul><li>常驻内存，加快运行速度</li><li>封装</li></ul><h3 id="闭包使用中的注意点"><a href="#闭包使用中的注意点" class="headerlink" title="闭包使用中的注意点"></a>闭包使用中的注意点</h3><p>除了上面提到的内存开销问题外，还有一个需要被注意的地方，就是闭包所引用的外部变量，在一些特殊情况下会存在与期望值不同的误差。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pAry = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;p&#x27;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pAry.length; i++) &#123;</span><br><span class="line">    pAry[i].i = i;</span><br><span class="line">    pAry[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(<span class="built_in">this</span>.i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段代码中，你希望通过一个循环，来为每一个 <code>p</code> 标签绑定一个 <code>click</code> 事件，然而不幸的是，<code>for</code> 循环中使用的闭包函数没有让你如愿以偿，在闭包函数中，<code>i</code> 被认作 <code>pAry.length</code>，也就是循环到最后 <code>i</code> 的最终值。为什么会这样呢？ 原来，闭包引用变量，而非直接使用变量，“引用”的意思是将指针指向变量的内容。由于这个原因，当 <code>i=0</code> 的时候，闭包里面的 <code>i</code> 确实是 0，但是当随着 <code>i</code> 的值变大的时候，闭包内的 <code>i</code> 并没有保存当前值，而是继续把指针指向 <code>i</code> 的内容，当你点击某个 <code>p</code> 标签的时候，<code>i</code> 的内容实际上是 <code>for</code> 到最后 <code>i</code> 的值。</p><p>同样，这个问题会出现在 <code>setTimeout，setInterval，\$.ajax</code> 等这类操作中，你只要记住，当你绑定操作时，和执行操作时，对应的变量是否已经变化就 OK 了。</p>]]></content>
      
      
      <categories>
          
          <category> FE Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）用 GitLab CI 进行持续集成</title>
      <link href="312.html"/>
      <url>312.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接: <code>https://scarletsky.github.io/2016/07/29/use-gitlab-ci-for-continuous-integration/</code></p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>从 <code>GitLab 8.0</code> 开始，<code>GitLab CI</code> 就已经集成在 <code>GitLab</code> 中，我们只要在项目中添加一个 <code>.gitlab-ci.yml</code> 文件，然后添加一个 <code>Runner</code>，即可进行持续集成。 而且随着 <code>GitLab</code> 的升级，<code>GitLab CI</code> 变得越来越强大，本文将介绍如何使用 <code>GitLab CI</code> 进行持续集成。</p><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><p>在介绍 <code>GitLab CI</code> 之前，我们先看看一些持续集成相关的概念。</p><h3 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h3><p>一次 <code>Pipeline</code> 其实相当于一次构建任务，里面可以包含多个流程，如安装依赖、运行测试、编译、部署测试服务器、部署生产服务器等流程。 任何提交或者 <code>Merge Request</code> 的合并都可以触发 <code>Pipeline</code>，如下图所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+------------------+           +----------------+</span><br><span class="line">|                  |  trigger  |                |</span><br><span class="line">|   Commit / MR    +----------&gt;+    Pipeline    |</span><br><span class="line">|                  |           |                |</span><br><span class="line">+------------------+           +----------------+</span><br></pre></td></tr></table></figure><h3 id="Stages"><a href="#Stages" class="headerlink" title="Stages"></a>Stages</h3><p><code>Stages</code> 表示构建阶段，说白了就是上面提到的流程。 我们可以在一次 <code>Pipeline</code> 中定义多个 <code>Stages</code>，这些 <code>Stages</code> 会有以下特点：</p><ul><li>所有 <code>Stages</code> 会按照顺序运行，即当一个 <code>Stage</code> 完成后，下一个 <code>Stage</code> 才会开始</li><li>只有当所有 <code>Stages</code> 完成后，该构建任务 (<code>Pipeline</code>) 才会成功</li><li>如果任何一个 <code>Stage</code> 失败，那么后面的 <code>Stages</code> 不会执行，该构建任务 (<code>Pipeline</code>) 失败</li><li>因此，<code>Stages</code> 和 <code>Pipeline</code> 的关系就是：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------------------------------------+</span><br><span class="line">| |</span><br><span class="line">| Pipeline |</span><br><span class="line">| |</span><br><span class="line">| +-----------+ +------------+ +------------+ |</span><br><span class="line">| | Stage <span class="number">1</span> |----&gt;| Stage <span class="number">2</span> |-----&gt;| Stage <span class="number">3</span> | |</span><br><span class="line">| +-----------+ +------------+ +------------+ |</span><br><span class="line">| |</span><br><span class="line">+--------------------------------------------------------+</span><br></pre></td></tr></table></figure><h3 id="Jobs"><a href="#Jobs" class="headerlink" title="Jobs"></a>Jobs</h3><p><code>Jobs</code> 表示构建工作，表示某个 <code>Stage</code> 里面执行的工作。 我们可以在 <code>Stages</code> 里面定义多个 <code>Jobs</code>，这些 <code>Jobs</code> 会有以下特点：</p><ul><li>相同 <code>Stage</code> 中的 <code>Jobs</code> 会并行执行</li><li>相同 <code>Stage</code> 中的 <code>Jobs</code> 都执行成功时，该 <code>Stage</code> 才会成功</li><li>如果任何一个 <code>Job</code> 失败，那么该 <code>Stage</code> 失败，即该构建任务 (<code>Pipeline</code>) 失败</li></ul><p>所以，<code>Jobs</code> 和 <code>Stage</code> 的关系图就是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+------------------------------------------+</span><br><span class="line">|                                          |</span><br><span class="line">|  Stage <span class="number">1</span>                                 |</span><br><span class="line">|                                          |</span><br><span class="line">|  +---------+  +---------+  +---------+   |</span><br><span class="line">|  |  Job <span class="number">1</span>  |  |  Job <span class="number">2</span>  |  |  Job <span class="number">3</span>  |   |</span><br><span class="line">|  +---------+  +---------+  +---------+   |</span><br><span class="line">|                                          |</span><br><span class="line">+------------------------------------------+</span><br></pre></td></tr></table></figure><h2 id="GitLab-Runner"><a href="#GitLab-Runner" class="headerlink" title="GitLab Runner"></a>GitLab Runner</h2><h3 id="Runner-简介"><a href="#Runner-简介" class="headerlink" title="Runner 简介"></a>Runner 简介</h3><p>理解了上面的基本概念之后，有没有觉得少了些什么东西 —— 由谁来执行这些构建任务呢？ 答案就是 <code>GitLab Runner</code> 了！</p><p>想问为什么不是 <code>GitLab CI</code> 来运行那些构建任务？ 一般来说，构建任务都会占用很多的系统资源 (譬如编译代码)，而 <code>GitLab CI</code> 又是 <code>GitLab</code> 的一部分，如果由 <code>GitLab CI</code> 来运行构建任务的话，在执行构建任务的时候，<code>GitLab</code> 的性能会大幅下降。</p><p><code>GitLab CI</code> 最大的作用是管理各个项目的构建状态，因此，运行构建任务这种浪费资源的事情就交给 <code>GitLab Runner</code> 来做拉！ 因为 <code>GitLab Runner</code> 可以安装到不同的机器上，所以在构建任务运行期间并不会影响到 <code>GitLab</code> 的性能~</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装 <code>GitLab Runner</code> 太简单了，按照着 <span class="exturl" data-url="aHR0cHM6Ly9naXRsYWIuY29tL2dpdGxhYi1vcmcvZ2l0bGFiLWNpLW11bHRpLXJ1bm5lcg==">官方文档<i class="fa fa-external-link-alt"></i></span> 的教程来就好拉！ 下面是 <code>Debian/Ubuntu/CentOS</code> 的安装方法，其他系统去参考官方文档：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For Debian/Ubuntu</span></span><br><span class="line">curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.deb.sh | sudo bash</span><br><span class="line">sudo apt-get install gitlab-ci-multi-runner</span><br><span class="line"><span class="comment"># For CentOS</span></span><br><span class="line">curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-ci-multi-runner/script.rpm.sh | sudo bash</span><br><span class="line">sudo yum install gitlab-ci-multi-runner</span><br></pre></td></tr></table></figure><h3 id="注册-Runner"><a href="#注册-Runner" class="headerlink" title="注册 Runner"></a>注册 Runner</h3><p>安装好 <code>GitLab Runner</code> 之后，我们只要启动 <code>Runner</code> 然后和 <code>CI</code> 绑定就可以了：</p><ul><li>打开你 <code>GitLab</code> 中的项目页面，在项目设置中找到 <code>runners</code></li><li>运行 <code>sudo gitlab-ci-multi-runner register</code></li><li>输入 <code>CI URL</code></li><li>输入 <code>Token</code></li><li>输入 <code>Runner</code> 的名字</li><li>选择 <code>Runner</code> 的类型，简单起见还是选 <code>Shell</code> 吧</li><li>完成</li></ul><p>当注册好 <code>Runner</code> 之后，可以用 <code>sudo gitlab-ci-multi-runner list</code> 命令来查看各个 <code>Runner</code> 的状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo gitlab-runner list</span><br><span class="line">Listing configured runners          ConfigFile=/etc/gitlab-runner/config.toml</span><br><span class="line">my-runner                           Executor=shell Token=cd1cd7cf243afb47094677855aacd3 URL=http://mygitlab.com/ci</span><br></pre></td></tr></table></figure><h2 id="gitlab-ci-yml"><a href="#gitlab-ci-yml" class="headerlink" title=".gitlab-ci.yml"></a>.gitlab-ci.yml</h2><h3 id="配置简介"><a href="#配置简介" class="headerlink" title="配置简介"></a>配置简介</h3><p>配置好 <code>Runner</code> 之后，我们要做的事情就是在项目根目录中添加 <code>.gitlab-ci.yml</code> 文件了。 当我们添加了 <code>.gitlab-ci.yml</code> 文件后，每次提交代码或者合并 <code>MR</code> 都会自动运行构建任务了。</p><p>还记得 <code>Pipeline</code> 是怎么触发的吗？<code>Pipeline</code> 也是通过提交代码或者合并 <code>MR</code> 来触发的！ 那么 <code>Pipeline</code> 和 <code>.gitlab-ci.yml</code> 有什么关系呢？ 其实 <code>.gitlab-ci.yml</code> 就是在定义 <code>Pipeline</code> 而已拉！</p><h3 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h3><p>我们先来看看 <code>.gitlab-ci.yml</code> 是怎么写的：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义 stages</span></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line"><span class="comment"># 定义 job</span></span><br><span class="line"><span class="attr">job1:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;I am job1&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;I am in test stage&quot;</span></span><br><span class="line"><span class="comment"># 定义 job</span></span><br><span class="line"><span class="attr">job2:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;I am job2&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">echo</span> <span class="string">&quot;I am in build stage&quot;</span></span><br></pre></td></tr></table></figure><p>写起来很简单吧！用 <code>stages</code> 关键字来定义 <code>Pipeline</code> 中的各个构建阶段，然后用一些非关键字来定义 <code>jobs</code>。 每个 <code>job</code> 中可以可以再用 <code>stage</code> 关键字来指定该 <code>job</code> 对应哪个 <code>stage</code>。 <code>job</code> 里面的 <code>script</code> 关键字是最关键的地方了，也是每个 <code>job</code> 中必须要包含的，它表示每个 <code>job</code> 要执行的命令。</p><p>回想一下我们之前提到的 <code>Stages</code> 和 <code>Jobs</code> 的关系，然后猜猜上面例子的运行结果？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I am job2</span><br><span class="line">I am <span class="keyword">in</span> build stage</span><br><span class="line">I am job1</span><br><span class="line">I am <span class="keyword">in</span> test stage</span><br></pre></td></tr></table></figure><p>根据我们在 <code>stages</code> 中的定义，<code>build</code> 阶段要在 <code>test</code> 阶段之前运行，所以 <code>stage:build</code> 的 <code>jobs</code> 会先运行，之后才会运行 <code>stage:test</code> 的 <code>jobs</code>。</p><h3 id="常用的关键字"><a href="#常用的关键字" class="headerlink" title="常用的关键字"></a>常用的关键字</h3><p>下面介绍一些常用的关键字，想要更加详尽的内容请前往 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdpdGxhYi5jb20vY2UvY2kveWFtbC9SRUFETUUuaHRtbA==">官方文档<i class="fa fa-external-link-alt"></i></span></p><h4 id="stages"><a href="#stages" class="headerlink" title="stages"></a>stages</h4><p>定义 <code>Stages</code>，默认有三个 <code>Stages</code>，分别是 <code>build, test, deploy</code>。</p><h4 id="types"><a href="#types" class="headerlink" title="types"></a>types</h4><p><code>stages</code> 的别名。</p><h4 id="before-script"><a href="#before-script" class="headerlink" title="before_script"></a>before_script</h4><p>定义任何 Jobs 运行前都会执行的命令。</p><h4 id="after-script"><a href="#after-script" class="headerlink" title="after_script"></a>after_script</h4><blockquote><p>要求 GitLab 8.7+ 和 GitLab Runner 1.2+</p></blockquote><p>定义任何 Jobs 运行完后都会执行的命令。</p><h4 id="variables-amp-amp-Job-variables"><a href="#variables-amp-amp-Job-variables" class="headerlink" title="variables &amp;&amp; Job.variables"></a>variables &amp;&amp; Job.variables</h4><blockquote><p>要求 GitLab Runner 0.5.0+</p></blockquote><p>定义环境变量。 如果定义了 <code>Job</code> 级别的环境变量的话，该 <code>Job</code> 会优先使用 <code>Job</code> 级别的环境变量。 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdpdGxhYi5jb20vY2UvY2kvdmFyaWFibGVzL1JFQURNRS5odG1s">查看更多<i class="fa fa-external-link-alt"></i></span></p><h4 id="cache-amp-amp-Job-cache"><a href="#cache-amp-amp-Job-cache" class="headerlink" title="cache &amp;&amp; Job.cache"></a>cache &amp;&amp; Job.cache</h4><blockquote><p>要求 GitLab Runner 0.7.0+</p></blockquote><p>定义需要缓存的文件。 每个 <code>Job</code> 开始的时候，<code>Runner</code> 都会删掉 <code>.gitignore</code> 里面的文件。 如果有些文件 (如 <code>node_modules/</code>) 需要多个 <code>Jobs</code> 共用的话，我们只能让每个 <code>Job</code> 都先执行一遍 <code>npm install</code>。 这样很不方便，因此我们需要对这些文件进行缓存。缓存了的文件除了可以跨 <code>Jobs</code> 使用外，还可以跨 <code>Pipeline</code> 使用。</p><p>具体用法请查看 <span class="exturl" data-url="aHR0cDovL2RvY3MuZ2l0bGFiLmNvbS9jZS9jaS95YW1sL1JFQURNRS5odG1sI2NhY2hl">官方文档<i class="fa fa-external-link-alt"></i></span>。</p><h4 id="Job-script"><a href="#Job-script" class="headerlink" title="Job.script"></a>Job.script</h4><p>定义 <code>Job</code> 要运行的命令，必填项。</p><h4 id="Job-stage"><a href="#Job-stage" class="headerlink" title="Job.stage"></a>Job.stage</h4><p>定义 <code>Job</code> 的 <code>stage</code>，默认为 <code>test</code>。</p><h4 id="Job-artifacts"><a href="#Job-artifacts" class="headerlink" title="Job.artifacts"></a>Job.artifacts</h4><p>定义 <code>Job</code> 中生成的附件。 当该 <code>Job</code> 运行成功后，生成的文件可以作为附件 (如生成的二进制文件) 保留下来，打包发送到 <code>GitLab</code>，之后我们可以在 <code>GitLab</code> 的项目页面下下载该附件。 注意，不要把 <code>artifacts</code> 和 <code>cache</code> 混淆了。</p><h3 id="实用例子"><a href="#实用例子" class="headerlink" title="实用例子"></a>实用例子</h3><p>下面给出一个我自己在用的例子：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">install_deps</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy_test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy_production</span></span><br><span class="line"><span class="attr">cache:</span></span><br><span class="line">  <span class="attr">key:</span> <span class="string">$&#123;CI_BUILD_REF_NAME&#125;</span></span><br><span class="line">  <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">dist/</span></span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line"><span class="attr">install_deps:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">install_deps</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">develop</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="comment"># 运行测试用例</span></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">develop</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test</span></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line"><span class="attr">build:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">develop</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">clean</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build:client</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build:server</span></span><br><span class="line"><span class="comment"># 部署测试服务器</span></span><br><span class="line"><span class="attr">deploy_test:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy_test</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">develop</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pm2</span> <span class="string">delete</span> <span class="string">app</span> <span class="string">||</span> <span class="literal">true</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pm2</span> <span class="string">start</span> <span class="string">app.js</span> <span class="string">--name</span> <span class="string">app</span></span><br><span class="line"><span class="comment"># 部署生产服务器</span></span><br><span class="line"><span class="attr">deploy_production:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy_production</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">bash</span> <span class="string">scripts/deploy/deploy.sh</span></span><br></pre></td></tr></table></figure><p>上面的配置把一次 <code>Pipeline</code> 分成五个阶段：</p><ul><li>安装依赖(<code>install_deps</code>)</li><li>运行测试(<code>test</code>)</li><li>编译(<code>build</code>)</li><li>部署测试服务器(<code>deploy_test</code>)</li><li>部署生产服务器(<code>deploy_production</code>)</li></ul><p>设置 <code>Job.only</code> 后，只有当 <code>develop</code> 分支和 <code>master</code> 分支有提交的时候才会触发相关的 <code>Jobs</code>。注意，我这里用 <code>GitLab Runner</code> 所在的服务器作为测试服务器。</p>]]></content>
      
      
      <categories>
          
          <category> FE Build </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）301、302、200、206、304、404等HTTP状态引见</title>
      <link href="303.html"/>
      <url>303.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考链接：<code>https://www.cnblogs.com/micua/p/3502691.html</code></p></blockquote><p>如果向您的服务器发出了某项请求要求显示您网站上的某个网页，那么，您的服务器会返回 <code>HTTP</code> 状态代码以响应该请求。 一些常见的状态代码为：</p><ul><li><code>200</code> - 服务器成功返回网页</li><li><code>404</code> - 请求的网页不存在</li><li><code>503</code> - 服务器暂时不可用</li></ul><p>以下提供了 <code>HTTP</code> 状态代码的完整列表。您也可以访问有关 <code>HTTP</code> 状态代码的 <span class="exturl" data-url="aHR0cHM6Ly93d3cudzMub3JnL1Byb3RvY29scy9yZmMyNjE2L3JmYzI2MTYtc2VjMTAuaHRtbA==">W3C<i class="fa fa-external-link-alt"></i></span> 来了解详细信息。</p><h2 id="1xx（临时响应）"><a href="#1xx（临时响应）" class="headerlink" title="1xx（临时响应）"></a>1xx（临时响应）</h2><p>用于表示临时响应并需要请求者执行操作才能继续的状态代码。</p><h3 id="100（继续）"><a href="#100（继续）" class="headerlink" title="100（继续）"></a>100（继续）</h3><p>请求者应当继续提出请求。服务器返回此代码则意味着，服务器已收到了请求的第一部分，现正在等待接收其余部分。</p><h3 id="101（切换协议）"><a href="#101（切换协议）" class="headerlink" title="101（切换协议）"></a>101（切换协议）</h3><p>请求者已要求服务器切换协议，服务器已确认并准备进行切换。</p><h3 id="2xx（成功）"><a href="#2xx（成功）" class="headerlink" title="2xx（成功）"></a>2xx（成功）</h3><p>用于表示服务器已成功处理了请求的状态代码。</p><h3 id="200（成功）"><a href="#200（成功）" class="headerlink" title="200（成功）"></a>200（成功）</h3><p>服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。如果您的 <code>robots.txt</code> 文件显示为此状态，那么，这表示 <code>Googlebot</code> 已成功检索到该文件。</p><h3 id="201（已创建）"><a href="#201（已创建）" class="headerlink" title="201（已创建）"></a>201（已创建）</h3><p>请求成功且服务器已创建了新的资源。</p><h3 id="202（已接受）"><a href="#202（已接受）" class="headerlink" title="202（已接受）"></a>202（已接受）</h3><p>服务器已接受了请求，但尚未对其进行处理。</p><h3 id="203（非授权信息）"><a href="#203（非授权信息）" class="headerlink" title="203（非授权信息）"></a>203（非授权信息）</h3><p>服务器已成功处理了请求，但返回了可能来自另一来源的信息。</p><h3 id="204（无内容）"><a href="#204（无内容）" class="headerlink" title="204（无内容）"></a>204（无内容）</h3><p>服务器成功处理了请求，但未返回任何内容。</p><h3 id="205（重置内容）"><a href="#205（重置内容）" class="headerlink" title="205（重置内容）"></a>205（重置内容）</h3><p>服务器成功处理了请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如清除表单内容以输入新内容）。</p><h3 id="206（部分内容）"><a href="#206（部分内容）" class="headerlink" title="206（部分内容）"></a>206（部分内容）</h3><p>服务器成功处理了部分 GET 请求。</p><h2 id="3xx（已重定向）"><a href="#3xx（已重定向）" class="headerlink" title="3xx（已重定向）"></a>3xx（已重定向）</h2><p>要完成请求，您需要进一步进行操作。通常，这些状态代码是永远重定向的。<code>Google</code> 建议您在每次请求时使用的重定向要少于 5 个。您可以使用网站管理员工具来查看 <code>Googlebot</code> 在抓取您已重定向的网页时是否会遇到问题。诊断下的抓取错误页中列出了 <code>Googlebot</code> 由于重定向错误而无法抓取的网址。</p><h3 id="300（多种选择）"><a href="#300（多种选择）" class="headerlink" title="300（多种选择）"></a>300（多种选择）</h3><p>服务器根据请求可执行多种操作。服务器可根据请求者 (<code>User agent</code>) 来选择一项操作，或提供操作列表供请求者选择。</p><h3 id="301（永久移动）"><a href="#301（永久移动）" class="headerlink" title="301（永久移动）"></a>301（永久移动）</h3><p>请求的网页已被永久移动到新位置。服务器返回此响应（作为对 <code>GET</code> 或 <code>HEAD</code> 请求的响应）时，会自动将请求者转到新位置。您应使用此代码通知 <code>Googlebot</code> 某个网页或网站已被永久移动到新位置。</p><h3 id="302（临时移动）"><a href="#302（临时移动）" class="headerlink" title="302（临时移动）"></a>302（临时移动）</h3><p>服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 <code>GET</code> 和 <code>HEAD</code> 请求的 <code>301</code> 代码类似，会自动将请求者转到不同的位置。但由于 <code>Googlebot</code> 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 <code>Googlebot</code> 某个页面或网站已被移动。</p><h3 id="303（查看其他位置）"><a href="#303（查看其他位置）" class="headerlink" title="303（查看其他位置）"></a>303（查看其他位置）</h3><p>当请求者应对不同的位置进行单独的 <code>GET</code> 请求以检索响应时，服务器会返回此代码。对于除 <code>HEAD</code> 请求之外的所有请求，服务器会自动转到其他位置。</p><h3 id="304（未修改）"><a href="#304（未修改）" class="headerlink" title="304（未修改）"></a>304（未修改）</h3><p>自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应当将服务器配置为返回此响应（称为 <code>If-Modified-Since</code> <code>HTTP</code> 标头）。由于服务器可以告诉 <code>Googlebot</code> 自从上次抓取后网页没有更改过，因此可节省带宽和开销。</p><h3 id="305（使用代理）"><a href="#305（使用代理）" class="headerlink" title="305（使用代理）"></a>305（使用代理）</h3><p>请求者只能使用代理访问请求的网页。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。</p><h3 id="307（临时重定向）"><a href="#307（临时重定向）" class="headerlink" title="307（临时重定向）"></a>307（临时重定向）</h3><p>服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 <code>GET</code> 和 <code>HEAD</code> 请求的 <code>301</code> 代码类似，会自动将请求者转到不同的位置。但由于 <code>Googlebot</code> 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 <code>Googlebot</code> 某个页面或网站已被移动。</p><h2 id="4xx（请求错误）"><a href="#4xx（请求错误）" class="headerlink" title="4xx（请求错误）"></a>4xx（请求错误）</h2><p>这些状态代码表示，请求可能出错，已妨碍了服务器对请求的处理。</p><h3 id="400（错误请求）"><a href="#400（错误请求）" class="headerlink" title="400（错误请求）"></a>400（错误请求）</h3><p>服务器不理解请求的语法。</p><h3 id="401（未授权）"><a href="#401（未授权）" class="headerlink" title="401（未授权）"></a>401（未授权）</h3><p>请求要求进行身份验证。登录后，服务器可能会返回对页面的此响应。</p><h3 id="403（已禁止）"><a href="#403（已禁止）" class="headerlink" title="403（已禁止）"></a>403（已禁止）</h3><p>服务器拒绝请求。如果在 <code>Googlebot</code> 尝试抓取您网站上的有效网页时显示此状态代码（您可在 <code>Google</code> 网站管理员工具中诊 断下的网络抓取页面上看到此状态代码），那么，这可能是您的服务器或主机拒绝 <code>Googlebot</code> 对其进行访问。</p><h3 id="404（未找到）"><a href="#404（未找到）" class="headerlink" title="404（未找到）"></a>404（未找到）</h3><p>服务器找不到请求的网页。例如，如果请求是针对服务器上不存在的网页进行的，那么，服务器通常会返回此代码。</p><p>如果您的网站上没有 <code>robots.txt</code> 文件，而您在 <code>Google</code> 网站管理员工具” 诊断”标签的 <code>robots.txt</code> 页上发现此状态，那么，这是正确的状态。然而，如果您有 <code>robots.txt</code> 文件而又发现了此状态，那么，这说明您的 <code>robots.txt</code> 文件可能是命名错误或位于错误的位置。（该文件应当位于顶级域名上，且应当名为 <code>robots.txt</code>）。</p><p>如果您在 <code>Googlebot</code> 尝试抓取的网址上发现此状态（位于”诊断”标签的 HTTP 错误页上），那么，这表示 <code>Googlebot</code> 所追踪的可能是另一网页中的无效链接（旧链接或输入有误的链接）。</p><h3 id="405（方法禁用）"><a href="#405（方法禁用）" class="headerlink" title="405（方法禁用）"></a>405（方法禁用）</h3><p>禁用请求中所指定的方法。</p><h3 id="406（不接受）"><a href="#406（不接受）" class="headerlink" title="406（不接受）"></a>406（不接受）</h3><p>无法使用请求的内容特性来响应请求的网页。</p><h3 id="407（需要代理授权）"><a href="#407（需要代理授权）" class="headerlink" title="407（需要代理授权）"></a>407（需要代理授权）</h3><p>此状态代码与 401（未授权）类似，但却指定了请求者应当使用代理进行授权。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。</p><h3 id="408（请求超时）"><a href="#408（请求超时）" class="headerlink" title="408（请求超时）"></a>408（请求超时）</h3><p>服务器等候请求时超时。</p><h3 id="409（冲突）"><a href="#409（冲突）" class="headerlink" title="409（冲突）"></a>409（冲突）</h3><p>服务器在完成请求时发生冲突。服务器必须包含有关响应中所发生的冲突的信息。服务器在响应与前一个请求相冲突的 <code>PUT</code> 请求时可能会返回此代码，同时会提供两个请求的差异列表。</p><h3 id="410（已删除）"><a href="#410（已删除）" class="headerlink" title="410（已删除）"></a>410（已删除）</h3><p>如果请求的资源已被永久删除，那么，服务器会返回此响应。该代码与 <code>404</code>（未找到）代码类似，但在资源以前有但现在已经不复存在的情况下，有时会替代 <code>404</code> 代码出现。如果资源已被永久删除，那么，您应当使用 301 代码指定该资源的新位置。</p><h3 id="411（需要有效长度）"><a href="#411（需要有效长度）" class="headerlink" title="411（需要有效长度）"></a>411（需要有效长度）</h3><p>服务器不会接受包含无效内容长度标头字段的请求。</p><h3 id="412（未满足前提条件）"><a href="#412（未满足前提条件）" class="headerlink" title="412（未满足前提条件）"></a>412（未满足前提条件）</h3><p>服务器未满足请求者在请求中设置的其中一个前提条件。</p><h3 id="413（请求实体过大）"><a href="#413（请求实体过大）" class="headerlink" title="413（请求实体过大）"></a>413（请求实体过大）</h3><p>服务器无法处理请求，因为请求实体过大，已超出服务器的处理能力。</p><h2 id="414（请求的-URI-过长）"><a href="#414（请求的-URI-过长）" class="headerlink" title="414（请求的 URI 过长）"></a>414（请求的 URI 过长）</h2><p>请求的 URI（通常为网址）过长，服务器无法进行处理。</p><h3 id="415（不支持的媒体类型）"><a href="#415（不支持的媒体类型）" class="headerlink" title="415（不支持的媒体类型）"></a>415（不支持的媒体类型）</h3><p>请求的格式不受请求页面的支持。</p><h3 id="416（请求范围不符合要求）"><a href="#416（请求范围不符合要求）" class="headerlink" title="416（请求范围不符合要求）"></a>416（请求范围不符合要求）</h3><p>如果请求是针对网页的无效范围进行的，那么，服务器会返回此状态代码。</p><h3 id="417（未满足期望值）"><a href="#417（未满足期望值）" class="headerlink" title="417（未满足期望值）"></a>417（未满足期望值）</h3><p>服务器未满足”期望”请求标头字段的要求。</p><h3 id="5xx（服务器错误）"><a href="#5xx（服务器错误）" class="headerlink" title="5xx（服务器错误）"></a>5xx（服务器错误）</h3><p>这些状态代码表示，服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错。</p><h3 id="500（服务器内部错误"><a href="#500（服务器内部错误" class="headerlink" title="500（服务器内部错误"></a>500（服务器内部错误</h3><p>服务器遇到错误，无法完成请求。</p><h3 id="501（尚未实施）"><a href="#501（尚未实施）" class="headerlink" title="501（尚未实施）"></a>501（尚未实施）</h3><p>服务器不具备完成请求的功能。例如，当服务器无法识别请求方法时，服务器可能会返回此代码。</p><h3 id="502（错误网关）"><a href="#502（错误网关）" class="headerlink" title="502（错误网关）"></a>502（错误网关）</h3><p>服务器作为网关或代理，从上游服务器收到了无效的响应。</p><h3 id="503（服务不可用）"><a href="#503（服务不可用）" class="headerlink" title="503（服务不可用）"></a>503（服务不可用）</h3><p>目前无法使用服务器（由于超载或进行停机维护）。通常，这只是一种暂时的状态。</p><h3 id="504（网关超时）"><a href="#504（网关超时）" class="headerlink" title="504（网关超时）"></a>504（网关超时）</h3><p>服务器作为网关或代理，未及时从上游服务器接收请求。</p><h3 id="505（HTTP-版本不受支持）"><a href="#505（HTTP-版本不受支持）" class="headerlink" title="505（HTTP 版本不受支持）"></a>505（HTTP 版本不受支持）</h3><p>服务器不支持相应请求中所用的 HTTP 协议版本。</p>]]></content>
      
      
      <categories>
          
          <category> FE Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）JS 原型与原型链详解</title>
      <link href="277.html"/>
      <url>277.html</url>
      
        <content type="html"><![CDATA[<h3 id="一-普通对象与函数对象"><a href="#一-普通对象与函数对象" class="headerlink" title="一. 普通对象与函数对象"></a>一. 普通对象与函数对象</h3><p><code>JavaScript</code> 中，万物皆对象！但对象也是有区别的。分为<strong>普通对象</strong>和<strong>函数对象</strong>，<code>Object</code> 、<code>Function</code> 是 <code>JS</code> 自带的函数对象。下面举例说明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> f1();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;str&#x27;</span>, <span class="string">&#x27;console.log(str)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>); <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>); <span class="comment">//function</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f1); <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f2); <span class="comment">//function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f3); <span class="comment">//function</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o1); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o2); <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o3); <span class="comment">//object</span></span><br></pre></td></tr></table></figure><p>在上面的例子中 <code>o1 o2 o3</code> 为普通对象，<code>f1 f2 f3</code> 为函数对象。怎么区分，其实很简单，<strong>凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。f1,f2,归根结底都是通过 new Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的。</strong> 一定要分清楚普通对象和函数对象，下面我们会常常用到它。</p><h3 id="二-构造函数"><a href="#二-构造函数" class="headerlink" title="二. 构造函数"></a>二. 构造函数</h3><p>我们先复习一下构造函数的知识：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.job = job;</span><br><span class="line">  <span class="built_in">this</span>.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&#x27;Zaxlct&#x27;</span>, <span class="number">28</span>, <span class="string">&#x27;Software Engineer&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&#x27;Mick&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;Doctor&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面的例子中 <code>person1</code> 和 <code>person2</code> 都是 <code>Person</code> 的<strong>实例</strong>。这两个实例都有一个 <code>constructor</code> （构造函数）属性，该属性（是一个指针）指向 <code>Person</code>。 即：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person1.constructor == Person); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.constructor == Person); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>我们要记住两个概念（构造函数，实例）： <strong>person1 和 person2 都是构造函数 Person 的实例。</strong> 一个公式： <strong>实例的构造函数属性（constructor）指向构造函数。</strong></p><h3 id="三-原型对象"><a href="#三-原型对象" class="headerlink" title="三. 原型对象"></a>三. 原型对象</h3><p>在 <code>JavaScript</code> 中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个<strong>函数对象</strong>都有一个 <code>prototype</code> 属性，这个属性指向函数的<strong>原型对象</strong>。 （先用不管什么是 <code>__proto__</code> 第二节的课程会详细的剖析）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&#x27;Zaxlct&#x27;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">28</span>;</span><br><span class="line">Person.prototype.job = <span class="string">&#x27;Software Engineer&#x27;</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName(); <span class="comment">// &#x27;Zaxlct&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName(); <span class="comment">// &#x27;Zaxlct&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person1.sayName == person2.sayName); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>我们得到了本文第一个定律：</p><p>每个对象都有 <code>proto</code> 属性，但只有函数对象才有 <code>prototype</code> 属性。</p><p>那什么是<strong>原型对象</strong>呢？ 我们把上面的例子改一改你就会明白了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Zaxlct&#x27;</span>,</span><br><span class="line">  age: <span class="number">28</span>,</span><br><span class="line">  job: <span class="string">&#x27;Software Engineer&#x27;</span>,</span><br><span class="line">  sayName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>原型对象，顾名思义，它就是一个普通对象（废话 = =!）。从现在开始你要牢牢记住原型对象就是 <code>Person.prototype</code> ，如果你还是害怕它，那就把它想想成一个字母 <code>A</code>： <code>var A = Person.prototype</code></p><p>在上面我们给 <code>A</code> 添加了 四个属性：<code>name、age、job、sayName</code>。其实它还有一个默认的属性：<code>constructor</code></p><blockquote><p>在默认情况下，所有的原型对象都会自动获得一个 <code>constructor</code>（构造函数）属性，这个属性（是一个指针）指向 <code>prototype</code> 属性所在的函数（Person）</p></blockquote><p>上面这句话有点拗口，我们「翻译」一下：A 有一个默认的 <code>constructor</code> 属性，这个属性是一个指针，指向 <code>Person</code>。即： <code>Person.prototype.constructor == Person</code></p><p>在上面第二小节《构造函数》里，我们知道实例的构造函数属性（<code>constructor</code>）指向构造函数 ：<code>person1.constructor == Person</code></p><p>这两个「公式」好像有点联系：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person1.constructor == Person;</span><br><span class="line">Person.prototype.constructor == Person;</span><br></pre></td></tr></table></figure><p><code>person1</code> 为什么有 <code>constructor</code> 属性？那是因为 <code>person1</code> 是 <code>Person</code> 的实例。 那 <code>Person.prototype</code> 为什么有 <code>constructor</code> 属性？？同理， <code>Person.prototype</code> （你把它想象成 <code>A</code>） 也是 <code>Person</code> 的实例。 也就是在 <code>Person</code> 创建的时候，创建了一个它的实例对象并赋值给它的 <code>prototype</code>，基本过程如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype = A;</span><br></pre></td></tr></table></figure><p><strong>结论：原型对象（Person.prototype）是 构造函数（Person）的一个实例。</strong></p><p>原型对象其实就是普通对象（但 F<code>unction.prototype</code> 除外，它是函数对象，但它很特殊，他没有 <code>prototype</code> 属性（前面说道函数对象都有 <code>prototype</code> 属性））。看下面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype); <span class="comment">//Person&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person.prototype); <span class="comment">//Object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype); <span class="comment">// Function，这个特殊</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype); <span class="comment">// Object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype.prototype); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p><code>Function.prototype</code> 为什么是函数对象呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line"><span class="built_in">Function</span>.prototype = A;</span><br></pre></td></tr></table></figure><p><strong>上文提到凡是通过 new Function( ) 产生的对象都是函数对象。因为 A 是函数对象，所以 Function.prototype 是函数对象。</strong></p><p>那原型对象是用来做什么的呢？主要作用是用于继承。举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name; <span class="comment">// tip: 当函数执行时这个 this 指的是谁？</span></span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name; <span class="comment">// tip: 当函数执行时这个 this 指的是谁？</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> person(<span class="string">&#x27;Mick&#x27;</span>);</span><br><span class="line">person1.getName(); <span class="comment">//Mick</span></span><br></pre></td></tr></table></figure><p>从这个例子可以看出，通过给 <code>Person.prototype</code> 设置了一个函数对象的属性，那有 <code>Person</code> 的实例（<code>person1</code>）出来的普通对象就继承了这个属性。具体是怎么实现的继承，就要讲到下面的原型链了。</p><p>小问题，上面两个 <code>this</code> 都指向谁？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> person(<span class="string">&#x27;Mick&#x27;</span>);</span><br><span class="line">person1.name = <span class="string">&#x27;Mick&#x27;</span>; <span class="comment">// 此时 person1 已经有 name 这个属性了</span></span><br><span class="line">person1.getName(); <span class="comment">//Mick</span></span><br></pre></td></tr></table></figure><p>故两次 <code>this</code> 在函数执行时都指向 <code>person1</code>。</p><h3 id="四-proto"><a href="#四-proto" class="headerlink" title="四. __proto__"></a>四. <code>__proto__</code></h3><p><code>JS</code> 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做<code>__proto__</code>的内置属性，用于指向创建它的构造函数的原型对象。 对象 <code>person1</code> 有一个<code>__proto__</code>属性，创建它的构造函数是 <code>Person</code>，构造函数的原型对象是 P<code>erson.prototype</code>，所以： <code>person1.__proto__ == Person.prototype</code></p><p><img data-src="http://cdn.flqin.com/p277-1.jpg" alt="__proto__"></p><p>根据上面这个连接图，我们能得到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.constructor == Person;</span><br><span class="line">person1.__proto__ == Person.prototype;</span><br><span class="line">person1.constructor == Person;</span><br></pre></td></tr></table></figure><p><strong>不过，要明确的真正重要的一点就是，这个连接存在于实例（<code>person1</code>）与构造函数（<code>Person</code>）的原型对象（<code>Person.prototype</code>）之间，而不是存在于实例（<code>person1</code>）与构造函数（<code>Person</code>）之间。</strong></p><p>注意：因为绝大部分浏览器都支持<code>__proto__</code>属性，所以它才被加入了 <code>ES6</code> 里（<code>ES5</code> 部分浏览器也支持，但还不是标准）。</p><h3 id="五-构造器"><a href="#五-构造器" class="headerlink" title="五. 构造器"></a>五. 构造器</h3><p>熟悉 <code>Javascript</code> 的童鞋都知道，我们可以这样创建一个对象： <code>var obj = &#123;&#125;</code> 它等同于下面这样： <code>var obj = new Object()</code></p><p><code>obj</code> 是构造函数（<code>Object</code>）的一个实例。所以： <code>obj.constructor === Object</code> <code>obj.__proto__ === Object.prototype</code></p><p>新对象 <code>obj</code> 是使用 <code>new</code> 操作符后跟一个<strong>构造函数</strong>来创建的。构造函数（<code>Object</code>）本身就是一个函数（就是上面说的函数对象），它和上面的构造函数 <code>Person</code> 差不多。只不过该函数是出于创建新对象的目的而定义的。所以不要被 <code>Object</code> 吓倒。</p><p>同理，可以创建对象的构造器不仅仅有 <code>Object</code>，也可以是 <code>Array，Date，Function</code> 等。 所以我们也可以构造函数来创建 <code>Array、 Date、Function</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">b.constructor === <span class="built_in">Array</span>;</span><br><span class="line">b.__proto__ === <span class="built_in">Array</span>.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">c.constructor === <span class="built_in">Date</span>;</span><br><span class="line">c.__proto__ === <span class="built_in">Date</span>.prototype;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Function</span>();</span><br><span class="line">d.constructor === <span class="built_in">Function</span>;</span><br><span class="line">d.__proto__ === <span class="built_in">Function</span>.prototype;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>,<span class="built_in">Function</span>,<span class="built_in">Array</span>,<span class="built_in">Date</span>,<span class="built_in">Number</span>,<span class="built_in">String</span>,<span class="built_in">Boolean</span> 这些构造器都是函数对象.</span><br></pre></td></tr></table></figure><h3 id="六-原型链"><a href="#六-原型链" class="headerlink" title="六. 原型链"></a>六. 原型链</h3><p>小测试来检验一下你理解的怎么样：</p><p>1.<code>person1.__proto__</code> 是什么？ 2.<code>Person.__proto__</code> 是什么？ 3.<code>Person.prototype.__proto__</code> 是什么？ 4.<code>Object.__proto__</code> 是什么？ 5.<code>Object.prototype__proto__</code> 是什么？</p><p>答案： 第一题： 因为 <code>person1.__proto__ === person1 的构造函数.prototype</code> 因为 <code>person1的构造函数 === Person</code> 所以 <code>person1.__proto__ === Person.prototype</code></p><p>第二题： 因为 <code>Person.__proto__ === Person的构造函数.prototype</code> 因为 <code>Person的构造函数 === Function</code> 所以 <code>Person.__proto__ === Function.prototype</code></p><p>第三题： <code>Person.prototype</code> 是一个普通对象，我们无需关注它有哪些属性，只要记住它是一个普通对象。 因为一个 <code>普通对象的构造函数 === Object</code> 所以 <code>Person.prototype.__proto__ === Object.prototype</code></p><p>第四题，参照第二题，因为 <code>Person</code> 和 <code>Object</code> 一样都是构造函数</p><p>第五题： <code>Object.prototype</code> 对象也有 <code>proto</code> 属性，但它比较特殊，为 <code>null</code>。因为 <code>null</code> 处于原型链的顶端，这个只能记住。 <code>Object.prototype.__proto__ === null</code></p><h3 id="七-函数对象-（复习一下前面的知识点）"><a href="#七-函数对象-（复习一下前面的知识点）" class="headerlink" title="七. 函数对象 （复习一下前面的知识点）"></a>七. 函数对象 （复习一下前面的知识点）</h3><p><strong>所有函数对象的 <code>proto</code> 都指向 <code>Function.prototype</code>，它是一个空函数（<code>Empty function</code>）</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.constructor == <span class="built_in">Function</span>; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>.constructor == <span class="built_in">Function</span>; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">String</span>.constructor == <span class="built_in">Function</span>; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span></span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.constructor == <span class="built_in">Function</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.constructor == <span class="built_in">Function</span>; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.constructor == <span class="built_in">Function</span>; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RegExp</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">RegExp</span>.constructor == <span class="built_in">Function</span>; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Error</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Error</span>.constructor == <span class="built_in">Function</span>; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>.__proto__ === <span class="built_in">Function</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Date</span>.constructor == <span class="built_in">Function</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><code>JavaScript</code> 中有内置(<code>build-in</code>)构造器/对象共计 12 个（<code>ES5</code> 中新加了 <code>JSON</code>），这里列举了可访问的 8 个构造器。剩下如 <code>Global</code> <code>不能直接访问，Arguments</code> 仅在函数调用时由 <code>JS</code> 引擎创建，<code>Math</code>，<code>JSON</code> 是以对象形式存在的，无需 <code>new</code>。它们的<code>__proto__</code>是 <code>Object.prototype</code>。如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Math</span>.construrctor == <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.construrctor == <span class="built_in">Object</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>上面说的<strong>函数对象</strong>当然包括自定义的。如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> Perosn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(Person.__proto__ === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Man.__proto__ === <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>这说明什么呢？</p><p><strong>所有的构造器都来自于 <code>Function.prototype</code>，甚至包括根构造器 <code>Object</code> 及 <code>Function</code> 自身。所有构造器都继承了 <code>Function.prototype</code> 的属性及方法。如 <code>length、call、apply、bind</code></strong></p><p>（你应该明白第一句话，第二句话我们下一节继续说，先挖个坑：）） <code>Function.prototype</code>也是唯一一个 <code>typeof XXX.prototype</code> 为 <code>function</code> 的 <code>prototype</code>。其它的构造器的 <code>prototype</code> 都是一个对象（原因第三节里已经解释过了）。如下（又复习了一遍）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Number</span>.prototype); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Boolean</span>.prototype); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">String</span>.prototype); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Array</span>.prototype); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">RegExp</span>.prototype); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Error</span>.prototype); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Date</span>.prototype); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype); <span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>噢，上面还提到它是一个空的函数，<code>console.log(Function.prototype)</code> 下看看（留意，下一节会再说一下这个）</p><p>知道了所有构造器（含内置及自定义）的<code>__proto__</code>都是<code>Function.prototype</code>，那<code>Function.prototype</code>的<code>__proto__</code>是谁呢？ 相信都听说过 <code>JavaScript</code> 中函数也是一等公民，那从哪能体现呢？如下 <code>console.log(Function.prototype.__proto__ === Object.prototype) // true</code> 这说明所有的构造器也都是一个普通 JS 对象，可以给构造器添加/删除属性等。同时它也继承了 <code>Object.prototype</code> 上的所有方法：<code>toString、valueOf、hasOwnProperty</code> 等。（你也应该明白第一句话，第二句话我们下一节继续说，不用挖坑了，还是刚才那个坑；））</p><p>最后 <code>Object.prototype</code> 的 <code>__proto__</code> 是谁？ <code>Object.prototype.__proto__ === null // true</code> 已经到顶了，为 <code>null</code>。(读到现在，再回过头看第五章，能明白吗？)</p><h3 id="八-Prototype"><a href="#八-Prototype" class="headerlink" title="八. Prototype"></a>八. Prototype</h3><blockquote><p>在 ECMAScript 核心所定义的全部属性中，最耐人寻味的就要数 <code>prototype</code> 属性了。对于 ECMAScript 中的引用类型而言，prototype 是保存着它们所有实例方法的真正所在。换句话所说，诸如 toString()和 valuseOf() 等方法实际上都保存在 prototype 名下，只不过是通过各自对象的实例访问罢了。</p></blockquote><p>我们知道 JS 内置了一些方法供我们使用，比如： 对象可以用 <code>constructor/toString()/valueOf()</code> 等方法; 数组可以用 <code>map()/filter()/reducer()</code> 等方法； 数字可用用 <code>parseInt()/parseFloat()</code>等方法； Why ？？？</p><p><strong>当我们创建一个函数时：</strong> <code>var Person = new Object()</code> <code>Person</code> 是 <code>Object</code> 的实例，所以 <code>Person</code> 继承了 <code>Object</code> 的原型对象 <code>Object.prototype</code> 上所有的方法。</p><p><strong>Object 的每个实例都具有 Object.prototype 的属性和方法。</strong> 所以我可以用 <code>Person.constructor</code> 也可以用 <code>Person.hasOwnProperty</code>。</p><p><strong>当我们创建一个数组时：</strong></p><p><code>var num = new Array()</code> <code>num</code> 是 <code>Array</code> 的实例，所以 <code>num</code> <strong>继承</strong>了 <code>Array</code> 的原型对象 <code>Array.prototype</code> 上所有的方法。 <code>Array.prototype =&gt; []</code> 这尼玛怎么是一个空数组？？？</p><p>我们可以用一个 <code>ES5</code> 提供的新方法：<code>Object.getOwnPropertyNames</code> 获取所有（包括不可枚举的属性）的属性名不包括 <code>prototy</code> 中的属性，返回一个数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayAllKeys = <span class="built_in">Array</span>.prototype; <span class="comment">// [] 空数组</span></span><br><span class="line"><span class="comment">// 只得到 arrayAllKeys 这个对象里所有的属性名(不会去找 arrayAllKeys.prototype 中的属性)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(arrayAllKeys));</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">    [&quot;length&quot;, &quot;constructor&quot;, &quot;toString&quot;, &quot;toLocaleString&quot;, &quot;join&quot;, &quot;pop&quot;, &quot;push&quot;,</span></span><br><span class="line"><span class="comment">    &quot;concat&quot;, &quot;reverse&quot;, &quot;shift&quot;, &quot;unshift&quot;, &quot;slice&quot;, &quot;splice&quot;, &quot;sort&quot;, &quot;filter&quot;, &quot;forEach&quot;,</span></span><br><span class="line"><span class="comment">    &quot;some&quot;, &quot;every&quot;, &quot;map&quot;, &quot;indexOf&quot;, &quot;lastIndexOf&quot;, &quot;reduce&quot;, &quot;reduceRight&quot;,</span></span><br><span class="line"><span class="comment">    &quot;entries&quot;, &quot;keys&quot;, &quot;copyWithin&quot;, &quot;find&quot;, &quot;findIndex&quot;, &quot;fill&quot;]</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure><p>这样你就明白了随便声明一个数组，它为啥能用那么多方法了。</p><p>细心的你肯定发现了 <code>Object.getOwnPropertyNames(arrayAllKeys)</code> 输出的数组里并没有 <code>constructor/hasOwnPrototype</code> 等<strong>对象</strong>的方法（你肯定没发现）。 但是随便定义的数组也能用这些方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = [<span class="number">1</span>];</span><br><span class="line"><span class="built_in">console</span>.log(num.hasOwnPrototype()); <span class="comment">// false (输出布尔值而不是报错)</span></span><br></pre></td></tr></table></figure><p>Why ？？？</p><p>因为<code>Array.prototype</code>虽然没这些方法，但是它有原型对象（<code>__proto__</code>）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上面我们说了 Object.prototype 就是一个普通对象。</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.__proto__ == <span class="built_in">Object</span>.prototype;</span><br></pre></td></tr></table></figure><p>所以 <code>Array.prototype</code> 继承了对象的所有方法，当你用 <code>num.hasOwnPrototype()</code> 时，<code>JS</code> 会先查一下它的构造函数 （<code>Array</code>） 的原型对象 <code>Array.prototype</code> 有没有有 <code>hasOwnPrototype()</code> 方法，没查到的话继续查一下 <code>Array.prototype</code> 的原型对象 <code>Array.prototype.__proto__</code>有没有这个方法。</p><p><strong>当我们创建一个函数时：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;return x*x;&#x27;</span>);</span><br><span class="line"><span class="comment">//当然你也可以这么创建 f = function(x)&#123; return x*x &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(f.arguments); <span class="comment">// arguments 方法从哪里来的？</span></span><br><span class="line"><span class="built_in">console</span>.log(f.call(<span class="built_in">window</span>)); <span class="comment">// call 方法从哪里来的？</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype); <span class="comment">// function() &#123;&#125; （一个空的函数）</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(<span class="built_in">Function</span>.prototype));</span><br><span class="line"><span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">    [&quot;length&quot;, &quot;name&quot;, &quot;arguments&quot;, &quot;caller&quot;, &quot;constructor&quot;, &quot;bind&quot;, &quot;toString&quot;, &quot;call&quot;, &quot;apply&quot;]</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure><p>我们再复习第八小节这句话：</p><blockquote><p>所有<strong>函数对象 proto</strong>都指向 <code>Function.prototype</code>，它是一个空函数（<code>Empty function</code>）</p></blockquote><p>嗯，我们验证了它就是空函数。不过不要忽略前半句。我们枚举出了它的所有的方法，所以所有的<strong>函数对象</strong>都能用。</p><p>如果你还没搞懂啥是函数对象？</p><p>还有，我建议你可以再复习下为什么：</p><blockquote><p><code>Function.prototype</code> 是唯一一个 <code>typeof XXX.prototype</code> 为 <code>function</code> 的 <code>prototype</code></p></blockquote><h3 id="九-复习一下"><a href="#九-复习一下" class="headerlink" title="九. 复习一下"></a>九. 复习一下</h3><p>第八小节我们总结了：</p><p><strong>所有函数对象的 <code>__proto__</code> 都指向 <code>Function.prototype</code>，它是一个空函数（<code>Empty function</code>）</strong></p><p>但是你可别忘了在第三小节我们总结的：</p><p><strong>所有对象的 <code>__proto__</code> 都指向其构造器的 <code>prototype</code></strong></p><p>先看看 <code>JS</code> 内置构造器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;jack&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/hello/g</span>;</span><br><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">var</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;exception&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.__proto__ === <span class="built_in">Array</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.__proto__ === <span class="built_in">RegExp</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(date.__proto__ === <span class="built_in">Date</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(err.__proto__ === <span class="built_in">Error</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>再看看自定义的构造器，这里定义了一个 <code>Person</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>p</code> 是 <code>Person</code> 的实例对象，<code>p</code> 的内部原型总是指向其构造器 <code>Person</code> 的原型对象 <code>prototype</code>。</p><p>每个对象都有一个 <code>constructor</code> 属性，可以获取它的构造器，因此以下打印结果也是恒等的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === p.constructor.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面的 <code>Person</code> 没有给其原型添加属性或方法，这里给其原型添加一个 <code>getName</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改原型</span></span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === p.constructor.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>可以看到 <code>p.__proto__</code> 与 <code>Person.prototype</code>，<code>p.constructor.prototype</code> 都是恒等的，即都指向同一个对象。</p><p>如果换一种方式设置原型，结果就有些不同了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重写原型</span></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === Person.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(p.__proto__ === p.constructor.prototype); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>这里直接重写了 <code>Person.prototype</code>（注意：上一个示例是修改原型）。输出结果可以看出 <code>p.__proto__</code> 仍然指向的是 <code>Person.prototype</code>，而不是 <code>p.constructor.prototype</code>。</p><p>这也很好理解，给<code>Person.prototype</code>赋值的是一个对象直接量<code>&#123;getName: function()&#123;&#125;&#125;</code>，使用对象直接量方式定义的对象其构造器（<code>constructor</code>）指向的是根构造器 <code>Object</code>，<code>Object.prototype</code> 是一个空对象<code>&#123;&#125;</code>，<code>&#123;&#125;</code>自然与<code>&#123;getName: function()&#123;&#125;&#125;</code>不等。如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype); <span class="comment">// 为一个空的对象&#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.constructor === <span class="built_in">Object</span>); <span class="comment">// 对象直接量方式定义的对象其constructor为Object</span></span><br><span class="line"><span class="built_in">console</span>.log(p.constructor.prototype === <span class="built_in">Object</span>.prototype); <span class="comment">// 为true，不解释(๑ˇ3ˇ๑)</span></span><br></pre></td></tr></table></figure><h3 id="十-原型链（再复习一下：）"><a href="#十-原型链（再复习一下：）" class="headerlink" title="十. 原型链（再复习一下：）"></a>十. 原型链（再复习一下：）</h3><p>下面这个例子你应该能明白了！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__ === Person.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype.__proto__ === <span class="built_in">Object</span>.prototype); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__); <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">Person.__proto__ == <span class="built_in">Function</span>.prototype; <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Function</span>.prototype); <span class="comment">// function()&#123;&#125; (空函数)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="built_in">console</span>.log(num.__proto__ == <span class="built_in">Array</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype.__proto__ == <span class="built_in">Object</span>.prototype); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.prototype); <span class="comment">// [] (空数组)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.__proto__); <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.__proto__ == <span class="built_in">Function</span>.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>疑点解惑：</p><p>1.<code>Object.__proto__ === Function.prototype // true</code> <code>Object</code> 是函数对象，是通过<code>new Function()</code>创建的，所以<code>Object.__proto__</code>指向<code>Function.prototype</code>。（参照第八小节：「所有函数对象的<code>__proto__</code>都指向<code>Function.prototype</code>」）</p><p>2.<code>Function.__proto__ === Function.prototype // true</code> <code>Function</code> 也是对象函数，也是通过<code>new Function()</code>创建，所以<code>Function.__proto__</code>指向<code>Function.prototype</code>。</p><blockquote><p>自己是由自己创建的，好像不符合逻辑，但仔细想想，现实世界也有些类似，你是怎么来的，你妈生的，你妈怎么来的，你姥姥生的，……类人猿进化来的，那类人猿从哪来，一直追溯下去……，就是无，（NULL 生万物） 正如《道德经》里所说“无，名天地之始”。</p></blockquote><p>3.<code>Function.prototype.__proto__ === Object.prototype //true</code></p><blockquote><p>其实这一点我也有点困惑，不过也可以试着解释一下。 <code>Function.prototype</code>是个函数对象，理论上他的<code>__proto__</code>应该指向 <code>Function.prototype</code>，就是他自己，自己指向自己，没有意义。 JS 一直强调万物皆对象，函数对象也是对象，给他认个祖宗，指向<code>Object.prototype</code>。<code>Object.prototype.__proto__ === null</code>，保证原型链能够正常结束。</p></blockquote><h3 id="十一-总结"><a href="#十一-总结" class="headerlink" title="十一.总结"></a>十一.总结</h3><ul><li>原型和原型链是 JS 实现继承的一种模型。</li><li>原型链的形成是真正是靠<code>__proto__</code>而非<code>prototype</code></li></ul><p>要深入理解这句话，我们再举个例子，看看前面你真的理解了吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> dog = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">animal.price = <span class="number">2000</span>;</span><br><span class="line">dog.prototype = animal;</span><br><span class="line"><span class="keyword">var</span> tidy = <span class="keyword">new</span> dog();</span><br><span class="line"><span class="built_in">console</span>.log(dog.price); <span class="comment">//undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(tidy.price); <span class="comment">// 2000</span></span><br></pre></td></tr></table></figure><p>这里解释一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dog = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">dog.prototype.price = <span class="number">2000</span>;</span><br><span class="line"><span class="keyword">var</span> tidy = <span class="keyword">new</span> dog();</span><br><span class="line"><span class="built_in">console</span>.log(tidy.price); <span class="comment">// 2000</span></span><br><span class="line"><span class="built_in">console</span>.log(dog.price); <span class="comment">//undefined</span></span><br><span class="line"><span class="keyword">var</span> dog = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> tidy = <span class="keyword">new</span> dog();</span><br><span class="line">tidy.price = <span class="number">2000</span>;</span><br><span class="line"><span class="built_in">console</span>.log(dog.price); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>这个明白吧？想一想我们上面说过这句话：</p><blockquote><p>实例（<code>tidy</code>）和 原型对象（<code>dog.prototype</code>）存在一个连接。不过，要明确的真正重要的一点就是，这个连接存在于实例（<code>tidy</code>）与构造函数的原型对象（<code>dog.prototype</code>）之间，而不是存在于实例（<code>tidy</code>）与构造函数（<code>dog</code>）之间。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> FE Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>同一台电脑关于多个SSH KEY管理</title>
      <link href="273.html"/>
      <url>273.html</url>
      
        <content type="html"><![CDATA[<h2 id="比如有-aaa-bbb-ccc-三个帐号需要生成不同的-PUBLIC-KEY"><a href="#比如有-aaa-bbb-ccc-三个帐号需要生成不同的-PUBLIC-KEY" class="headerlink" title="比如有 aaa,bbb,ccc 三个帐号需要生成不同的 PUBLIC KEY"></a>比如有 aaa,bbb,ccc 三个帐号需要生成不同的 PUBLIC KEY</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/root/.ssh/id_rsa):/root/.ssh/id_rsa_aaa</span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):</span><br><span class="line">Enter same passphrase again:</span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /root/.ssh/id_rsa_aaa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /root/.ssh/id_rsa_aaa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">9b:92:f6:1f:d2:72:bd:72:19:45:42:5f:e4:65:33:64 root@AY140122145815620396Z</span><br><span class="line">The key<span class="string">&#x27;s randomart image is:</span></span><br><span class="line"><span class="string">+--[ RSA 2048]----+</span></span><br><span class="line"><span class="string">|           .. .E=|</span></span><br><span class="line"><span class="string">|            ..o++|</span></span><br><span class="line"><span class="string">|             o. .|</span></span><br><span class="line"><span class="string">|              .  |</span></span><br><span class="line"><span class="string">|        S    .   |</span></span><br><span class="line"><span class="string">|       . + ..    |</span></span><br><span class="line"><span class="string">|      + = + .o   |</span></span><br><span class="line"><span class="string">|     . o +..o.   |</span></span><br><span class="line"><span class="string">|        ...o.    |</span></span><br><span class="line"><span class="string">+-----------------+</span></span><br></pre></td></tr></table></figure><p>我们在 <code>/root/.ssh/</code> 目录下创建 <code>id_rsa_aaa</code> 私钥 和 <code>id_rsa_aaa.pub</code> 公钥.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/root/.ssh/id_rsa):/root/.ssh/id_rsa_aaa  <span class="comment">#设置路径,如果不设置默认生成 id_rsa  和  id_rsa.pub</span></span><br></pre></td></tr></table></figure><h2 id="按照上面的步骤逐个生成-bbb-和-ccc-对应的公钥和私钥"><a href="#按照上面的步骤逐个生成-bbb-和-ccc-对应的公钥和私钥" class="headerlink" title="按照上面的步骤逐个生成 bbb 和 ccc 对应的公钥和私钥"></a>按照上面的步骤逐个生成 bbb 和 ccc 对应的公钥和私钥</h2><h2 id="查看系统-ssh-key-代理-执行如下命令"><a href="#查看系统-ssh-key-代理-执行如下命令" class="headerlink" title="查看系统 ssh-key 代理,执行如下命令"></a>查看系统 ssh-key 代理,执行如下命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add -l</span><br><span class="line">Could not open a connection to your authentication agent.</span><br></pre></td></tr></table></figure><p>如果发现上面的提示,说明系统代理里没有任何 <code>key</code>,执行如下操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> ssh-agent bash</span><br></pre></td></tr></table></figure><p>如果系统已经有 <code>ssh-key</code> 代理 ,执行下面的命令可以删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add -D</span><br></pre></td></tr></table></figure><h2 id="把-ssh-目录下的-3-个私钥添加的-ssh-agent"><a href="#把-ssh-目录下的-3-个私钥添加的-ssh-agent" class="headerlink" title="把 .ssh 目录下的 3 个私钥添加的 ssh-agent"></a>把 .ssh 目录下的 3 个私钥添加的 ssh-agent</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa_aaa</span><br><span class="line">ssh-add ~/.ssh/id_rsa_bbb</span><br><span class="line">ssh-add ~/.ssh/id_rsa_ccc</span><br></pre></td></tr></table></figure><p>依次执行上面三条 <code>shell</code> 把三个私钥添加到 <code>ssh-key</code> 代理里面。</p><h2 id="打开-github-或者-开源中国-ssh-管理页面把-对应的公钥提交保存到代码管理服务器-pub-结尾"><a href="#打开-github-或者-开源中国-ssh-管理页面把-对应的公钥提交保存到代码管理服务器-pub-结尾" class="headerlink" title="打开 github 或者 开源中国 ssh 管理页面把 对应的公钥提交保存到代码管理服务器 (.pub 结尾)"></a>打开 github 或者 开源中国 ssh 管理页面把 对应的公钥提交保存到代码管理服务器 (.pub 结尾)</h2><h2 id="在-ssh-目录创建-config-配置文件"><a href="#在-ssh-目录创建-config-配置文件" class="headerlink" title="在 .ssh 目录创建 config 配置文件"></a>在 .ssh 目录创建 config 配置文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nano ~/.ssh/config</span><br></pre></td></tr></table></figure><p>输入如下配置信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#aaa  (github 配置)</span></span><br><span class="line">Host aaa</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_aaa</span><br><span class="line"></span><br><span class="line"><span class="comment">#bbb  (开源中国 配置)</span></span><br><span class="line">Host bbb</span><br><span class="line">    HostName git.oschina.net</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/id_rsa_bbb</span><br><span class="line"></span><br><span class="line"><span class="comment">#ccc</span></span><br><span class="line">........</span><br></pre></td></tr></table></figure><h2 id="记住上面一步-Host-里设置的别名-开始克隆项目-以开源中国为例"><a href="#记住上面一步-Host-里设置的别名-开始克隆项目-以开源中国为例" class="headerlink" title="记住上面一步 Host 里设置的别名,开始克隆项目,以开源中国为例"></a>记住上面一步 Host 里设置的别名,开始克隆项目,以开源中国为例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@git.oschina.net:userName/projectName.git</span><br></pre></td></tr></table></figure><p>到此为止多个 <code>ssh-key</code> 已经可以同时使用.</p>]]></content>
      
      
      <categories>
          
          <category> FE Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）V8引擎的垃圾内存回收机制</title>
      <link href="259.html"/>
      <url>259.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接 <code>https://juejin.cn/post/6875714523332870157#heading-9</code></p></blockquote><h2 id="垃圾回收的起因"><a href="#垃圾回收的起因" class="headerlink" title="垃圾回收的起因"></a>垃圾回收的起因</h2><p>在其他的后端语言中，如 Java/Go, 对于内存的使用没有什么限制，但是 JS 不一样，V8 只能使用系统的一部分内存。</p><p>我们都知道，所有的对象类型的数据再 JS 中都是通过堆进行空间分配的，当我们构造一个对象进项赋值操作的时候，其实相应的内存已经分配到了堆上，我们可以不断地这样创建对象，让 V8 为它分配空间，直到堆的大小达到上限。</p><h3 id="v8-内存限制"><a href="#v8-内存限制" class="headerlink" title="v8 内存限制"></a>v8 内存限制</h3><p>那么问题来了，V8 为什么要给它设置内存上限？明明服务器的机器有几十 G 的内存，只能让我用这么一点？</p><p>究其根本，是由两个因素共同决定的：</p><ul><li>一个是 JS 单线程的执行机制</li><li>另一个是 JS 垃圾回收机制的限制</li></ul><p>首先 JS 是单线程运行的，这意味着一旦进入到垃圾回收，那么其它的各种运行逻辑都要暂停; 另一方面垃圾回收其实是非常耗时间的操作，V8 官方是这样形容的：</p><blockquote><p>以 1.5GB 的垃圾回收堆内存为例，V8 做一次小的垃圾回收需要 50ms 以上，做一次非增量式(ps:后面会解释)的垃圾回收甚至要 1s 以上。</p></blockquote><p>可见其耗时之久，而且在这么长的时间内，我们的 JS 代码执行会一直没有响应，造成应用卡顿，导致应用性能和响应能力直线下降。因此，V8 做了一个简单粗暴的 选择，那就是限制堆内存。</p><p>那么 V8 是如何进行内存的垃圾回收呢，防止有用的 JS 代码执行会一直没有响应，造成使用的应用卡顿。</p><h2 id="V8-是如何进行垃圾回收的？"><a href="#V8-是如何进行垃圾回收的？" class="headerlink" title="V8 是如何进行垃圾回收的？"></a>V8 是如何进行垃圾回收的？</h2><p>JS 引擎中对变量的存储主要有两种位置，栈内存和堆内存。</p><h3 id="栈内存的回收"><a href="#栈内存的回收" class="headerlink" title="栈内存的回收"></a>栈内存的回收</h3><p>栈内存调用栈上下文切换后，栈顶的空间就会自动被回收。</p><h3 id="堆内存的回收"><a href="#堆内存的回收" class="headerlink" title="堆内存的回收"></a>堆内存的回收</h3><p>v8 把堆内存划分为两部分进行处理————<strong>新生代内存</strong>和<strong>老生代内存</strong>两个区域。</p><p>顾名思义，<strong>新生代</strong>就是临时分配的内存，存活时间短；<strong>老生代</strong>是常驻内存，存活的时间长。</p><h4 id="新生代内存的回收"><a href="#新生代内存的回收" class="headerlink" title="新生代内存的回收"></a>新生代内存的回收</h4><p>v8 的堆内存，也就是两个内存之和，由<strong>新生代</strong>和<strong>老生代</strong>共同组成。</p><p><img data-src="https://cdn.flqin.com/p259-1.image" alt="新生代&amp;老生代"></p><p>根据这两种不同种类的堆内存，v8 采用了不同的回收策略，来根据不同的场景做针对性的优化。</p><p><strong>新生代</strong>的垃圾回收是怎么做的呢？</p><p>首先将新生代内存空间一分为二，如图</p><p><img data-src="https://cdn.flqin.com/p259-2.image" alt="新生代内存"></p><p>其中的 From 部分表示正在使用的内存，To 是目前闲置的内存。</p><p>当进行垃圾回收时，v8 将 From 部分的对象检查一遍。</p><ul><li>如果是<strong>存活对象</strong>，那么直接复制到 To 内存中（<code>在 To 内存中按照顺序从头放置的</code>）</li><li>如果是<strong>非存活对象</strong>，直接回收即可</li></ul><p>当所有的 From 中的存活对象按照顺序进入到 To 内存之后，From 和 To 两者的角色<code>对调</code>，From 现在被闲置，To 为正在使用，如此循环。</p><p>那你很可能会问了，直接将非存活对象回收了不就万事大吉了嘛，为什么还要后面的一系列操作？</p><p>注意，我刚刚特别说明了，在 To 内存中按照顺序从头放置的，这是为了应对这样的场景:</p><p><img data-src="https://cdn.flqin.com/p259-3.image" alt="内存碎片"></p><p>深色的小方块代表存活对象，白色部分表示待分配的内存，由于堆内存是连续分配的，这样零零散散的空间可能会导致稍微大一点的对象没有办法进行空间分配， 这种零散的空间也叫做<strong>内存碎片</strong>。刚刚介绍的新生代垃圾回收算法也叫 <strong>Scavenge 算法</strong>。</p><p>Scavenge 算法主要就是解决<strong>内存碎片</strong>的问题，在进行一顿复制之后，To 空间变成了这个样子:</p><p><img data-src="https://cdn.flqin.com/p259-4.image" alt="整理内存碎片"></p><p>是不是整齐了许多？这样就大大方便了后续连续空间的分配。</p><p>不过 Scavenge 算法的<code>劣势</code>也非常明显，就是<strong>内存只能使用新生代内存的一半</strong>，但是它只存放生命周期短的对象，这种对象<strong>一般很少</strong>，因此<strong>时间性能</strong>非常优秀。</p><h4 id="老生代内存的回收"><a href="#老生代内存的回收" class="headerlink" title="老生代内存的回收"></a>老生代内存的回收</h4><p>刚刚介绍了新生代的回收方式，那么新生代中的变量<strong>如果经过多次回收后依然存在</strong>，那么就会被放入到<strong>老生代内存</strong>中，这种现象就叫<strong>晋升</strong>。</p><p>发生晋升其实不只是这一种原因，我们来梳理一下会有哪些情况触发晋升：</p><ul><li>已经经历过一次 Scavenge 回收。</li><li>To（闲置）空间的内存占用超过 25%。</li></ul><p>现在进入到<strong>老生代</strong>的垃圾回收机制当中，<strong>老生代</strong>中累计的变量空间一般都是很大的，当然不能用 <code>Scavenge</code> 算法啦，因为它不仅会<strong>浪费一半空间</strong>，还会对<strong>庞大的内存空间进行复制</strong>呢。</p><p>那么对于老生代而言，究竟是采取怎样的策略进行垃圾回收的呢？</p><p>「第一步」，进行<code>标记-清除</code>。主要分为两个阶段，即<code>标记阶段</code>和<code>清除阶段</code>。首先会遍历堆中的所有对象，对它们作上标记，然后对代码环境中<code>使用的变量</code>以及被<code>强引用</code>的变量取消标记（因为它们属于被引用对象），剩下的就是要删除的变量了，在随后的<code>清除阶段</code>对其进行空间的回收。</p><p>当然这又会引发内存碎片的问题，存活对象的空间不连续对后续的空间分配造成障碍。老生代又是如何处理这个问题的呢？</p><p>「第二步」，整理<code>内存碎片</code>。v8 的解决方式非常简单粗暴，在<code>清除阶段</code>结束后，把存活的对象全部往一端靠拢。</p><p><img data-src="https://cdn.flqin.com/p259-5.image" alt="整理内存碎片"></p><p>由于是移动对象，它的执行速度不可能很快，事实上也是整个过程中最耗时间的部分。</p><h4 id="增量标记"><a href="#增量标记" class="headerlink" title="增量标记"></a>增量标记</h4><p>由于 <strong>JS 的单线程机制</strong>，V8 在进行垃圾回收的时候，不可避免地会<strong>阻塞</strong>业务逻辑的执行，倘若老生代的垃圾回收任务很重，那么耗时会非常可怕，严重影响应用的性能。 那这个时候为了避免这样问题，V8 采取了<strong>增量标记</strong>的方案，即<strong>将一口气完成的标记任务分为很多小的部分完成，每做完一个小的部分就”歇”一下，就 js 应用逻辑执行一会儿， 然后再执行下面的部分</strong>。如果循环，直到标记阶段完成才进入内存碎片的整理上面来。其实这个过程跟 React Fiber 的思路有点像，这里就不展开了。</p><p>经过<strong>增量标记</strong>之后，垃圾回收过程对 JS 应用的阻塞时间减少到原来了 1 / 6, 可以看到，这是一个非常成功的改进。</p><h3 id="介绍一下引用计数和标记清除"><a href="#介绍一下引用计数和标记清除" class="headerlink" title="介绍一下引用计数和标记清除"></a>介绍一下引用计数和标记清除</h3><ul><li><p><code>「引用计数」</code>：给一个变量赋值引用类型，则该对象的引用次数+1，如果这个变量变成了其他值，那么该对象的引用次数-1，垃圾回收器会回收引用次数为 0 的对象。但是当对象<code>循环引用</code>时，会导致引用次数永远无法归零，造成内存无法释放。</p></li><li><p><code>「标记清除」</code>：垃圾收集器先给 内存中所有对象加上标记，然后从根节点开始遍历，去掉被引用的对象和运行环境中对象的标记，剩下的被标记的对象就是无法访问的，等待垃圾回收的对象。</p></li></ul><h3 id="V8-的垃圾回收是发生在什么时候？"><a href="#V8-的垃圾回收是发生在什么时候？" class="headerlink" title="V8 的垃圾回收是发生在什么时候？"></a>V8 的垃圾回收是发生在什么时候？</h3><p>浏览器渲染页面的空闲时间进行垃圾回收。</p>]]></content>
      
      
      <categories>
          
          <category> FE Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）js数组去重</title>
      <link href="257.html"/>
      <url>257.html</url>
      
        <content type="html"><![CDATA[<h2 id="嵌套循环比较"><a href="#嵌套循环比较" class="headerlink" title="嵌套循环比较"></a>嵌套循环比较</h2><p>两层 <code>for</code> 循环，<code>for</code> 循环中每次从原数组中取出一个元素，用这个元素循环与结果数组对比。若结果数组中没有该元素，则存到结果数组中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique_towFor =</span><br><span class="line">  <span class="built_in">Array</span>.prototype.unique_towFor ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.length &lt;= <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">    result.push(<span class="built_in">this</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> notIn = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; result.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>[i] == result[j]) &#123;</span><br><span class="line">          notIn = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (notIn) &#123;</span><br><span class="line">        result.push(<span class="built_in">this</span>[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h2 id="临时数组保存"><a href="#临时数组保存" class="headerlink" title="临时数组保存"></a>临时数组保存</h2><p>算法的基本思想就是把去重后的结果放在一个临时数组中。对原来数组的元素与临时数组元素比较，临时数组中不存在这个元素的，放入临时数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique_tempArray =</span><br><span class="line">  <span class="built_in">Array</span>.prototype.unique_tempArray ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = []; <span class="comment">//临时数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (result.indexOf(<span class="built_in">this</span>[i]) == -<span class="number">1</span>) &#123;</span><br><span class="line">        result.push(<span class="built_in">this</span>[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h2 id="利用对象去重-基础常用"><a href="#利用对象去重-基础常用" class="headerlink" title="利用对象去重(基础常用)"></a>利用对象去重(基础常用)</h2><p>创建一个新的数组存放结果，和一个空对象。<code>for</code> 循环时，每次取出一个元素与对象进行对比，如果这个元素不重复，则把它存放到结果数组中，同时把这个元素的内容作为对象的一个属性，并赋值，存入到对象中。这个方法用作统计也很方便。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique_objectArray =</span><br><span class="line">  <span class="built_in">Array</span>.prototype.unique_objectArray ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!obj[<span class="built_in">this</span>[i]]) &#123;</span><br><span class="line">        obj[<span class="built_in">this</span>[i]] = <span class="number">1</span>;</span><br><span class="line">        result.push(<span class="built_in">this</span>[i]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj[<span class="built_in">this</span>[i]]++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h2 id="先排序，后去重"><a href="#先排序，后去重" class="headerlink" title="先排序，后去重"></a>先排序，后去重</h2><p>先把数组排序，然后比较相邻的两个值。 排序的时候用的 <code>JS</code> 原生的 <code>sort</code> 方法，<code>JS</code> 引擎内部用的是快速排序，此方法速度比较快！无语中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique_sortArray =</span><br><span class="line">  <span class="built_in">Array</span>.prototype.unique_sortArray ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.sort();</span><br><span class="line">    <span class="keyword">var</span> result = [<span class="built_in">this</span>[<span class="number">0</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>[i] !== result[result.length - <span class="number">1</span>]) &#123;</span><br><span class="line">        result.push(<span class="built_in">this</span>[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h2 id="利用-ES6-的-Set-对象和-Array-from-方法"><a href="#利用-ES6-的-Set-对象和-Array-from-方法" class="headerlink" title="利用 ES6 的 Set 对象和 Array.from 方法"></a>利用 ES6 的 Set 对象和 Array.from 方法</h2><ul><li><code>Set</code> 对象可以是任何类型的单个值的集合。它是 <code>ES6</code> 新增的有序列表集合，它不会包含重复项。之前我们通常用对象(<code>Object</code>)或者数组(<code>Array</code>)来实现没有重复项的集合。</li><li><code>Array.from()</code>方法可以将一个类数组对象或可遍历对象转换成真正的数组。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique_es6SetArray =</span><br><span class="line">  <span class="built_in">Array</span>.prototype.unique_esSetArray ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(<span class="built_in">this</span>));</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h2 id="利用-filter-和-Map-对象"><a href="#利用-filter-和-Map-对象" class="headerlink" title="利用 filter 和 Map 对象"></a>利用 filter 和 Map 对象</h2><p><code>filter()</code> 方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique_filterArray =</span><br><span class="line">  <span class="built_in">Array</span>.prototype.unique_filterArray ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> arr.indexOf(item) === index;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>既然可以使用 <code>filter</code> 的方法，那么也可以使用 <code>filter</code> 加 <code>object</code> 的方法，这里使用 <code>Map</code> 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique_es6MapArray =</span><br><span class="line">  <span class="built_in">Array</span>.prototype.unique_es6MapArray ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index, arr</span>) </span>&#123;</span><br><span class="line">      !seen.has(item) &amp;&amp; seen.set(item, <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>这里的 <code>filter</code> 函数可以简化，当然也有人这样写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique_es6MapArray =</span><br><span class="line">  <span class="built_in">Array</span>.prototype.unique_es6MapArray ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> seen = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.filter(<span class="function">(<span class="params">a</span>) =&gt;</span> !seen.has(a) &amp;&amp; seen.set(a, <span class="number">1</span>));</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h2 id="使用第三方"><a href="#使用第三方" class="headerlink" title="使用第三方"></a>使用第三方</h2><p>最后，可以使用第三方库函数 <code>jquery</code> 和 <code>underscore</code> 或者 <code>lodash</code>。 下面以 <code>lodash</code> 和 <code>underscore</code> 为例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique_3partyArray =</span><br><span class="line">  <span class="built_in">Array</span>.prototype.unique_3partyArray ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _.uniq(arr); <span class="comment">//要先引入lodash.js或者underscore.js</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FE Code </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js判断变量是否是dom对象</title>
      <link href="254.html"/>
      <url>254.html</url>
      
        <content type="html"><![CDATA[<p>我们在写 <code>js</code> 代码时有时需要判断某个对象是不是 <code>DOM</code> 对象，然后再进行后续的操作，这里我给出一种兼容各大浏览器，同时又算是比较稳妥的一种方法。</p><p>要判断一个对象是否 <code>DOM</code> 对象，首先想到的无非就是它是否具有 <code>DOM</code> 对象的各种属性或特征，比如是否有 <code>nodeType</code> 属性，有 <code>tagName</code> 属性，等等。判断的特征越多，也就越可靠，因为毕竟我们自定义的 <code>js</code> 对象也可以有那些属性。还有其他方法吗?</p><p>在 <code>DOM Level2</code> 标准中定义了一个 <code>HTMLElement</code> 对象，它规定所有的 <code>DOM</code> 对象都是 <code>HTMLElement</code> 的实例，所以我们可以利用这点来判断一个对象是不是 <code>DOM</code> 对象: 如果该对象是 <code>HTMLElement</code> 的实例，则它肯定是一个 <code>DOM</code> 对象。在不支持 <code>HTMLElement</code> 的浏览器中我们则还是使用特征检测法。</p><p>首先要对 <code>HTMLElement</code> 进行类型检查，因为即使在支持 <code>HTMLElement</code> 的浏览器中，类型却是有差别的，在<code>Chrome,Opera</code> 中 <code>HTMLElement</code> 的类型为 <code>function</code>，此时就不能用它来判断了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isDOM =</span><br><span class="line">  <span class="keyword">typeof</span> HTMLElement === <span class="string">&#x27;object&#x27;</span></span><br><span class="line">    ? <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj <span class="keyword">instanceof</span> HTMLElement;</span><br><span class="line">      &#125;</span><br><span class="line">    : <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">&#x27;object&#x27;</span> &amp;&amp; obj.nodeType === <span class="number">1</span> &amp;&amp; <span class="keyword">typeof</span> obj.nodeName === <span class="string">&#x27;string&#x27;</span>;</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FE Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Javascript 中神奇的 this</title>
      <link href="240.html"/>
      <url>240.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="误以为-this-指向函数自身"><a href="#误以为-this-指向函数自身" class="headerlink" title="误以为 this 指向函数自身"></a>误以为 this 指向函数自身</h3><p>根据 <code>this</code> 的英语语法，很容易将函数中出现的 <strong>this</strong> 理解为函数自身。在 <code>javascript</code> 当中函数作为一等公民，确实可以在调用的时候将属性值存储起来。但是如果使用方法不对，就会发生与实际预期不一致的情况。具体情况，请看下面代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  fn(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn.count); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>如果 <code>fn</code> 函数里面的 <code>this</code> 指向自身函数，那么 <code>count</code> 属性的属性值就应该产生变化，但实际上却是纹丝不动。对于这个问题，有些人会利用作用域来解决，比如这么写:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">  count: <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  data.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  fn(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data.count); <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>又或者更直接的这么写:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  fn.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn.count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  fn(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fn.count); <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>虽然这两种方式都输出了正确的结果，但是却避开了 <code>this</code> 到底绑定在哪里的问题。如果对一个事物的工作原理不清晰，就往往会产生头痛治头，脚痛治脚的问题，从而导致代码变得的丑陋，而且维护性也会变得很差。</p><p><strong>实际上，this 提供了一种更优雅的方法来隐式’传递’一个对象的引用，因此可以将 API 设计得更加简洁并且易于复用。</strong></p><h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><h3 id="默认绑定规则"><a href="#默认绑定规则" class="headerlink" title="默认绑定规则"></a>默认绑定规则</h3><p>无论是 <code>全局环境</code> 还是 <code>函数独立调用（包括嵌套函数，IIFE，闭包等）</code>，<code>this</code> 默认绑定到 <code>window</code>。在严格模式下，会将函数体里的 <code>this</code> 默认绑定为 <code>undefined</code>。以避免全局变量的污染。</p><h4 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span> === <span class="built_in">window</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="函数独立调用"><a href="#函数独立调用" class="headerlink" title="函数独立调用"></a>函数独立调用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">window</span> === <span class="built_in">this</span>); <span class="comment">//浏览器环境</span></span><br><span class="line">&#125;</span><br><span class="line">fn(); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>函数 <code>fn</code> 是直接在全局作用域下调用的，没有带其他任何修饰，这种情况下，函数调用的时候使用了 <code>this</code> 的默认绑定，指向了全局对象。</p><p><code>fn</code> 函数中的 <code>this</code> 指向了全局变量，所以 <code>this.count++</code> 相当于 <code>window.count++</code>(浏览器环境下)，当然不会对 <code>fn</code> 函数的 <code>count</code> 属性产生影响。</p><h5 id="嵌套函数"><a href="#嵌套函数" class="headerlink" title="嵌套函数"></a>嵌套函数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//虽然test()函数被嵌套在obj.foo()函数中，但test()函数是独立调用，而不是方法调用。所以this默认绑定到window</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">    test();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); <span class="comment">//0</span></span><br></pre></td></tr></table></figure><h5 id="IIFE（立即执行函数）"><a href="#IIFE（立即执行函数）" class="headerlink" title="IIFE（立即执行函数）"></a>IIFE（立即执行函数）</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); <span class="comment">//0</span></span><br><span class="line"><span class="comment">//等价于上例</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">    test();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); <span class="comment">//0</span></span><br></pre></td></tr></table></figure><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo()(); <span class="comment">//0</span></span><br></pre></td></tr></table></figure><h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">1</span>; <span class="comment">// 这种指向全局的 this 不对</span></span><br><span class="line">&#125;</span><br><span class="line">F();</span><br><span class="line"><span class="comment">//Uncaught TypeError: Cannot set property &#x27;a&#x27; of undefined</span></span><br></pre></td></tr></table></figure><p>严格模式下在 <code>函数体</code>里的 <code>this</code> 不允许指向全局对象。</p><h3 id="隐式绑定规则"><a href="#隐式绑定规则" class="headerlink" title="隐式绑定规则"></a>隐式绑定规则</h3><p>如果函数在以对象为上下文进行调用，那么 <code>this</code> 会绑定到调用这个函数的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.fn(); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>即使函数声明不在对象当中，<code>this</code> 指向仍会产生变化:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  fn: fn,</span><br><span class="line">&#125;;</span><br><span class="line">obj.fn(); <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>由此可见，<code>this</code> 的绑定，不与函数定义的位置有关，而是与调用者和调用方式有关。</p><p>在隐式的绑定规则下，有一些特殊的地方，需要注意：</p><h4 id="多层对象调用"><a href="#多层对象调用" class="headerlink" title="多层对象调用"></a>多层对象调用</h4><p>在多层对象引用下，<code>this</code> 指向的是调用的函数的那个对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;</span><br><span class="line">  a: <span class="number">3</span>,</span><br><span class="line">  fn: fn,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  obj3: obj3,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  obj2: obj2,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.obj2.obj3.fn(); <span class="comment">//3</span></span><br></pre></td></tr></table></figure><h4 id="隐式丢失"><a href="#隐式丢失" class="headerlink" title="隐式丢失"></a>隐式丢失</h4><h5 id="函数别名"><a href="#函数别名" class="headerlink" title="[函数别名]"></a>[函数别名]</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//把obj.foo赋予别名bar，造成了隐式丢失，因为只是把foo()函数赋给了bar，而bar与obj对象则毫无关系</span></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo;</span><br><span class="line">bar(); <span class="comment">//0</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;;</span><br><span class="line">bar(); <span class="comment">//0</span></span><br></pre></td></tr></table></figure><p>虽然 <code>bar</code> 引用了 <code>obj.foo</code>，但是函数的调用方式，仍是不带任何修饰的，所以 <code>this</code> 还是绑定在了 <code>window</code> 上。</p><h5 id="参数传递"><a href="#参数传递" class="headerlink" title="[参数传递]"></a>[参数传递]</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//把obj.foo当作参数传递给bar函数时，有隐式的函数赋值fn=obj.foo。与上例类似，只是把foo函数赋给了fn，而fn与obj对象则毫无关系</span></span><br><span class="line">bar(obj.foo); <span class="comment">//0</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line">bar(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="内置函数"><a href="#内置函数" class="headerlink" title="[内置函数]"></a>[内置函数]</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">setTimeout</span>(obj.foo, <span class="number">100</span>); <span class="comment">//0</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;, <span class="number">100</span>); <span class="comment">//0</span></span><br></pre></td></tr></table></figure><p><code>setTimeout</code> 是 <code>window</code> 的方法，<code>setTimeout</code> 在调用传入函数的时候，如果这个函数没有指定了的 <code>this</code>，那么它会做一个隐式的操作 —- <code>自动地注入全局上下文 window</code>。</p><p>隐式绑定 <code>this</code> 不是一种很推荐的方式，因为很有可能就发生丢失的情况，如果业务当中对 <code>this</code> 的绑定有要求，建议还是使用显示绑定的方式。</p><h3 id="显式绑定规则"><a href="#显式绑定规则" class="headerlink" title="显式绑定规则"></a>显式绑定规则</h3><p>显示绑定就是利用函数原型上的 <code>apply</code> 与 <code>call</code> 方法来对 <code>this</code> 进行绑定。用法就是把想要绑定的对象作为第一个参数传进去。如果传入了一个原始值(字符串,布尔类型，数字类型)，来当做 <code>this</code> 的绑定对象，这个原始值转换成它的对象形式。</p><p>如果你把 <code>null</code> 或者 <code>undefined</code> 作为 <code>this</code> 的绑定对象传入 <code>call/apply/bind</code>，这些值会在调用时被忽略，实际应用的是默认绑定规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">fn.call(obj); <span class="comment">//&#123;&#125;</span></span><br></pre></td></tr></table></figure><p>有些时候会想将函数的 <code>this</code> 绑定在某个对象上，但是不需要立即调用，这样的话，直接利用 <code>call</code> 或者 <code>apply</code> 是无法做的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  fn: fn,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bind.call(obj, fn); <span class="comment">//window</span></span><br></pre></td></tr></table></figure><p>上面这个例子，看似好像可以，但实际上是 <code>bind</code> 函数的 <code>this</code> 绑定到了 <code>obj</code> 这个对象，但是 <code>fn</code> 仍然是没有任何修饰的调用，所以 <code>fn</code> 仍然是默认的绑定方式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params">fn, obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    fn.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  fn: fn,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fun = bind(fn, obj);</span><br><span class="line">fun(); <span class="comment">//obj</span></span><br></pre></td></tr></table></figure><p>这样调用，就可以将灵活多变的 <code>this</code>，牢牢的控制住了，因为 <code>fn</code> 的调用方式为 <code>apply</code> 调用。所以，<code>this</code> 就被绑定在传入的 <code>obj</code> 对象上，在 <code>ES5</code> 当中，函数的原型方法上多了一个 <code>bind</code>，效果与上面的函数基本一致。</p><h4 id="apply-call-bind-实现"><a href="#apply-call-bind-实现" class="headerlink" title="apply/call/bind 实现"></a>apply/call/bind 实现</h4><p>注： call 性能比 apply 好。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply2 = <span class="function"><span class="keyword">function</span> (<span class="params">context = <span class="built_in">window</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// 用于防止 Function.prototype.apply2() 直接调用</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">Symbol</span>();</span><br><span class="line">  context[fn] = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line">  <span class="comment">//let args = [...arguments].slice(1);   // call 则仅仅是参数不同</span></span><br><span class="line">  <span class="keyword">let</span> args = <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">  <span class="comment">// 判断是否有第二个参数</span></span><br><span class="line">  <span class="keyword">if</span> (args) &#123;</span><br><span class="line">    result = context[fn](...args);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context[fn]();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context[fn];</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind2 = <span class="function"><span class="keyword">function</span> (<span class="params">content</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span> === <span class="built_in">Function</span>.prototype) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Error&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> resFn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> resFn ? <span class="built_in">this</span> : content, args.concat(...arguments));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">tmp</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  tmp.prototype = <span class="built_in">this</span>.prototype;</span><br><span class="line">  resFn.prototype = <span class="keyword">new</span> tmp();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> resFn;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="new"><a href="#new" class="headerlink" title="new"></a>new</h4><p><code>new</code> 是一个被很多人误解的一个关键字，但实际上 <code>javascript</code> 的 <code>new</code> 与传统面向对象的语言完全不同。 个人把 <code>new</code> 理解为一种特殊的函数调用，当使用 <code>new</code> 关键字来调用函数的时候，会执行下面操作:</p><ol><li>创建一个全新的对象；</li><li>将构造函数的作用域赋给新对象(<code>this</code> 就指向了这个新对象)，将新对象的 <code>__proto__</code> 指向构造函数的 <code>prototype</code>，设置新对象的内部属性，可访问性等；</li><li>执行构造函数中的代码（为这个新对象添加属性）；</li><li>如果构造函数返回值为基本类型或者为 <code>this</code> 又或者不返回任何值，那么将会返回这个创建的新对象；如果返回了一个对象，那么则会返回这个对象。</li></ol><h5 id="new-实现"><a href="#new-实现" class="headerlink" title="new 实现"></a>new 实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (func.prototype !== <span class="literal">null</span>) &#123;</span><br><span class="line">    res.__proto__ = func.prototype;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> ret = func.apply(res, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> ret === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> ret === <span class="string">&#x27;function&#x27;</span>) &amp;&amp; ret !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = New(A, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// equals to</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> A(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>故构造函数中的 <code>this</code> 指向构造函数创建的对象实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line">fn.prototype.hi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> fn(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><p>类和模块的内部，默认就是 <code>严格模式</code>。上文说到在严格模式下，会将 <code>this</code> 默认绑定为 <code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">printName</span>(<span class="params">name = <span class="string">&#x27;there&#x27;</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">print</span>(<span class="params">text</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Logger();</span><br><span class="line"><span class="keyword">const</span> &#123; printName &#125; = logger;</span><br><span class="line">printName(); <span class="comment">// TypeError: Cannot read property &#x27;print&#x27; of undefined</span></span><br></pre></td></tr></table></figure><p>可以将 <code>this</code> 绑定到实例上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.printName = <span class="built_in">this</span>.printName.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="class-实现"><a href="#class-实现" class="headerlink" title="class 实现"></a>class 实现</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  subType.prototype = <span class="built_in">Object</span>.create(superType.prototype, &#123;</span><br><span class="line">    <span class="title">constructor</span>: &#123;</span><br><span class="line">      enumerable: <span class="literal">false</span>,</span><br><span class="line">      configurable: <span class="literal">true</span>,</span><br><span class="line">      writable: <span class="literal">true</span>,</span><br><span class="line">      value: subType,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">Object</span>.setPrototypeOf(subType, superType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6 的 class 内部是基于寄生组合式继承，它是目前最理想的继承方式，通过 Object.create 方法创造一个空对象，并将这个空对象继承 Object.create 方法的参数，再让子类（subType）的原型对象等于这个空对象，就可以实现子类实例的原型等于这个空对象，而这个空对象的原型又等于父类原型对象（superType.prototype）的继承关系</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//而 Object.create 支持第二个参数，即给生成的空对象定义属性和属性描述符/访问器描述符，我们可以给这个空对象定义一个 constructor 属性更加符合默认的继承行为，同时它是不可枚举的内部属性（enumerable:false）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//而 ES6 的 class 允许子类继承父类的静态方法和静态属性，而普通的寄生组合式继承只能做到实例与实例之间的继承，对于类与类之间的继承需要额外定义方法，这里使用 Object.setPrototypeOf 将 superType 设置为 subType 的原型，从而能够从父类中继承静态方法和静态属性</span></span><br></pre></td></tr></table></figure><h5 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(superType.prototype);</span><br><span class="line">  prototype.constructor = subType;</span><br><span class="line">  subType.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  SuperType.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数本身不创建 <code>this</code>，在它声明时可以捕获别人的 <code>this</code> 供自己使用。<code>this</code> 一旦被捕获，以后将不再变化，即不会被 <code>call、apply 或 bind</code> 影响。</p><p>传统写法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="built_in">this</span>;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(_this.a);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fn.call(obj); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>箭头函数写法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//this 来源于 fn 函数的作用域</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fn.call(obj); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>如果用 <code>apply</code> 显式绑定：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> fn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;;</span><br><span class="line">fn.apply(obj);</span><br></pre></td></tr></table></figure><h4 id="事件函数"><a href="#事件函数" class="headerlink" title="事件函数"></a>事件函数</h4><p>如果是在事件函数当中，<code>this</code> 的绑定是指向触发事件的 <code>DOM</code> 元素的，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;body&#x27;</span>)[<span class="number">0</span>].addEventListener(</span><br><span class="line">  <span class="string">&#x27;click&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">false</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>点击 <code>body</code> 元素之后，控制台则会显示 <code>body</code> 元素。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果想判断一个函数的 <code>this</code> 绑定在哪里，首先是找到函数的调用位置，之后是按照规则来判断。</p><ul><li>如果函数调用时没有任何修饰条件，那么在严格模式下则会绑定到 <code>undefined</code>，非严格模式下会绑定到全局 <code>window</code>。</li><li>如果是用对象做上下文，来对函数进行调用，那么则会绑定到调用的这个对象上。</li><li>如果是用 <code>call</code> 或者 <code>apply</code> 方法来进行调用的，则会绑定到第一个传入参数上。</li><li>如果是使用 <code>new</code> 关键字来调用函数的，则会绑定到新创建的那个对象上.</li><li>如果是在事件函数内，则会绑定到触发事件的那个 <code>DOM</code> 元素上。</li><li>绑定优先级：<code>显式绑定 &gt; 隐式绑定 &gt; 默认绑定， new 绑定 &gt; 隐式绑定 &gt; 默认绑定</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> FE Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）JavaScript类型识别</title>
      <link href="237.html"/>
      <url>237.html</url>
      
        <content type="html"><![CDATA[<h2 id="类型系统"><a href="#类型系统" class="headerlink" title="类型系统"></a>类型系统</h2><blockquote><p>javascript 类型系统可以分为标准类型和对象类型，进一步标准类型又可以分为原始类型和引用类型，而对象类型又可以分为内置对象类型、普通对象类型、自定义对象类型。</p></blockquote><p><img data-src="http://cdn.flqin.com/p237-1.jpeg" alt="类型系统"></p><h3 id="类型转化表"><a href="#类型转化表" class="headerlink" title="类型转化表"></a>类型转化表</h3><p><img data-src="http://cdn.flqin.com/p237-2.png" alt="类型转化表"></p><h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><ul><li>typeof</li><li>instanceof</li><li>Object.prototype.toString</li><li>constructor</li></ul><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><ul><li>可以识别标准类型(<code>null</code> 除外)</li><li>不可识别具体的对象类型(<code>Function</code> 除外)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 可以识别标准类型(`null`除外)</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>; <span class="comment">//&quot;number&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;&#x27;</span>; <span class="comment">//&quot;string&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">//&quot;undefined&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">//&quot;boolean&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">//&quot;object&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 不可识别具体的对象类型(`Function`除外)</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">//&quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">//&quot;object&quot;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">//&quot;function&quot;</span></span><br></pre></td></tr></table></figure><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><blockquote><p><code>instanceof</code> 左侧为查询变量,右侧为标识对象的类</p></blockquote><ul><li>能够判别内置对象类型</li><li>不能判别原始类型</li><li>能够判别自定义类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 能够判别内置对象类型</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">//true</span></span><br><span class="line">/\d/ <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 不能判别原始类型</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>; <span class="comment">//false</span></span><br><span class="line"><span class="string">&#x27;xiaohong&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 能够判别自定义类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.x = x;</span><br><span class="line">  <span class="built_in">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">c <span class="keyword">instanceof</span> Point; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="实现一个-instanceof"><a href="#实现一个-instanceof" class="headerlink" title="实现一个 instanceof"></a>实现一个 instanceof</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceOf</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> proto = left.__proto__;</span><br><span class="line">  <span class="keyword">let</span> prototype = right.prototype;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proto === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (proto === prototype) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    proto = proto.__proto__;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h3><ul><li>可以识别标准类型,及内置对象类型</li><li>不能识别自定义类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 可以识别标准类型,及内置对象类型</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">21</span>); <span class="comment">//&quot;[object Number]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call([]); <span class="comment">//&quot;[object Array]&quot;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="regexp">/[A-Z]/</span>); <span class="comment">//&quot;[object RegExp]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 不能识别自定义类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.x = x;</span><br><span class="line">  <span class="built_in">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">//c instanceof Point;//true</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(c); <span class="comment">//&quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure><p>为了方便使用,使用函数封装如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeProto</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typeProto(<span class="string">&#x27;guo&#x27;</span>); <span class="comment">//&quot;String&quot;</span></span><br><span class="line">typeProto(&#123;&#125;); <span class="comment">//&quot;Object&quot;</span></span><br></pre></td></tr></table></figure><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><blockquote><p>constructor 指向构造这个对象的构造函数本身..</p></blockquote><ul><li>可识别原始类型</li><li>可识别内置对象类型</li><li>可识别自定义类型</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 可识别原始类型</span></span><br><span class="line"><span class="string">&#x27;guo&#x27;</span>.constructor === <span class="built_in">String</span>; <span class="comment">//true</span></span><br><span class="line">(<span class="number">1</span>).constructor === <span class="built_in">Number</span>; <span class="comment">//true</span></span><br><span class="line"><span class="literal">true</span>.constructor === <span class="built_in">Boolean</span>; <span class="comment">//true</span></span><br><span class="line">(&#123;&#125;.constructor === <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 可识别内置对象类型</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>().constructor === <span class="built_in">Date</span>; <span class="comment">//true</span></span><br><span class="line">[].constructor === <span class="built_in">Array</span>; <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 可识别自定义类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.x = x;</span><br><span class="line">  <span class="built_in">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> People(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">c.constructor === People; <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>为了方便使用,使用函数封装如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getConstructorName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor.toString().match(<span class="regexp">/function\s*([^(]*)/</span>)[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getConstructorName(<span class="keyword">new</span> <span class="built_in">Date</span>()); <span class="comment">//&quot;Date&quot;</span></span><br><span class="line">getConstructorName(<span class="literal">null</span>); <span class="comment">//null</span></span><br><span class="line">getConstructorName(<span class="number">12</span>); <span class="comment">//&quot;Number&quot;</span></span><br></pre></td></tr></table></figure><h2 id="类型判断对比表"><a href="#类型判断对比表" class="headerlink" title="类型判断对比表"></a>类型判断对比表</h2><p>其中红色的单元格表示该判断方式不支持的类型。</p><p><img data-src="http://cdn.flqin.com/p237-3.png" alt="类型判断对比表"></p>]]></content>
      
      
      <categories>
          
          <category> FE Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>函数声明、函数表达式等浅析</title>
      <link href="230.html"/>
      <url>230.html</url>
      
        <content type="html"><![CDATA[<p><code>javascript</code> 和其他编程语言相比比较随意，所以 <code>javascript</code> 代码中充满各种奇葩的写法，有时雾里看花，当然，能理解各型各色的写法也是对 <code>javascript</code> 语言特性更进一步的深入理解。</p><h2 id="函数基本概念"><a href="#函数基本概念" class="headerlink" title="函数基本概念"></a>函数基本概念</h2><h3 id="函数声明-function-declaration"><a href="#函数声明-function-declaration" class="headerlink" title="函数声明(function declaration)"></a>函数声明(function declaration)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnName</span> (<span class="params"></span>) </span>&#123;…&#125;;</span><br></pre></td></tr></table></figure><p>使用 <code>function</code> 关键字声明一个函数，再指定一个函数名，叫函数声明。</p><h3 id="函数表达式-function-expression"><a href="#函数表达式-function-expression" class="headerlink" title="函数表达式(function expression)"></a>函数表达式(function expression)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fnName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;…&#125;;</span><br></pre></td></tr></table></figure><p>将匿名函数赋予一个变量，叫函数表达式，这是最常见的函数表达式语法形式。</p><h3 id="匿名函数-Anonymous-Function"><a href="#匿名函数-Anonymous-Function" class="headerlink" title="匿名函数(Anonymous Function)"></a>匿名函数(Anonymous Function)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>使用 <code>function</code> 关键字声明一个函数，但未给函数命名，所以叫匿名函数。</p><p>匿名函数属于函数表达式，匿名函数有很多作用，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序或创建闭包等等。</p><p>匿名函数可以有效的保证在页面上写入 <code>Javascript</code>，而不会造成全局变量的污染。 这在给一个不是很熟悉的页面增加 <code>Javascript</code> 时非常有效，也很优美。</p><p><code>javascript</code> 中没用私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉，根据 <code>javascript</code> 函数作用域链的特性，可以使用这种技术可以模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量，所以 <code>( function()&#123;…&#125; )()</code> 内部定义的变量不会和外部的变量发生冲突，俗称“匿名包裹器”或“命名空间”。</p><h3 id="立即执行函数-IIFE"><a href="#立即执行函数-IIFE" class="headerlink" title="立即执行函数(IIFE)"></a>立即执行函数(IIFE)</h3><p>函数体后面加括号就能立即调用，则这个函数必须是函数表达式，不能是函数声明。 在理解了一些函数基本概念后，回头看看：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;…&#125; )()</span><br><span class="line">( <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;…&#125; () )</span><br></pre></td></tr></table></figure><p>这是两种立即执行函数的写法，一个括号包裹匿名函数，并直接在 ① 匿名函数的后面或者 ② 包含匿名函数括号的后面加个括号 就可以立即调用函数。</p><p>在 <code>function</code> 前面加<code>（）、！、+、 -</code> 甚至是逗号等到都可以起到函数定义后立即执行的效果，而 <code>（）、！、+、-、=</code> 等运算符，都将函数声明转换成函数表达式，消除了 <code>javascript</code> 引擎识别函数表达式和函数声明的歧义，告诉 <code>javascript</code> 引擎这是一个函数表达式，不是函数声明，可以在后面加括号，并立即执行函数的代码。</p><p>加括号是最安全的做法，因为<code>！、+、-</code>等运算符还会和函数的返回值进行运算，有时造成不必要的麻烦。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//firebug输出123,使用（）运算符</span></span><br><span class="line">&#125;)(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//firebug输出1234，使用（）运算符</span></span><br><span class="line">&#125;)(<span class="number">1234</span>);</span><br><span class="line"></span><br><span class="line">!(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//firebug输出12345,使用！运算符</span></span><br><span class="line">&#125;)(<span class="number">12345</span>);</span><br><span class="line"></span><br><span class="line">+(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//firebug输出123456,使用+运算符</span></span><br><span class="line">&#125;)(<span class="number">123456</span>);</span><br><span class="line"></span><br><span class="line">-(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//firebug输出1234567,使用-运算符</span></span><br><span class="line">&#125;)(<span class="number">1234567</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = (<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">//firebug输出12345678，使用=运算符</span></span><br><span class="line">&#125;)(<span class="number">12345678</span>);</span><br></pre></td></tr></table></figure><h2 id="函数声明和函数表达式区别"><a href="#函数声明和函数表达式区别" class="headerlink" title="函数声明和函数表达式区别"></a>函数声明和函数表达式区别</h2><ol><li><p><code>Javascript</code> 引擎在解析 <code>javascript</code> 代码时会 <code>函数声明提升（Function declaration Hoisting）</code> 当前执行环境（作用域）上的函数声明，而函数表达式必须等到 <code>Javascript</code> 引擎执行到它所在行时，才会从上而下一行一行地解析函数表达式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fnName();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正常，因为‘提升&#x27;了函数声明，函数调用可在函数声明之前</span></span><br><span class="line"></span><br><span class="line">fnName();</span><br><span class="line"><span class="keyword">var</span> fnName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//报错，变量fnName还未保存对函数的引用，函数调用必须在函数表达式之后</span></span><br></pre></td></tr></table></figure></li><li><p>函数表达式后面可以加括号立即调用该函数，函数声明不可以，只能以 <code>fnName()</code> 形式调用 。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fnName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">//函数表达式后面加括号，当javascript引擎解析到此处时能立即调用函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">//不会报错，但是javascript引擎只解析函数声明，忽略后面的括号，函数声明不会被调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;();</span><br><span class="line"><span class="comment">//语法错误，虽然匿名函数属于函数表达式，但是未进行赋值操作，</span></span><br><span class="line"><span class="comment">//所以javascript引擎将开头的function关键字当做函数声明，报错：要求需要一个函数名</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FE Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）谈谈使用 promise 时候的一些反模式</title>
      <link href="226.html"/>
      <url>226.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文链接 <code>https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html</code></p></blockquote><p>各位 <code>JavaScript</code> 程序员，是时候承认了，我们在使用 <code>promise</code> 的时候，会写出许多有问题的 <code>promise</code> 代码。 当然并不是 <code>promise</code> 本身的问题，<code>A+ spec</code> 规范定义的 <code>promise</code> 非常棒。 在过去的几年中，笔者看到了很多程序员在调用 <code>PouchDB</code> 或者其他 <code>promise</code> 化的 <code>API</code> 时遇到了很多困难。这让笔者认识到，在 <code>JavaScript</code> 程序员之中，只有少数人是真正理解了 <code>promise</code> 规范的。如果这个事实让你难以接受，那么思考一下我在 <code>Twitter</code> 上出的题：</p><p>问：下面四个使用 promise 的语句之间的不同点在哪儿？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doSomethingElse();</span><br><span class="line">&#125;)；</span><br><span class="line"></span><br><span class="line">doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    doSomethingElse();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">doSomething().then(doSomethingElse());</span><br><span class="line"></span><br><span class="line">doSomething().then(doSomethingElse);</span><br></pre></td></tr></table></figure><p>如果你知道这个问题的答案，那么恭喜你，你已经是一个 <code>promise</code> 大师并且可以直接关闭这个网页了。</p><p>但是对于不能回答这个问题的程序员中 99.9% 的人，别担心，你们不是少数派。没有人能够在笔者的 <code>tweet</code> 上完全正确的回答这个问题，而且对于 #3 最终答案也令我感到震惊，即便我是出题人。</p><p>答案在本文的底部，但是首先，笔者必须先探究一下 <code>promise</code> 为何如此复杂，为什么不管是新手还是专家都有被 <code>promise</code> 折磨的经历。同时，笔者也会给出自认为能够快速、准确理解 <code>promise</code> 的方法。而且笔者确信读过这篇文章之后，理解 <code>promise</code> 不会那么难了。</p><p>在此之前，我们先了解一下有关 <code>promise</code> 的一些常识。</p><h2 id="Promise-的起源"><a href="#Promise-的起源" class="headerlink" title="Promise 的起源"></a>Promise 的起源</h2><p>如果你读过有关 <code>promise</code> 的文章，你会发现文章中一定会提到 <code>Callback hell</code>，不说别的，在视觉上，回调金字塔会让你的代码最终超过屏幕的宽度。</p><p><code>promise</code> 是能够解决这个问题的，但是它解决的问题不仅仅是缩进。在讨论到如何 解决 <code>Callback hell</code> 问题 的时候，我们遇到真正的难题是回调函数剥夺了程序员使用 <code>return</code> 和 <code>throw</code> 的能力。而程序的执行流程的基础建立于一个函数在执行过程中调用另一个函数时产生的副作用。(译者注：个人对这里副作用的理解是，函数调用函数会产生函数调用栈，而回调函数是不运行在栈上的，因此不能使用 <code>return</code> 和 <code>throw</code>)。</p><p>事实上，回调函数还有更恼人的——剥夺我们在栈上执行代码的能力，而在其他语言当中，我们始终都能够在栈上执行代码。编写不在栈上运行的代码就像开没有刹车的车一样，在你真正需要它的时候，才明白它有多么的重要。</p><p><code>promise</code> 被设计为能够让我们重新使用那些编程语言的基本要素：<code>return，throw，栈。</code> 在想要使用 <code>promise</code> 之前，我们首先要学会正确使用它。</p><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>一些人尝试使用 漫画 的方式解释 <code>promise</code>，或者是像是解释名词一样解释它：它表示同步代码中的值，并且能在代码中被传递。</p><p>笔者并没有觉得这些解释对理解 <code>promise</code> 有用。笔者自己的理解是：<code>promise</code> 是关于代码结构和代码运行流程的。因此，笔者认为展示一些常见错误，并告诉大家如何修正它才是王道。</p><p>扯远一点，对于 <code>promise</code>，不同的人有不同的理解，为了本文的最终目的，我在这里只讨论 <code>promise</code> 的官方 规范，在较新版本的浏览器会作为 <code>window</code> 对象的一个属性被暴露出来。然而并不是所有的浏览器都支持这一特性，但是到目前为止有许多 <code>polyfill</code>，比如这个名字很大胆并且实现非常简洁的 <code>promise</code> 库：<code>Lie</code>。</p><h3 id="新手错误-1：Callback-hell"><a href="#新手错误-1：Callback-hell" class="headerlink" title="新手错误 1：Callback hell"></a>新手错误 1：Callback hell</h3><p><code>PouchDB</code> 有许多 <code>promise</code> 风格的 <code>API</code>，程序员在写有关 <code>PouchDB</code> 的代码的时候，常常将 <code>promise</code> 用的一塌糊涂。下面给出一种很常见的糟糕写法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">remote.allDocs(&#123;</span><br><span class="line">    include_docs: <span class="literal">true</span>,</span><br><span class="line">    attachment: <span class="literal">true</span></span><br><span class="line">&#125;).then(functionb (result) &#123;</span><br><span class="line">    <span class="keyword">var</span> docs = result.rows;</span><br><span class="line">    docs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">        localdb.put(element.doc).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">&#x27;pulled doc with id&#x27;</span> + element.doc._id + <span class="string">&#x27;and added to local db.&#x27;</span>);&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err.status == <span class="number">409</span>) &#123;</span><br><span class="line">            localdb.get(element.doc._id).then(<span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</span><br><span class="line">             localdb.remove(resp._id, resp._rev).then(<span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</span><br><span class="line"><span class="comment">// et cetera...</span></span><br></pre></td></tr></table></figure><p>你确实可以将 <code>promise</code> 当做回调函数来使用，但这却是一种杀鸡用牛刀的行为。不过这么做也是可行的。 你可能会认为这种错误是那些刚入行的新手才会犯的。但是笔者在黑莓的 开发者博客 上曾经看到类似的代码。过去的书写回调函数的习惯是很难改变的。</p><p>下面给出一种代码风格更好的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">remotedb.allDocs(...).then(functioin (resultofAllDocs) &#123;</span><br><span class="line">    <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfPut</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> localdb.get(...);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">resultOfGet</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> localdb.put(...);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这就是 <code>promise</code> 的链式调用，它体现 <code>promise</code> 的强大之处，每个函数在上一个 <code>promise</code> 的状态变为 <code>resolved</code> 的时候才会被调用，并且能够得到上一个 <code>promise</code> 的输出结果。稍后还有详细的解释。</p><h3 id="新手错误-2：怎样用-forEach-处理-promise"><a href="#新手错误-2：怎样用-forEach-处理-promise" class="headerlink" title="新手错误 2：怎样用 forEach() 处理 promise"></a>新手错误 2：怎样用 forEach() 处理 promise</h3><p>这个问题是大多数人掌握 <code>promise</code> 的绊脚石，当这些人想在代码中使用他们熟悉的 <code>forEach()</code> 方法或者是写一个 <code>for</code> 循环，抑或是 <code>while</code> 循环的时候，都会为如何使用 <code>promise</code> 而疑惑不已。他们会写下这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// I want to remove() all docs</span></span><br><span class="line">db.allDocs(&#123; <span class="attr">include_docs</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    result.rows.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">row</span>) </span>&#123;</span><br><span class="line">      db.remove(row.doc);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// I naively believe all docs have been removed() now!</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>这段代码的问题在于第一个回调函数实际上返回的是 <code>undefined</code>，也就意味着第二个函数并不是在所有的 <code>db.remove()</code> 执行结束之后才执行。事实上，第二个函数的执行不会有任何延时，它执行的时候被删除的 <code>doc</code> 数量可能为任意整数。</p><p>这段代码看起来是能够正常工作的，因此这个 <code>bug</code> 也具有一定的隐藏性。写这代码的人以为 <code>PouchDB</code> 已经删除了这些 <code>docs</code>，可以更新 <code>UI</code> 了。这个 <code>bug</code> 会在一定几率下出现，或者是特定的浏览器。而一旦出现，这种 <code>bug</code> 是很难调试的。</p><p>一言以蔽之，你需要的不是 <code>forEach()/for/while</code> 而是 <code>Promise.all()：</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.allDocs(&#123; <span class="attr">include_docs</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">      result.rows.map(<span class="function"><span class="keyword">function</span> (<span class="params">row</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> db.remove(row.doc);</span><br><span class="line">      &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">arrayObject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// All docs have really been removed() now!</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>从根本上说，<code>Promise.all()</code> 以一个 <code>promise</code> 对象组成的数组为输入，返回另一个 <code>promise</code> 对象。这个对象的状态只会在数组中所有的 <code>promise</code> 对象的状态都变为 <code>resolved</code> 的时候才会变成 <code>resolved</code>。可以将其理解为异步的 <code>for</code> 循环。</p><p><code>Promise.all()</code> 还会将计算结果以数组的形式传递给下一个函数，这一点十分有用。举例来说，如果你想用 <code>get()</code> 方法从 <code>PouchDB</code> 得到多个值的时候，就可以利用这个特性。同时，作为输入的一系列 <code>promise</code> 对象中，如果有一个的状态变为 <code>rejected</code>，那么 <code>all()</code> 返回的 <code>promise</code> 对象的状态也会变为 <code>rejected</code>。</p><h3 id="新手错误-3：忘记添加-catch-方法"><a href="#新手错误-3：忘记添加-catch-方法" class="headerlink" title="新手错误 3：忘记添加 catch() 方法"></a>新手错误 3：忘记添加 catch() 方法</h3><p>这是一个很常见的错误。很多程序员对他们代码中的 <code>promise</code> 调用十分自信，觉得代码永远不会抛出一个 <code>error</code>，也可能他们只是简单的忘了加 <code>catch()</code> 方法。不幸的是，不加 <code>catch()</code> 方法会让回调函数中抛出的异常被吞噬，在你的控制台是看不到相应的错误的，这对调试来说是非常痛苦的。</p><p>为了避免这种糟糕的情况，我已经养成了在自己的 <code>promise</code> 调用链最后添加如下代码的习惯：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">somePromise()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> anotherPromise();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> yetAnotherPromise();</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="built_in">console</span>.log.bind(<span class="built_in">console</span>)); <span class="comment">// &lt;-- this is badass</span></span><br></pre></td></tr></table></figure><p>即使你并不打算在代码中处理异常，在代码中添加 <code>catch()</code> 也是一个谨慎的编程风格的体现。在某种情况下你原先的假设出错的时候，这会让你的调试工作轻松一些。</p><h3 id="新手错误-4：使用-“deferred”"><a href="#新手错误-4：使用-“deferred”" class="headerlink" title="新手错误 4：使用 “deferred”"></a>新手错误 4：使用 “deferred”</h3><p>这类型 错误 笔者经常看到，在这里我也不想重复它了。简而言之，<code>promise</code> 经过了很长一段时间的发展，有一定的历史包袱。<code>JavaScript</code> 社区用了很长的时间才纠正了发展道路上的一些错误。<code>jQuery</code> 和 <code>Angular</code> 早期都在使用 <code>deferred</code> 类型的 <code>promise</code>。而在最新的 <code>ES6</code> 的 <code>Promise</code> 标准中，这种实现方式已经被替代了，同时，一些 <code>Promise</code> 的库，比如 <code>Q，bluebid，Lie</code> 也是参照 <code>ES6</code> 的标准来实现的。</p><p>如果你还在代码中使用 <code>deferred</code> 的话，那么你就是走在错误的道路上了，这里笔者给出一些修正的办法。</p><p>首先，绝大多数的库都给出了将第三方库的方法包装成 <code>promise</code> 对象的方法。举例来说，<code>Angular</code> 的 <code>$q</code> 模块可以使用 <code>$q.when()</code> 完成这一包装过程。因此，在 <code>Angular</code> 中，包装 <code>PouchDB</code> 的 <code>promise API</code> 的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$q.when(db.put(doc)).then(...) <span class="comment">// &lt;-- this is all the code you need</span></span><br></pre></td></tr></table></figure><p>另一种方法就是使用暴露给程序员的 构造函数。<code>promise</code> 的构造函数能够包装那些非 <code>promise</code> 的 <code>API</code>。下面给出一个例子，在该例中将 <code>Node.js</code> 提供的 f<code>s.readFile()</code> 方法包装成 <code>promise</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">&#x27;myfile.txt&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="keyword">return</span> reject(err);</span><br><span class="line">        &#125;</span><br><span class="line">        resolve(file);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(...)</span><br></pre></td></tr></table></figure><p>齐活！</p><p>如果你想更多的了解为什么这样的写法是一个反模式，猛戳这里 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3BldGthYW50b25vdi9ibHVlYmlyZC93aWtpL1Byb21pc2UtYW50aS1wYXR0ZXJucyN0aGUtZGVmZXJyZWQtYW50aS1wYXR0ZXJu">the Bluebird wiki page on promise anti-patterns<i class="fa fa-external-link-alt"></i></span></p><h3 id="新手错误-5：不显式调用-return"><a href="#新手错误-5：不显式调用-return" class="headerlink" title="新手错误 5：不显式调用 return"></a>新手错误 5：不显式调用 return</h3><p>下面这段代码的问题在哪里？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">somePromise()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    someOtherPromise();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Gee, I hope someOtherPromise() has resolved</span></span><br><span class="line">    <span class="comment">// Spoiler alert: it hasn&#x27;t</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>现在该讨论所有需要了解的关于 <code>promise</code> 的知识点了。理解了这一个知识点，笔者提到的一些错误你都不会犯了。</p><p>正如笔者前面所说的，<code>promise</code> 的神奇之处在于让我们能够在回调函数里面使用 <code>return</code> 和 <code>throw</code>。但是实践的时候是什么样子呢？</p><p>每一个 <code>promise</code> 对象都会提供一个 <code>then</code> 方法或者是 <code>catch</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">somePromise().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// I&#x27;m inside a then() function!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 <code>then</code> 方法内部，我们可以做三件事：</p><ul><li><code>return</code> 一个 <code>promise</code> 对象</li><li><code>return</code> 一个同步的值或者是 <code>undefined</code></li><li>同步的 <code>throw</code> 一个错误</li></ul><p>理解这三种情况之后，你就会理解 <code>promise</code> 了。</p><h4 id="返回另一个-promise-对象"><a href="#返回另一个-promise-对象" class="headerlink" title="返回另一个 promise 对象"></a>返回另一个 promise 对象</h4><p>在有关 <code>promise</code> 的相关文章中，这种写法很常见，就像上文提到的构成 <code>promise</code> 链的一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">&#x27;nolan&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p>这段代码里面的 <code>return</code> 非常关键，没有这个 <code>return</code> 的话，<code>getUserAccountById</code> 只是一个普通的被别的函数调用的函数。下一个回调函数会接收到 <code>undefined</code> 而不是 <code>userAccount</code>。</p><h4 id="返回一个同步的值或者是-undefined"><a href="#返回一个同步的值或者是-undefined" class="headerlink" title="返回一个同步的值或者是 undefined"></a>返回一个同步的值或者是 <code>undefined</code></h4><p>返回一个 <code>undefined</code> 大多数情况下是错误的，但是返回一个同步的值确实是一个将同步代码转化成 <code>promise</code> 风格代码的好方法。举个例子，现在在内存中有 <code>users</code>。我们可以：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">&#x27;nolan&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class="line">      <span class="keyword">return</span> inMemoryCache[user.id]; <span class="comment">// returning a synchronous value!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inMemoryCache[user.id]; <span class="comment">// returning a promise</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// I got a user account</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>第二个回调函数并不关心 <code>userAccount</code> 是通过同步的方式得到的还是异步的方式得到的，而第一个回调函数即可以返回同步的值又可以返回异步的值。</p><p>不幸的是，如果不显式调用 <code>return</code> 语句的话，<code>JavaScript</code> 里的函数会返回 <code>undefined</code>。这也就意味着在你想返回一些值的时候，不显式调用 <code>return</code> 会产生一些副作用。</p><p>鉴于以上原因，笔者养成了一个在 <code>then</code> 方法内部永远显式的调用 <code>return</code> 或者 <code>throw</code> 的习惯。建议你也这样做。</p><h4 id="抛出一个同步的错误"><a href="#抛出一个同步的错误" class="headerlink" title="抛出一个同步的错误"></a>抛出一个同步的错误</h4><p>说到 <code>throw</code>，这又体现了 <code>promise</code> 的功能强大。在用户退出的情况下，我们的代码中会采用抛出异常的方式进行处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">&#x27;nolan&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (user.isLoggedOut()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;user logged out!&#x27;</span>); <span class="comment">// throwing a synchronous error!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inMemoryCache[user.id]) &#123;</span><br><span class="line">      <span class="keyword">return</span> inMemoryCache[user.id]; <span class="comment">// returning a synchronous value!</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id); <span class="comment">// returning a promise!</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// I got a user account!</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Boo, I got an error!</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>如果用户已经登出的话，<code>catch()</code> 会收到一个同步的错误，如果有 <code>promise</code> 对象的状态变为 <code>rejected</code> 的话，它还会收到一个异步的错误。<code>catch()</code> 的回调函数不用关心错误是异步的还是同步的。</p><p>在使用 <code>promise</code> 的时候抛出异常在开发阶段很有用，它能帮助我们定位代码中的错误。比方说，在 <code>then</code> 函数内部调用 <code>JSON.parse（）</code>，如果 <code>JSON</code> 对象不合法的话，可能会抛出异常，在回调函数中，这个异常会被吞噬，但是在使用 <code>promise</code> 之后，我们就可以捕获到这个异常了。</p><h2 id="进阶错误"><a href="#进阶错误" class="headerlink" title="进阶错误"></a>进阶错误</h2><p>接下来我们讨论一下使用 <code>promise</code> 的边界情况。</p><p>下面的错误笔者将他们归类为 “进阶错误”，因为这些错误发生在那些已经相对熟练使用 <code>promise</code> 的程序员身上。但是为了解决本文开头提出的问题，还是有必要对其进行讨论。</p><h3 id="进阶错误-1：不了解-Promise-resolve"><a href="#进阶错误-1：不了解-Promise-resolve" class="headerlink" title="进阶错误 1：不了解 Promise.resolve()"></a>进阶错误 1：不了解 Promise.resolve()</h3><p>就像之前所说的，<code>promise</code> 能够将同步代码包装成异步的形式。然而，如果你经常写出如下的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(someSynchronousValue);</span><br><span class="line">&#125;).then(...);</span><br></pre></td></tr></table></figure><p>你可以使用 <code>Promise.resolve()</code> 将上述代码精简。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(someSynchronousValue).then(...);</span><br></pre></td></tr></table></figure><p>在捕获同步异常的时候这个做法也是很有效的。我在编写 <code>API</code> 的时候已经养成了使用 <code>Promise.resolve()</code> 的习惯：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">somePromiseAPI</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    doSomethingThatMayThrow();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">  &#125;).then(...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记住，有可能抛出错误的代码都有可能因为错误被吞噬而对你的工作造成困扰。但是如果你用 <code>Promise.resolve()</code> 包装了代码的话，你永远都可以在代码后面加上 <code>catch()</code>。</p><p>相同的，使用 <code>Promise.reject()</code> 可以立即返回一个状态为 <code>rejected</code> 的 <code>promise</code> 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;some awful error&#x27;</span>));</span><br></pre></td></tr></table></figure><h3 id="进阶错误-2：cacth-和-then-null-…-并不完全相同"><a href="#进阶错误-2：cacth-和-then-null-…-并不完全相同" class="headerlink" title="进阶错误 2：cacth() 和 then(null, …) 并不完全相同"></a>进阶错误 2：cacth() 和 then(null, …) 并不完全相同</h3><p>笔者提到过 <code>cacth()</code> 是 <code>then(null, ...)</code> 的语法糖，因此下面两个代码片段是等价的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">somePromise().catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">somePromise().then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是，这并不意味着下面的两个代码片段是等价的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">somePromise()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> someOtherPromise();</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">somePromise().then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> someOtherPromise();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果你不理解的话，那么请思考一下如果第一个回调函数抛出一个错误会发生什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">somePromise()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;oh noes&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// I caught your error! :)</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">somePromise().then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;oh noes&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// I didn&#x27;t catch your error! :(</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>结论就是，当使用 <code>then(resolveHandler, rejectHandler)</code>，<code>rejectHandler</code> 不会捕获在 <code>resolveHandler</code> 中抛出的错误。</p><p>因为，笔者的个人习惯是从不使用 <code>then</code> 方法的第二个参数，转而使用 <code>catch()</code> 方法。但是也有例外，就是在笔者写异步的 <code>Mocha</code> 的测试用例的时候，如果想确认一个错误被抛出的话，代码是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">&#x27;should throw an error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doSomethingThatThrows().then(</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;I expected an error!&#x27;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      should.exist(err);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>说到测试，将 <code>mocha</code> 和 <code>Chai</code> 联合使用是一种很好的测试 <code>promise API</code> 的方案。</p><h3 id="进阶错误-3：promise-vs-promise-factories"><a href="#进阶错误-3：promise-vs-promise-factories" class="headerlink" title="进阶错误 3：promise vs promise factories"></a>进阶错误 3：promise vs promise factories</h3><p>某些情况下你想一个接一个的执行一系列 <code>promise</code>，这时候你想要一个类似于 <code>Promise.all()</code> 的方法，但是 <code>Proimise.all()</code> 是并行执行的，不符合要求。你可能一时脑抽写下这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeSequentially</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  promises.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">promise</span>) </span>&#123;</span><br><span class="line">    result = result.then(promise);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不幸的是，这段代码不会按照你所想的那样执行，那些 <code>promise</code> 对象里的异步调用还是会并行的执行。原因是你根本不应当在 <code>promise</code> 对象组成的数组这个层级上操作。对于每个 <code>promise</code> 对象来说，一旦它被创建，相关的异步代码就开始执行了。因此，这里你真正想要的是一个 <code>promise</code> 工厂。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">executeSequentially</span>(<span class="params">promiseFactories</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  promiseFactories.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">promiseFactory</span>) </span>&#123;</span><br><span class="line">    result = result.then(promiseFactory);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个 <code>promise</code> 工厂非常简单，它就是一个返回 <code>promise</code> 对象的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromiseFactory</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> somethingThatCreatesAPromise();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么采用 <code>promise</code> 对象就可以达到目的呢？因为 <code>promise</code> 工厂只有在调用的时候才会创建 <code>promise</code> 对象。它和 <code>then()</code> 方法的工作方式很像，事实上，它们就是一样的东西。</p><h3 id="进阶错误-4：如果我想要两个-promise-的结果应当如何做呢"><a href="#进阶错误-4：如果我想要两个-promise-的结果应当如何做呢" class="headerlink" title="进阶错误 4：如果我想要两个 promise 的结果应当如何做呢"></a>进阶错误 4：如果我想要两个 promise 的结果应当如何做呢</h3><p>很多时候，一个 <code>promise</code> 的执行是依赖另一个 <code>promise</code> 的。但是在某些情况下，我们想得到两个 <code>promise</code> 的执行结果，比方说：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">&#x27;nolan&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// dangit, I need the &quot;user&quot; object too!</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>为了避免金字塔问题，我们可能会在外层作用域存储 <code>user</code> 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user;</span><br><span class="line">getUserByName(<span class="string">&#x27;nolan&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    user = result;</span><br><span class="line">    <span class="keyword">return</span> getUserAccountById(user.id);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// okay, I have both the &quot;user&quot; and the &quot;userAccount&quot;</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>上面的代码能够到达想要的效果，但是这种显得不够专业，我建议抛开成见，拥抱金字塔：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getUserByName(<span class="string">&#x27;nolan&#x27;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// okay, I have both the &quot;user&quot; and the &quot;userAccount&quot;</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>至少，是暂时拥抱金字塔。如果缩进真的成为了你代码中的一个大问题，那么你可以像每一个 <code>JavaScript</code> 程序员从开始写代码起就被教导的一样，将其中的部分抽出来作为一个单独的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onGetUserAndUserAccount</span>(<span class="params">user, userAccount</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doSomething(user, userAccount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onGetUser</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getUserAccountById(user.id).then(<span class="function"><span class="keyword">function</span> (<span class="params">userAccount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> onGetUserAndUserAccount(user, userAccount);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserByName(<span class="string">&#x27;nolan&#x27;</span>)</span><br><span class="line">  .then(onGetUser)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// at this point, doSomething() is done, and we are back to indentation 0</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>随着你的 <code>promise</code> 代码越来越复杂，你会将越来越多的代码作为函数抽离出来。笔者发现这会促进代码风格变得优美：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">putYourRightFootIn().then(putYourRightFootOut).then(putYourRightFootIn).then(shakeItAllAbout);</span><br></pre></td></tr></table></figure><p>这就是 <code>promise</code> 的最终目的。</p><h3 id="进阶错误-5：promise-穿透"><a href="#进阶错误-5：promise-穿透" class="headerlink" title="进阶错误 5：promise 穿透"></a>进阶错误 5：promise 穿透</h3><p>这个错误我在前文中提到的问题中间接的给出了。这是个非常令人费解的案例，或许你永远不会写出这样的代码，但是这种写法还是让笔者感到震惊。 你认为下面的代码会输出什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">  .then(<span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>))</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>如果你认为输出的是 <code>bar</code>，那么你就错了。实际上它输出的是 <code>foo</code>！</p><p>产生这样的输出是因为你给 <code>then</code> 方法传递了一个非函数（比如 <code>promise</code> 对象）的值，代码会这样理解：<code>then(null)</code>，因此导致前一个 <code>promise</code> 的结果产生了坠落的效果。你可以自己测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">  .then(<span class="literal">null</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>随便添加任意多个 <code>then(null)</code>，结果都是不变的</p><p>让我们回到之前讲解 <code>promise vs promise factoriesde</code> 的地方。简而言之，如果你直接给 <code>then</code> 方法传递一个 <code>promise</code> 对象，代码的运行是和你所想的不一样的。<code>then</code> 方法应当接受一个函数作为参数。因此你应当这样书写代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>这样就会如愿输出 <code>bar</code>。</p><h3 id="答案来了"><a href="#答案来了" class="headerlink" title="答案来了"></a>答案来了</h3><p>下面给出前文题目的解答</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#1</span><br><span class="line"></span><br><span class="line">    doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> doSomethingElse();</span><br><span class="line">    &#125;).then(finalHandler);</span><br><span class="line"></span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line">    doSomething</span><br><span class="line">    |-----------------|</span><br><span class="line">                      doSomethingElse(<span class="literal">undefined</span>)</span><br><span class="line">                      |------------------|</span><br><span class="line">                                         finalHandler(resultOfDoSomethingElse)</span><br><span class="line">                                         |------------------|</span><br><span class="line"></span><br><span class="line">#2</span><br><span class="line"></span><br><span class="line">    doSomething().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      doSomethingElse();</span><br><span class="line">    &#125;).then(finalHandler);</span><br><span class="line"><span class="string">``</span></span><br><span class="line">答案：</span><br><span class="line"></span><br><span class="line">    doSomething</span><br><span class="line">    |-----------------|</span><br><span class="line">                      doSomethingElse(<span class="literal">undefined</span>)</span><br><span class="line">                      |------------------|</span><br><span class="line">                      finalHandler(<span class="literal">undefined</span>)</span><br><span class="line">                      |------------------|</span><br><span class="line"></span><br><span class="line">#3</span><br><span class="line"></span><br><span class="line">    doSomething().then(doSomethingElse())</span><br><span class="line">      .then(finalHandler);</span><br><span class="line"></span><br><span class="line">答案</span><br><span class="line"></span><br><span class="line">    doSomething</span><br><span class="line">    |-----------------|</span><br><span class="line">    doSomethingElse(<span class="literal">undefined</span>)</span><br><span class="line">    |---------------------------------|</span><br><span class="line">                      finalHandler(resultOfDoSomething)</span><br><span class="line">                      |------------------|</span><br><span class="line"></span><br><span class="line">#4</span><br><span class="line"></span><br><span class="line">    doSomething().then(doSomethingElse)</span><br><span class="line">      .then(finalHandler);</span><br><span class="line"></span><br><span class="line">答案</span><br><span class="line"></span><br><span class="line">    doSomething</span><br><span class="line">    |-----------------|</span><br><span class="line">                      doSomethingElse(resultOfDoSomething)</span><br><span class="line">                      |------------------|</span><br><span class="line">                                         finalHandler(resultOfDoSomethingElse)</span><br><span class="line">                                         |------------------|</span><br></pre></td></tr></table></figure><p>需要说明的是，在上述的例子中，我都假设 <code>doSomething()</code> 和 <code>doSomethingElse()</code> 返回一个 <code>promise</code> 对象，这些 <code>promise</code> 对象都代表了一个异步操作，这样的操作会在当前 <code>event loop</code> 之外结束，比如说有关 <code>IndexedDB，network</code> 的操作，或者是使用 <code>setTimeout</code>。这里给出 <span class="exturl" data-url="aHR0cDovL2pzYmluLmNvbS90dXF1a2FrYXdvLzEvZWRpdD9qcyxjb25zb2xlLG91dHB1dA==">JSBin<i class="fa fa-external-link-alt"></i></span> 上的示例。</p><h3 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h3><p><code>promise</code> 是个好东西。如果你还在使用传统的回调函数的话，我建议你迁移到 <code>promise</code> 上。这样你的代码会更简洁，更优雅，可读性也更强。</p><p>有这样的观点：<code>promise</code> 是不完美的。<code>promise</code> 确实比使用回调函数好，但是，如果你有别的选择的话，这两种方式最好都不要用。</p><p>尽管相比回调函数有许多优点，promise 仍然是难于理解的，并且使用起来很容易出错。新手和卖家都会经常将 <code>promise</code> 用的乱七八糟。不过这并不是他们的错。问题在于 <code>promise</code> 和我们写的同步代码非常相似，但仅此而已，并不尽然。</p><p>在同步环境下，你无需学习这些晦涩难懂的规则和新的 <code>API</code>。你可以随意使用像 <code>return</code>、<code>catch</code> 和 <code>throw</code> 这样的关键字以及 <code>for</code> 循环。你不需要时刻在脑中保持两个相并列的编程思想。</p>]]></content>
      
      
      <categories>
          
          <category> FE Js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BFC等Formatting Contexts浅析</title>
      <link href="224.html"/>
      <url>224.html</url>
      
        <content type="html"><![CDATA[<h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><p><code>CSS</code> 盒模型描述了通过 <code>文档树中的元素</code> 以及相应的 <code>视觉格式化模型(visual formatting model)</code> 所生成的矩形盒子。</p><h3 id="什么是-BFC"><a href="#什么是-BFC" class="headerlink" title="什么是 BFC"></a>什么是 BFC</h3><p><code>BFC(Block formatting context)</code> 直译为”块级格式化上下文”。它是一个独立的渲染区域，只有 <code>Block-level box</code> 参与，它规定了内部的 <code>Block-level Box</code> 如何布局，并且与这个区域外部毫不相干。同理，还有 <code>inline-level box，run-in box</code>。</p><h3 id="BFC-布局规则"><a href="#BFC-布局规则" class="headerlink" title="BFC 布局规则"></a>BFC 布局规则</h3><ul><li>内部的 <code>Box</code> 会在垂直方向，一个接一个地放置。</li><li><code>Box</code> 垂直方向的距离由 <code>margin</code> 决定。属于同一个 <code>BFC</code> 的两个相邻 <code>Box</code> 的 <code>margin</code> 会发生重叠。</li><li>每个元素的 <code>margin box</code> 的左边， 与包含块 <code>border box</code> 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li><code>BFC</code> 的区域不会与 <code>float box</code> 重叠。</li><li><code>BFC</code> 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li><li>计算 <code>BFC</code> 的高度时，浮动元素也参与计算。</li></ul><h3 id="哪些元素是-BFC"><a href="#哪些元素是-BFC" class="headerlink" title="哪些元素是 BFC"></a>哪些元素是 BFC</h3><ul><li>根元素，即 <code>HTML</code> 元素</li><li><code>float</code> 属性不为 <code>none</code></li><li><code>position</code> 为 <code>absolute</code> 或 <code>fixed</code></li><li><code>display</code> 为 <code>inline-block, table-cell, table-caption, flex, inline-flex</code></li><li><code>overflow</code> 不为 <code>visible</code></li></ul><h3 id="BFC-有什么用"><a href="#BFC-有什么用" class="headerlink" title="BFC 有什么用"></a>BFC 有什么用</h3><ul><li>自适应两栏布局</li><li>清除内部浮动（如给父元素加 <code>overflow:hidden</code>）</li><li>分属于不同的 <code>BFC</code> 时可以阻止 <code>margin</code> 重叠</li></ul><h3 id="什么是-FC"><a href="#什么是-FC" class="headerlink" title="什么是 FC"></a>什么是 FC</h3><p><code>FC</code> 的全称是：<code>Formatting Contexts</code>，是 <code>W3C CSS2.1</code> 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p><p><code>FC</code> 一共包含 <code>BFC、IFC、GFC、FFC</code> 四种类型。<code>CSS2.1</code> 规范中只有 <code>BFC、IFC。CSS3</code> 推出 <code>GFC、FFC</code> 两种新类型。</p><h3 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h3><p><code>IFC(Inline Formatting Contexts)</code> 直译为”内联格式化上下文”，<code>IFC</code> 的 <code>line box</code>（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 <code>padding/margin</code> 影响)。</p><h4 id="IFC-特性"><a href="#IFC-特性" class="headerlink" title="IFC 特性"></a>IFC 特性</h4><ul><li><code>IFC</code> 中的 <code>line box</code> 一般左右都贴紧整个 <code>IFC</code>，但是会因为 <code>float</code> 元素而扰乱。<code>float</code> 元素会位于 <code>IFC</code> 与与 <code>line box</code> 之间，使得 l<code>ine box</code> 宽度缩短。</li><li><code>IFC</code> 中时不可能有块级元素的，当插入块级元素时（如 <code>p</code> 中插入 <code>div</code>）会产生两个匿名块与 <code>div</code> 分隔开，即产生两个 <code>IFC</code>，每个 <code>IFC</code> 对外表现为块级元素，与 <code>div</code> 垂直排列。</li></ul><h4 id="IFC-作用"><a href="#IFC-作用" class="headerlink" title="IFC 作用"></a>IFC 作用</h4><ul><li>水平居中：当一个块要在环境中水平居中时，设置其为 <code>inline-block</code> 则会在外层产生 <code>IFC</code>，通过 <code>text-align</code> 则可以使其水平居中。</li><li>垂直居中：创建一个 <code>IFC</code>，用其中一个元素撑开父元素的高度，然后设置其 <code>vertical-align:middle</code>，其他行内元素则可以在此父元素下垂直居中。</li></ul><h3 id="GFC"><a href="#GFC" class="headerlink" title="GFC"></a>GFC</h3><p><code>GFC(GridLayout Formatting Contexts)</code> 直译为”网格布局格式化上下文”，当为一个元素设置 <code>display</code> 值为 <code>grid</code> 的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（<code>grid container</code>）上定义网格定义行（<code>grid definition rows</code>）和网格定义列（<code>grid definition columns</code>）属性各在网格项目（<code>grid item</code>）上定义网格行（<code>grid row</code>）和网格列（<code>grid columns</code>）为每一个网格项目（<code>grid item</code>）定义位置和空间。</p><p><code>GFC</code> 将改变传统的布局模式，他将让布局从一维布局变成了二维布局。简单的说，有了 <code>GFC</code> 之后，布局不再局限于单个维度了。这个时候你要实现类似九宫格，拼图之类的布局效果显得格外的容易。</p><h3 id="FFC"><a href="#FFC" class="headerlink" title="FFC"></a>FFC</h3><p><code>FFC(Flex Formatting Contexts)</code> 直译为”自适应格式化上下文”，<code>display</code> 值为 <code>flex</code> 或者 <code>inline-flex</code> 的元素将会生成自适应容器<code>（flex container）</code>。</p><p><code>Flex Box</code> 由伸缩容器和伸缩项目组成。通过设置元素的 <code>display</code> 属性为 <code>flex</code> 或 <code>inline-flex</code> 可以得到一个伸缩容器。设置为 <code>flex</code> 的容器被渲染为一个块级元素，而设置为 <code>inline-flex</code> 的容器则渲染为一个行内元素。</p><p>伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，<code>Flexbox</code> 定义了伸缩容器内伸缩项目该如何布局。</p><p>整体来说，<code>FFC</code> 与 <code>BFC</code> 有点儿类似，但仍有以下几点区别：</p><ul><li><code>Flexbox</code> 不支持 <code>::first-line</code> 和 <code>::first-letter</code> 这两种伪元素</li><li><code>vertical-align</code> 对 <code>Flexbox</code> 中的子元素是没有效果的</li><li><code>float</code> 和 <code>clear</code> 属性对 <code>Flexbox</code> 中的子元素是没有效果的，也不会使子元素脱离文档流(但是对 <code>Flexbox</code> 是有效果的！)</li><li>多栏布局（<code>column-*</code>） 在 <code>Flexbox</code> 中也是失效的，就是说我们不能使用多栏布局在 <code>Flexbox</code> 排列其下的子元素</li><li><code>Flexbox</code> 下的子元素不会继承父级容器的宽</li></ul>]]></content>
      
      
      <categories>
          
          <category> FE Summary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>移动端前端适配方案总结</title>
      <link href="218.html"/>
      <url>218.html</url>
      
        <content type="html"><![CDATA[<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><p>在介绍各方案之前，先有必要了解一些必备的名词。</p><h3 id="px"><a href="#px" class="headerlink" title="px"></a>px</h3><p>全称 <code>pixel</code>，像素。一个像素就是计算机屏幕所能显示一种特定颜色的最小区域。屏幕上显示数据最基本的点，不是长度单位。 如果点很小，那画面就清晰，我们称它为“分辨率高”，反之，就是“分辨率低”。</p><h3 id="ppi"><a href="#ppi" class="headerlink" title="ppi"></a>ppi</h3><p>全称 <code>Pixels Per Inch</code>，屏幕像素密度。单位是 <code>dpi</code>，表示的是每英寸所拥有的像素(<code>Pixel</code>)数目。 越大屏幕越高清。</p><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><p>屏幕分辨率确定计算机屏幕上显示多少信息的设置，以水平和垂直像素来衡量，iphone5 屏幕上垂直有 1136 个物理像素，水平有 640 个物理像素。<span class="exturl" data-url="aHR0cHM6Ly93d3cuc3Zlbi5kZS9kcGkv">查询设备的分辨率及 ppi<i class="fa fa-external-link-alt"></i></span></p><h3 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h3><p>相对长度单位。相对于根元素(即 <code>html</code> 元素)的 <code>font-size</code> 计算值的倍数。</p><h3 id="em"><a href="#em" class="headerlink" title="em"></a>em</h3><p>相对长度单位。在 <code>font-size</code> 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 <code>width</code>。</p><h3 id="vw，vh"><a href="#vw，vh" class="headerlink" title="vw，vh"></a>vw，vh</h3><p>视窗宽度/高度的 <code>1%</code></p><h3 id="物理像素（设备像素）"><a href="#物理像素（设备像素）" class="headerlink" title="物理像素（设备像素）"></a>物理像素（设备像素）</h3><p>设备屏幕上的实际像素。如 <code>iphone6</code> 宽为 <code>750</code>。</p><h3 id="设备独立像素（逻辑像素-css-像素）"><a href="#设备独立像素（逻辑像素-css-像素）" class="headerlink" title="设备独立像素（逻辑像素/css 像素）"></a>设备独立像素（逻辑像素/css 像素）</h3><p>设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: <code>css</code> 像素)，然后由相关系统转换为物理像素。如 <code>iphone6</code> 为 <code>375×667</code>。</p><h3 id="设备像素比-device-pixel-ratio-屏幕分辩比-dpr"><a href="#设备像素比-device-pixel-ratio-屏幕分辩比-dpr" class="headerlink" title="设备像素比(device pixel ratio/屏幕分辩比/dpr)"></a>设备像素比(device pixel ratio/屏幕分辩比/dpr)</h3><p><code>设备像素比 = 物理像素 / 设备独立像素</code></p><p>在某一方向上，<code>x</code> 方向或者 <code>y</code> 方向。在控制台通过 <code>window.devicePixelRatio</code> 可得。</p><p>所以 <code>iphone6</code> 的 <code>DPR</code> 为 2。</p><h3 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h3><p><code>scale</code> 是屏幕拉伸比。也就是视口上的 <code>initial-scale</code> , <code>maximum-sacle</code> 等属性。</p><h3 id="视口（viewport）"><a href="#视口（viewport）" class="headerlink" title="视口（viewport）"></a>视口（viewport）</h3><ul><li><p>布局视口：网页在开始设计时候的 <code>dom</code> 宽度（比如 <code>960px</code>）</p></li><li><p>可视视口：整个屏幕的视口（比如 <code>iphone6</code> <code>375px</code>）</p></li><li><p>完美视口：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;initial-scale=1.0,width=device-width,user-scalable=0,maximum-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">  width：设置布局视口的宽 </span></span><br><span class="line"><span class="comment">  init-scale：设置页面的初始缩放程度 </span></span><br><span class="line"><span class="comment">  minimum-scale：设置了页面最小缩放程度</span></span><br><span class="line"><span class="comment">  maximum-scale：设置了页面最大缩放程度 </span></span><br><span class="line"><span class="comment">  user-scalable：是否允许用户对页面进行缩放操作</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="目前主流的自适应布局解决方案"><a href="#目前主流的自适应布局解决方案" class="headerlink" title="目前主流的自适应布局解决方案"></a>目前主流的自适应布局解决方案</h2><h3 id="响应式（Responsive-web-design"><a href="#响应式（Responsive-web-design" class="headerlink" title="响应式（Responsive web design)"></a>响应式（Responsive web design)</h3><p>通过媒体查询根据不同的屏幕分辨率来进行适配。</p><p>优点:</p><ul><li><code>media query</code> 可以做到设备像素比的判断，方法简单，成本低，特别是对移动和 <code>PC</code> 维护同一套代码的时候。目前像 <code>Bootstrap</code> 等框架使用这种方式布局。</li><li>图片便于修改，只需修改 <code>css</code> 文件。</li><li>调整屏幕宽度的时候不用刷新页面即可响应式展示。</li></ul><p>缺点:</p><ul><li>代码量比较大，维护不方便。</li><li>为了兼顾大屏幕或高清设备，会造成其他设备资源浪费，特别是加载图片资源。</li><li>为了兼顾移动端和 <code>PC</code> 端各自响应式的展示效果，难免会损失各自特有的交互方式。</li></ul><h3 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=width=device-width,initial-scale=1,maximum-scale=1, minimum-scale=1,user-scalable=no&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>流式布局需要用到<code>百分比</code>或者 <code>flex</code>，即宽度永远铺满页面宽度，但高度和其他单位仍然用 <code>px</code>。它的字体精度可以保持跟设备系统一致（<code>dpi</code>）。</p><h3 id="移动端-vw-rem-布局（主流）"><a href="#移动端-vw-rem-布局（主流）" class="headerlink" title="移动端 vw+rem 布局（主流）"></a>移动端 vw+rem 布局（主流）</h3><p>在没有 <code>vw</code> 的上古时代，我们通常这样来设置根字体 <code>font-size</code> 的大小：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">autoRootFontSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> width = <span class="built_in">Math</span>.min(screen.width, <span class="built_in">document</span>.documentElement.getBoundingClientRect().width);</span><br><span class="line">    <span class="built_in">document</span>.documentElement.style.fontSize = width &gt; <span class="number">600</span> ? <span class="string">&#x27;16px&#x27;</span> : (width / <span class="number">750</span>) * <span class="number">32</span> + <span class="string">&#x27;px&#x27;</span>; <span class="comment">//只适配移动端，且默认根字体为 32px，默认设计稿宽度 750px</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, autoRootFontSize);</span><br><span class="line">  autoRootFontSize();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>通过屏幕尺寸发生变化就获取屏幕宽度的方式，动态获取计算根字体的大小。</p><p>如果支持 <code>css vw</code>，则 <code>1vw</code> 本质即等于上文中 <code>width/100</code>。则换算过来为 <code>fontSize = (100vw/750) * 32</code>，且不需要运行 <code>js</code> 及监听，直接设置 <code>css</code> 为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="built_in">calc</span>((<span class="number">100vw</span> / <span class="number">750</span>) * <span class="number">32</span>);</span><br><span class="line">&#125; <span class="comment">/* 以iphone6 750的设计稿为准 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 其他元素用rem作为单位 */</span></span><br></pre></td></tr></table></figure><p>然后启用 <code>postcss</code> 的 <code>postcss-pxtorem</code> 将其他元素的 <code>px</code> 转为 <code>rem</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    autoprefixer: &#123;&#125;,</span><br><span class="line">    <span class="string">&#x27;postcss-pxtorem&#x27;</span>: &#123;</span><br><span class="line">      rootValue: <span class="number">32</span>,</span><br><span class="line">      propList: [<span class="string">&#x27;*&#x27;</span>],</span><br><span class="line">      minPixelValue: <span class="number">3</span>,</span><br><span class="line">      mediaQuery: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中 <code>rootValue</code> 为默认的根字体尺寸，通过 <code>pxtorem</code> 确定了<strong>其他元素尺寸</strong>与<strong>根元素尺寸</strong>固定的比例对应关系。</p><h3 id="scale-伸缩布局"><a href="#scale-伸缩布局" class="headerlink" title="scale 伸缩布局"></a>scale 伸缩布局</h3><p>视觉稿、页面宽度、<code>viewport width</code> 使用统一宽度，利用浏览器自身缩放完成适配。页面样式（包括图像元素）完全按照视觉稿的尺寸，使用定值单位 （<code>px、em</code>）即可完成。</p><h4 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h4><p>通过 <code>js</code> 更改 <code>viewport</code> 的 <code>initial-scale</code>。</p><h4 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h4><p>写死 <code>viewport</code> 的宽度.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=360, user-scalable=no&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>优点:</p><ul><li>开发简单：缩放交给浏览器，完全按视觉稿切图。</li><li>还原精准：绝对等比例缩放，可以精准还原视觉稿（不考虑清晰度的情况下）。</li><li>测试方便：在 <code>PC</code> 端即可完成大部分测试，手机端只需酌情调整一些细节（比如图标、字体混合排列时，因为字体不同造成的对齐问题）。</li></ul><p>缺点:</p><ul><li>像素丢失：对于一些分辨率较低的手机，可能设备像素还未达到指定的 <code>viewport</code> 宽度，此时屏幕的渲染可能就不准确了。比较常见的是边框“消失”了，不过随着手机硬件的更新，这个问题会越来越少的。</li><li>缩放失效：某些安卓机不能正常的根据 <code>meta</code> 标签中 <code>width</code> 的值来缩放 <code>viewport</code>，需要配合 <code>initial-scale</code>。</li><li>文本折行：存在于缩放失效的机型中，某些手机为了便于文本的阅读，在文本到达 <code>viewport</code> 边缘（非元素容器的边缘）时即进行折行，而当 <code>viewport</code> 宽度被修正后，浏览器并没有正确的重绘，所以就发现文本没有占满整行。一些常用的段落性文本标签会存在该问题。</li><li>不能开启 <code>gpu raster</code> 硬件加速：不能显式设置 <code>minimum-scale=1.0</code>，否则就达不到效果。而这个值是 <code>chromium37</code> 以上的 <code>webview</code> 触发 <code>gpu raster</code> 的一个条件，所以用这种方法就没法利用 <code>gpu raster</code> 硬件加速。</li></ul><p>注：</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="PX-适配"><a href="#PX-适配" class="headerlink" title="PX 适配"></a>PX 适配</h3><p>在新闻，社区等可阅读内容较多的场景直接使用 <code>px</code> 单位可以营造更好地体验。<code>px</code> 方案可以让大屏幕手机展示出更多的内容，更符合人们的阅读习惯。就无需 <code>rem</code> 来等比缩放。</p><ul><li>新闻，社区等可阅读内容较多的场景：<code>px+flex+百分比</code></li><li>对视觉组件种类较多，视觉设计对元素位置的相对关系依赖较强的移动端页面：<code>vw + rem</code></li></ul><h3 id="retina-下图片高清方案"><a href="#retina-下图片高清方案" class="headerlink" title="retina 下图片高清方案"></a>retina 下图片高清方案</h3><ol><li>两倍图片(<code>@2x</code>)，然后图片容器缩小 <code>50%</code>(方便但会造成资源浪费)。</li><li>不同的 <code>dpr</code> 下，加载不同的尺寸的图片。</li></ol><h3 id="retina-下-1px-解决方案"><a href="#retina-下-1px-解决方案" class="headerlink" title="retina 下 1px 解决方案"></a>retina 下 1px 解决方案</h3><p>对于一条 1px 宽的直线，它们在屏幕上的物理尺寸是相同的，不同的其实是屏幕上最小的物理显示单元，即物理像素。所以对于一条直线，<code>iphone6</code> 它能显示的最小宽度用 <code>css</code> 来表示，理论上说是 0.5px。</p><p>所以，设计师想要的 retina 下 <code>border: 1px;</code>，其实就是 1 物理像素宽，对于 css 而言，可以认为是 <code>border: 0.5px;</code>，这是 retina 下(<code>dpr=2</code>)下能显示的最小单位。</p><h4 id="元素-scale（方便但圆角等无法用）"><a href="#元素-scale（方便但圆角等无法用）" class="headerlink" title="元素 scale（方便但圆角等无法用）"></a>元素 <code>scale</code>（方便但圆角等无法用）</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.scale</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.scale</span>:after &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span><br><span class="line">  -webkit-<span class="attribute">transform-origin</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断添加-class"><a href="#判断添加-class" class="headerlink" title="判断添加 class"></a>判断添加 class</h4><p><code>js</code> 来判断当前浏览器是否支持 <code>border</code> 的 0.5px，如果支持就会在 <code>HTML</code> 上添加一个 <code>class</code> 名 <code>hairlines</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.devicePixelRatio &amp;&amp; devicePixelRatio &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> testElem = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  testElem.style.border = <span class="string">&#x27;.5px solid transparent&#x27;</span>;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(testElem);</span><br><span class="line">  <span class="keyword">if</span> (testElem.offsetHeight == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">&#x27;html&#x27;</span>).classList.add(<span class="string">&#x27;hairlines&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.body.removeChild(testElem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#bbb</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.hairlines</span> <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">0.5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：3 倍屏下，不是 0.3333px？在 Chrome 上模拟 iPhone 8Plus，小于 0.46px 时无法显示。</p><h4 id="设置-viewport-的-scale-值（不推荐）"><a href="#设置-viewport-的-scale-值（不推荐）" class="headerlink" title="设置 viewport 的 scale 值（不推荐）"></a>设置 viewport 的 scale 值（不推荐）</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> viewport = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;meta[name=viewport]&#x27;</span>);</span><br><span class="line"><span class="comment">//下面是根据设备像素设置viewport</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.devicePixelRatio == <span class="number">1</span>) &#123;</span><br><span class="line">  viewport.setAttribute(<span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.devicePixelRatio == <span class="number">2</span>) &#123;</span><br><span class="line">  viewport.setAttribute(<span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.devicePixelRatio == <span class="number">3</span>) &#123;</span><br><span class="line">  viewport.setAttribute(<span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为涉及到所有的尺寸都要调整，且其他第三方组件不一定适配。</p><h4 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h4><ul><li>使用边框图片</li><li>使用 <code>box-shadow</code> 实现： <code>box-shadow: inset 0px -1px 1px -1px #d4d6d7</code>;</li></ul>]]></content>
      
      
      <categories>
          
          <category> FE Summary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>css居中完整版</title>
      <link href="208.html"/>
      <url>208.html</url>
      
        <content type="html"><![CDATA[<p>是时候对 <code>css</code> 居中的各种方式来波总结了！下面是一提到居中就应该联想到的关键属性：</p><h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center; <span class="comment">/* 水平居中 */</span></span><br><span class="line">  <span class="attribute">align-items</span>: center; <span class="comment">/* 垂直居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要固定居中元素的宽高。</p><h3 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  justify-self: center; <span class="comment">/* 水平居中 */</span></span><br><span class="line">  <span class="attribute">align-self</span>: center; <span class="comment">/* 垂直居中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要固定居中元素的宽高。</p><h3 id="absolute-transform"><a href="#absolute-transform" class="headerlink" title="absolute + transform"></a>absolute + transform</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要固定居中元素的宽高。</p><h3 id="absolute-calc"><a href="#absolute-calc" class="headerlink" title="absolute + calc"></a>absolute + calc</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">50px</span>);</span><br><span class="line">  <span class="attribute">top</span>: <span class="built_in">calc</span>(<span class="number">50%</span> - <span class="number">50px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要固定居中元素的宽高。</p><h3 id="absolute-负-margin"><a href="#absolute-负-margin" class="headerlink" title="absolute + 负 margin"></a>absolute + 负 margin</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要固定居中元素的宽高。</p><h3 id="absolute-margin-auto"><a href="#absolute-margin-auto" class="headerlink" title="absolute + margin: auto"></a>absolute + margin: auto</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要固定居中元素的宽高。</p><h3 id="writing-mode"><a href="#writing-mode" class="headerlink" title="writing-mode"></a>writing-mode</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  writing-mode: vertical-lr;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: auto;</span><br><span class="line">  writing-mode: horizontal-tb;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">text-align</span>: left; <span class="comment">/* 重置文字位置 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要修改 DOM 结构（为了居中元素，需要嵌套两层父元素）。不需要固定居中元素的宽高。</p><h2 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h2><h3 id="行内元素-行内块级元素特有"><a href="#行内元素-行内块级元素特有" class="headerlink" title="行内元素/行内块级元素特有"></a>行内元素/行内块级元素特有</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block; <span class="comment">/* 或 display: inline; */</span></span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="margin-auto"><a href="#margin-auto" class="headerlink" title="margin: auto"></a>margin: auto</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要固定居中元素的宽。</p><h3 id="text-align-inline-block"><a href="#text-align-inline-block" class="headerlink" title="text-align + inline-block"></a>text-align + inline-block</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">text-align</span>: left; <span class="comment">/* 重置文字位置（如果需要） */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的 <code>text-align: center;</code> 会使文本居中，但是对块级元素无效，如果将元素设置为 <code>inline-block</code>，该元素就会被当做文本对待，从而实现元素居中。</p><p>不需要固定居中元素的宽。</p><h3 id="fit-content-margin"><a href="#fit-content-margin" class="headerlink" title="fit-content + margin"></a>fit-content + margin</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: fit-content;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会使元素的宽度改变（同内容宽度）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: fit-content;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使子元素是浮动元素也适用。</p><h2 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h2><h3 id="table-cell-vertical-align"><a href="#table-cell-vertical-align" class="headerlink" title="table-cell + vertical-align"></a>table-cell + vertical-align</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要固定居中元素的高。</p><h3 id="inline-block-line-height"><a href="#inline-block-line-height" class="headerlink" title="inline-block + line-height"></a>inline-block + line-height</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素的 <code>height</code> 和 <code>line-height</code> 相同的时候，会使其文本内容垂直居中。因此该方案利用了这一特点，不过文本内容虽然垂直居中了，但是元素并没有，因此再将元素设置为 <code>inline-block</code>，这样元素就会被当做文本对待了。同时由于具有了 <code>inline</code> 属性，<code>vertical-align: middle;</code> 也就可以生效了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: initial; <span class="comment">/* 重置 */</span></span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要知道其父元素高度,不需要固定居中元素的高。</p><h3 id="inline-block-vertical-align"><a href="#inline-block-vertical-align" class="headerlink" title="inline-block + vertical-align"></a>inline-block + vertical-align</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.outer</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在居中元素的父元素上，使用一个伪元素，将这个伪元素设置为 <code>inline-block</code> 后，就好像它原来就是一个真正的 DOM 元素，存在于页面上。然后再将居中元素设置为 <code>inline-block</code>，根据 <code>inline-block</code> 的特性（多个相邻的 <code>inline-block</code> 元素会横向并排显示），居中元素会和伪元素横向并排显示。并且设置 <code>vertical-align: middle;</code> 后，它们会互相垂直对齐，最后将伪元素高度撑起来 <code>height: 100%;</code>，居中元素会对齐伪元素，从而实现了垂直居中。</p><p>不需要固定居中元素的高。</p>]]></content>
      
      
      <categories>
          
          <category> FE Summary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>flex布局总结</title>
      <link href="203.html"/>
      <url>203.html</url>
      
        <content type="html"><![CDATA[<p>布局的传统解决方案，基于盒状模型，依赖 <code>display 属性 + position 属性 + float 属性</code>。</p><h4 id="什么是-flex-布局"><a href="#什么是-flex-布局" class="headerlink" title="什么是 flex 布局"></a>什么是 flex 布局</h4><p><code>Flex</code>（<code>Flexible Box</code>），即为”弹性布局”。设为 <code>Flex</code> 布局以后，子元素的 <code>float</code>、<code>clear</code> 和 <code>vertical-align</code> 属性将失效。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex; <span class="comment">/* inline元素 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h4><p>以下属性设置在 <code>flex</code> 布局中的父元素（即设有 <code>display:flex</code> 的元素），用来控制内部子元素的行为。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: <span class="built_in">row</span>(默) | row-reverse | column | column-reverse;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: <span class="built_in">nowrap</span>(默) | wrap | wrap-reverse;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; &lt;flex-wrap&gt;;</span><br><span class="line">  <span class="attribute">justify-content</span>: <span class="built_in">flex-start</span>(默) | flex-end | center | space-between | space-around;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | <span class="built_in">stretch</span>(默);</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | <span class="built_in">stretch</span>(默);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>flex-direction</code>: 子元素的排列方向。<ul><li><code>row</code>: 水平方向，起点在左端。</li><li><code>row-reverse</code>: 水平方向，起点在右端。</li><li><code>column</code>: 垂直方向，起点在上沿。</li><li><code>column-reverse</code>: 垂直方向，起点在下沿。</li></ul></li><li><code>flex-wrap</code>: 如果子元素一条线排不下，如何换行。<ul><li><code>nowrap</code>: 不换行。</li><li><code>wrap</code>: 换行，第一行在上方。</li><li><code>wrap-reverse</code>: 换行，第一行在下方。</li></ul></li><li><code>flex-flow</code>: <code>flex-direction</code> 和 <code>flex-wrap</code> 的简写形式。</li><li><code>justify-content</code>: 子元素在一条横线上的对齐方式。<ul><li><code>flex-start</code>: 左对齐。</li><li><code>flex-end</code>: 右对齐。</li><li><code>center</code>: 居中。</li><li><code>space-between</code>: 两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>: 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul></li><li><code>align-items</code>: 每个子元素在垂直方向上的对齐方式。<ul><li><code>flex-start</code>: 对齐顶部。</li><li><code>flex-end</code>: 对齐底部。</li><li><code>center</code>: 垂直居中。</li><li><code>baseline</code>: 子元素的第一行文字的基线对齐。</li><li><code>stretch</code>: 如果子元素未设置高度或设为 <code>auto</code>，将占满整个容器的高度。</li></ul></li><li><code>align-content</code>: 定义数量超过一行的子元素的垂直对齐方式。<ul><li><code>flex-start</code>: 对齐顶部。</li><li><code>flex-end</code>: 对齐底部。</li><li><code>center</code>: 垂直居中。</li><li><code>space-between</code>: 垂直两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>: 垂直两端对齐，每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>: 如果子元素未设置高度或设为 <code>auto</code>，将占满整个容器的高度。</li></ul></li></ul><h4 id="容器内子元素的属性"><a href="#容器内子元素的属性" class="headerlink" title="容器内子元素的属性"></a>容器内子元素的属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;; <span class="comment">/* 定义子元素的排列顺序。数值越小，排列越靠前，默认为0。 */</span></span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* 定义子元素的放大比例，默认为0，即如果存在剩余空间，也不放大。 */</span></span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* 定义了子元素的缩小比例，默认为1，即如果空间不足，该项目将缩小。 */</span></span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* 定义了子元素所占固定空间（如100px），默认auto */</span></span><br><span class="line">  <span class="attribute">flex</span>: &lt;flex-grow&gt; &lt;flex-shrink（可选）&gt; &lt;flex-basis（可选）&gt; ]; <span class="comment">/* 快捷值：initial (0 1 auto)(默认), auto (1 1 auto), none (0 0 auto), 1 (1 1 0%), 0 (0 1 0%)*/</span></span><br><span class="line">  <span class="attribute">align-self</span>: auto（默） | flex-start | flex-end | center | baseline | stretch; <span class="comment">/* 该属性用来覆盖父元素统一的align-items属性，达到该子元素的个性化 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhhbmd4aW54dS5jb20vd29yZHByZXNzLzIwMjAvMTAvY3NzLWZsZXgtMC0xLW5vbmUv">flex:0 flex:1 flex:none flex:auto 应该在什么场景下使用<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> FE Css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）css画三角形等各类图标</title>
      <link href="196.html"/>
      <url>196.html</url>
      
        <content type="html"><![CDATA[<p><code>css3</code> 的属性 <code>transform</code>(转换) 用途很广泛，功能也很强大，为了熟悉它的各种转换方式(平移 <code>translate</code>，旋转 <code>rotate</code>，扭曲 <code>skew</code>，放缩 <code>scale</code>)，我做了一些平常常用的一些简单的图标。</p><p>这些图标很多是通过三角形来拼贴起来的，所以我们需要知道怎么样画三角形。</p><ol><li>我们要将该 <code>div</code> 的 <code>width</code> 和 <code>height</code> 都设置为 0，三角形是通过设置 <code>border</code> 来实现；</li><li>通过我们需要画成的三角形的目标分析，这个三角形的朝向(只针对规则的朝向：上、右、下、左、上左、上右、下右、下左，不规则的朝向可以通过旋转来实现)；</li><li>如果是上、右、下、左四种中的一种，将朝向的对面的 <code>border-color</code> 设置为我们需要的颜色，该朝向的这一边不设置 <code>border</code>，其它两边的 <code>border-color</code> 设置为 <code>transparent</code>；</li><li>如果是上左、上右、下右、下左中的一种，以上右为例，设置相关的两边：上和右的 <code>border-color</code> 设置成我们想要的颜色，其它两边的 <code>border-width</code> 设置成 <code>transparent</code>。</li><li><code>border-width</code> 的值就是底边长和高。</li></ol><h2 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h2><p><img data-src="http://cdn.flqin.com/p196-1.jpg" alt="三角形1"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bottom</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">2em</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">1.8em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">1.8em</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="http://cdn.flqin.com/p196-2.jpg" alt="三角形2"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bottomLeft</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">2em</span> <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: transparent transparent <span class="number">#000</span> <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="http://cdn.flqin.com/p196-3.jpg" alt="三角形3"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bottomLeftRotate</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">2em</span> <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: transparent transparent <span class="number">#000</span> <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">60deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向上"><a href="#向上" class="headerlink" title="向上"></a>向上</h2><p><img data-src="http://cdn.flqin.com/p196-4.png" alt="向上"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.top</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">0.9em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">0.9em</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">0.9em</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.top</span>:after &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>; <span class="comment">/*针对before,after必须加上*/</span></span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0.7em</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">0.45em</span>; <span class="comment">/*宽度的一半，结合 left: 50%; 使用*/</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.9em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1.3em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向右"><a href="#向右" class="headerlink" title="向右"></a>向右</h2><p><img data-src="http://cdn.flqin.com/p196-5.png" alt="向右"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1.3em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.9em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>:after &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">1.1em</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">0.9em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">0.9em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">0.9em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">0.9em</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向下"><a href="#向下" class="headerlink" title="向下"></a>向下</h2><p><img data-src="http://cdn.flqin.com/p196-6.png" alt="向下"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.bottom</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.9em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1.3em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.bottom</span>:after &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">1.1em</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">0.9em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">0.9em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">0.9em</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">0.9em</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向左"><a href="#向左" class="headerlink" title="向左"></a>向左</h2><p><img data-src="http://cdn.flqin.com/p196-7.png" alt="向左"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">0.9em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">0.9em</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">0.9em</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>:after &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>; <span class="comment">/*在绝对定位中，top: 0; bottom: 0; margin: auto; 结合使用能竖直居中*/</span></span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0.7em</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1.3em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.9em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正确"><a href="#正确" class="headerlink" title="正确"></a>正确</h2><p><img data-src="http://cdn.flqin.com/p196-8.png" alt="正确"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.true</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1.2em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.3em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">60deg</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>: right center;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.15em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.true</span>:after &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0.1em</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">0.85em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.3em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">60deg</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>: right center;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.15em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p><img data-src="http://cdn.flqin.com/p196-9.png" alt="错误"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.false</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.3em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">45deg</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.15em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.false</span>:after &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.3em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">90deg</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.15em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h2><p><img data-src="http://cdn.flqin.com/p196-10.png" alt="菜单"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.menu</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.3em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu</span>:before &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1.2em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.15em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu</span>:after &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1.2em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.9em</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">0.15em</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid none;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="菜单-2"><a href="#菜单-2" class="headerlink" title="菜单 2"></a>菜单 2</h2><p><img data-src="http://cdn.flqin.com/p196-11.png" alt="菜单 2"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.menu2</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.5em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.5em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu2</span>:before &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">0.75em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.5em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.5em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.menu2</span>:after &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0.75em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.5em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.5em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><img data-src="http://cdn.flqin.com/p196-12.png" alt="下载"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.download</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.8em</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">0.3em</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: none solid solid;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.download</span>:before &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0.7em</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.3em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.download</span>:after &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0.2em</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">0.6em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">0.6em</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">0.6em</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p><img data-src="http://cdn.flqin.com/p196-13.png" alt="上传"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.upload</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.8em</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">0.3em</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: none solid solid;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.upload</span>:before &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0.2em</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.3em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.upload</span>:after &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">1.1em</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">0.6em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">0.6em</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">0.6em</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p><img data-src="http://cdn.flqin.com/p196-14.png" alt="视频"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.video</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1.5em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1.2em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.3em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.video</span>:after &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">1.4em</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">0.7em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">0.7em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">0.6em</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">0.7em</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="语音"><a href="#语音" class="headerlink" title="语音"></a>语音</h2><p><img data-src="http://cdn.flqin.com/p196-15.png" alt="语音"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.voice</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1.4em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">0.2em</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: none none solid;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.voice</span>:before &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0.05em</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.8em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1.3em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.4em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.voice</span>:after &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: -<span class="number">0.6em</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">0.6em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">0.4em</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">0.6em</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h2><p><img data-src="http://cdn.flqin.com/p196-16.png" alt="播放"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.play</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0.2em</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.play</span>:after &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: auto;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: auto;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">0.3em</span>; <span class="comment">/*没有让其左右居中，因为看起来右边更空一些*/</span></span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">0.6em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">0.6em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">0.9em</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="暂停"><a href="#暂停" class="headerlink" title="暂停"></a>暂停</h2><p><img data-src="http://cdn.flqin.com/p196-17.png" alt="暂停"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.pause</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0.2em</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pause</span>:before &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: auto;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: auto;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">0.35em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.2em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.9em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pause</span>:after &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: auto;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: auto;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">0.15em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.2em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.9em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上一首-集"><a href="#上一首-集" class="headerlink" title="上一首(集)"></a>上一首(集)</h2><p><img data-src="http://cdn.flqin.com/p196-18.png" alt="上一首(集)"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.previous</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0.2em</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.previous</span>:before &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: auto;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: auto;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">0.65em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">0.45em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">0.45em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">0.6em</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.previous</span>:after &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: auto;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: auto;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">0.2em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">0.45em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">0.45em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">0.6em</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下一首-集"><a href="#下一首-集" class="headerlink" title="下一首(集)"></a>下一首(集)</h2><p><img data-src="http://cdn.flqin.com/p196-19.png" alt="下一首(集)"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.next</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0.2em</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.next</span>:before &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: auto;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: auto;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">0.4em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">0.45em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">0.45em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">0.6em</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.next</span>:after &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: auto;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: auto;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">0.05em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">0.45em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">0.45em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">0.6em</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><p><img data-src="http://cdn.flqin.com/p196-20.png" alt="停止"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.stop</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0.2em</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.stop</span>:after &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.9em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.9em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="当前位置"><a href="#当前位置" class="headerlink" title="当前位置"></a>当前位置</h2><p><img data-src="http://cdn.flqin.com/p196-21.png" alt="当前位置"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.position</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.6em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.6em</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0.4em</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.position</span>:after &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0.55em</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">0.4em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1em</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">0.7em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">0.7em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top-left-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">border-top-right-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pc"><a href="#pc" class="headerlink" title="pc"></a>pc</h2><p><img data-src="http://cdn.flqin.com/p196-22.png" alt="pc"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.pc</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1.4em</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">0.2em</span> <span class="number">0.2em</span> <span class="number">0.3em</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.2em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#efefef</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pc</span>:before &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">1.2em</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.6em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.4em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.pc</span>:after &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">1.6em</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1.6em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.2em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="phone"><a href="#phone" class="headerlink" title="phone"></a>phone</h2><p><img data-src="http://cdn.flqin.com/p196-23.png" alt="phone"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.phone</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1.4em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#efefef</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">0.3em</span> <span class="number">0.2em</span> <span class="number">0.5em</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.15em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.phone</span>:after &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: -<span class="number">0.4em</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.5em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.3em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.3em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p><img data-src="http://cdn.flqin.com/p196-24.png" alt="搜索"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.search</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.3em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-top-right-radius</span>: <span class="number">0.15em</span>;</span><br><span class="line">  <span class="attribute">border-bottom-right-radius</span>: <span class="number">0.15em</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">40deg</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>: right center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.search</span>:before &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">1.3em</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: -<span class="number">0.6em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0.3em</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五角星"><a href="#五角星" class="headerlink" title="五角星"></a>五角星</h2><p><img data-src="http://cdn.flqin.com/p196-25.png" alt="五角星"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.star</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">0.7em</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">1em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">1em</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.star</span>:before &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">0.7em</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">0.7em</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">1em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">1em</span> solid transparent;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">72deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.star</span>:after &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">0.7em</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">0.7em</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">1em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">1em</span> solid transparent;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">72deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p><img data-src="http://cdn.flqin.com/p196-26.png" alt="电子邮件"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.email</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">0.7em</span> <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: transparent transparent <span class="number">#000</span> <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.email</span>:before &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">0.7em</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">180deg</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>: left center;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">0.7em</span> <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: transparent transparent <span class="number">#000</span> <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.email</span>:after &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">0.7em</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">0.9em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">0.6em</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">0.9em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">0.9em</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="眼睛"><a href="#眼睛" class="headerlink" title="眼睛"></a>眼睛</h2><p><img data-src="http://cdn.flqin.com/p196-27.png" alt="眼睛"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.eye</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1.2em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.eye</span>:before &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.8em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.8em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.eye</span>:after &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.4em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.4em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="未锁"><a href="#未锁" class="headerlink" title="未锁"></a>未锁</h2><p><img data-src="http://cdn.flqin.com/p196-28.png" alt="未锁"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.unlock</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1.6em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1.4em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.unlock</span>:before &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">0.4em</span>;</span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">0.4em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.6em</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">0.2em</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid solid none;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.5em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.unlock</span>:after &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0.2em</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">0.15em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.3em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.5em</span>;</span><br><span class="line">  <span class="attribute">border-top-left-radius</span>: <span class="number">0.25em</span>;</span><br><span class="line">  <span class="attribute">border-top-right-radius</span>: <span class="number">0.25em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="杯子"><a href="#杯子" class="headerlink" title="杯子"></a>杯子</h2><p><img data-src="http://cdn.flqin.com/p196-29.png" alt="杯子"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.cup</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1.3em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">0.2em</span> <span class="number">0.2em</span> <span class="number">1.2em</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#efefef</span>;</span><br><span class="line">  <span class="attribute">border-bottom-left-radius</span>: <span class="number">0.3em</span>;</span><br><span class="line">  <span class="attribute">border-bottom-right-radius</span>: <span class="number">0.3em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cup</span>:before &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0.1em</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">0.7em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.7em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1.4em</span>;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">0.2em</span>;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-top-left-radius</span>: <span class="number">0.3em</span>;</span><br><span class="line">  <span class="attribute">border-bottom-left-radius</span>: <span class="number">0.3em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="心"><a href="#心" class="headerlink" title="心"></a>心</h2><p><img data-src="http://cdn.flqin.com/p196-30.png" alt="心"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.heart</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1.4em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-top-left-radius</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border-top-right-radius</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">45deg</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>: center bottom;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.heart</span>:after &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">0.7em</span>;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">0.7em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1.4em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">2em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-top-left-radius</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border-top-right-radius</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">90deg</span>);</span><br><span class="line">  <span class="attribute">transform-origin</span>: center bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主页"><a href="#主页" class="headerlink" title="主页"></a>主页</h2><p><img data-src="http://cdn.flqin.com/p196-31.png" alt="主页"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.home</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1.4em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.home</span>:before &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">0.7em</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">1em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">1em</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">0.8em</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.home</span>:after &#123;</span><br><span class="line">  z-index: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.3em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.5em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h2><p><img data-src="http://cdn.flqin.com/p196-32.png" alt="密码"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.password</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1.8em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1.4em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">0.2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.password</span>:before &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">0.6em</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">0.5em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">0.2em</span> solid <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.password</span>:after &#123;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0.2em</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">0.15em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.3em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.5em</span>;</span><br><span class="line">  <span class="attribute">border-top-left-radius</span>: <span class="number">0.25em</span>;</span><br><span class="line">  <span class="attribute">border-top-right-radius</span>: <span class="number">0.25em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用户-账号"><a href="#用户-账号" class="headerlink" title="用户(账号)"></a>用户(账号)</h2><p><img data-src="http://cdn.flqin.com/p196-33.png" alt="用户(账号)"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.user</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0.9em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0.9em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.user</span>:after &#123;</span><br><span class="line">  content: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">0.9em</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1.8em</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">1em</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">border-top-left-radius</span>: <span class="number">0.9em</span>;</span><br><span class="line">  <span class="attribute">border-top-right-radius</span>: <span class="number">0.9em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="菜单-3"><a href="#菜单-3" class="headerlink" title="菜单 3"></a>菜单 3</h2><p><img data-src="http://cdn.flqin.com/p196-34.png" alt="菜单 3"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#menu</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">10px</span> solid; <span class="comment">/*没有设置颜色值，将同文本颜色一样*/</span></span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">10px</span> solid;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: currentColor; <span class="comment">/*颜色关键字，将同文本颜色一致*/</span></span><br><span class="line">  <span class="attribute">background-clip</span>: content-box; <span class="comment">/*背景将绘制在内容方框内*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FE Css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）CSS实现单行、多行文本溢出显示省略号</title>
      <link href="192.html"/>
      <url>192.html</url>
      
        <content type="html"><![CDATA[<h2 id="单行文本的溢出"><a href="#单行文本的溢出" class="headerlink" title="单行文本的溢出"></a>单行文本的溢出</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line"><span class="attribute">white-space</span>: nowrap;</span><br></pre></td></tr></table></figure><p><img data-src="http://cdn.flqin.com/p192-1.png" alt="单行文本的溢出"></p><h2 id="多行文本的溢出"><a href="#多行文本的溢出" class="headerlink" title="多行文本的溢出"></a>多行文本的溢出</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  -webkit-box-orient: vertical;</span><br><span class="line">  -webkit-line-clamp: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="http://cdn.flqin.com/p192-2.png" alt="方法一"></p><ul><li><code>display: -webkit-box;</code> 必须结合的属性，将对象作为弹性伸缩盒子模型显示.</li><li><code>-webkit-box-orient</code> 必须结合的属性，设置或检索伸缩盒对象的子元素的排列方式.</li><li><code>-webkit-line-clamp</code> 用来限制在一个块元素显示的文本的行数。</li></ul><p>适用范围：因使用了 <code>WebKit</code> 的 <code>CSS</code> 扩展属性，该方法适用于 <code>WebKit</code> 浏览器及移动端。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">max-height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;...&#x27;</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to right, transparent, <span class="number">#fff</span> <span class="number">55%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img data-src="http://cdn.flqin.com/p192-3.png" alt="方法二"></p><ul><li>将 <code>height</code> 设置为 <code>line-height</code> 的整数倍，防止超出的文字露出。</li><li>给 <code>p::after</code> 添加渐变背景可避免文字只显示一半。</li><li>由于 <code>ie6-7</code> 不显示 <code>content</code> 内容，所以要添加标签兼容 <code>ie6-7</code>（如：<code>…</code>）；兼容 <code>ie8</code> 需要将 <code>::after</code> 替换成 <code>:after</code>。</li></ul><p>适用范围：该方法适用范围广，但文字未超出行的情况下也会出现省略号,可结合 <code>js</code> 优化该方法。</p>]]></content>
      
      
      <categories>
          
          <category> FE Css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）CSS选择器的权重与优先规则</title>
      <link href="189.html"/>
      <url>189.html</url>
      
        <content type="html"><![CDATA[<p>我们在使用 <code>CSS</code> 对网页元素定义样式时经常会遇到这种情况：要对一般元素应用一般样式，然后在更特殊的元素上覆盖它们。那么我们怎么样来保证我们所新定义的元素样式能覆盖目标元素上原有的样式呢？</p><p>在 <code>CSS</code> 中，会根据选择器的特殊性来决定所定义的样式规则的次序，具有更特殊选择器的规则优先于具有一般选择器的规则，如果两个规则的特殊性相同，那么后定义的规则优先。</p><p>那么，又怎么来计算选择器的特殊性呢？下面这张图介绍了特殊性的计算方法：</p><p><img data-src="http://cdn.flqin.com/p189-1.jpg" alt="选择器权值"></p><p>我们把特殊性分为 4 个等级，每个等级代表一类选择器，每个等级的值为其所代表的选择器的个数乘以这一等级的权值，最后把所有等级的值相加得出选择器的特殊值。</p><p>4 个等级的定义如下：</p><ul><li>第一等：代表内联样式，如：<code>style=””</code>，权值为 1000。</li><li>第二等：代表 <code>ID</code> 选择器，如：<code>#content</code>，权值为 100。</li><li>第三等：代表类，伪类和属性选择器，如： <code>.content</code>，权值为 10。</li><li>第四等：代表类型选择器和伪元素选择器，如： <code>div p</code>，权值为 1。</li></ul><p>例如上图为例，其中 <code>#NAV</code> 为二等选择器，<code>.ACTIVE</code> 为三等选择器，<code>UL</code>、<code>LI</code> 和 <code>A</code> 为四等选择器。则整个选择器表达式的特殊性的值为 <code>1_100+1_10+3\*1=113</code></p><p>下面是一些计算示例：</p><p><img data-src="http://cdn.flqin.com/p189-2.jpg" alt="计算示例"></p><p>注意：通用选择器（<code>*</code>），子选择器（<code>&gt;</code>）和相邻同胞选择器（<code>+</code>）并不在这四个等级中，所以他们的权值都为 <code>0</code>。</p><p>我们再来看一个具体的例子：假如有以下组样式规则，你能判断出 <code>HTML</code> 代码中的两个标题是什么颜色吗？</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#content</span> <span class="selector-tag">div</span><span class="selector-id">#main-content</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#content</span> <span class="selector-id">#main-content</span> &gt; <span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> <span class="selector-id">#content</span> <span class="selector-tag">div</span><span class="selector-attr">[id=<span class="string">&#x27;main-content&#x27;</span>]</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#main-content</span> <span class="selector-tag">div</span><span class="selector-class">.paragraph</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#main-content</span> <span class="selector-attr">[class=<span class="string">&#x27;paragraph&#x27;</span>]</span> <span class="selector-tag">h2</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-id">#main-content</span> <span class="selector-tag">div</span><span class="selector-class">.paragraph</span> <span class="selector-tag">h2</span><span class="selector-class">.first</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是 HTML 代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;main-content&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>CSS简介<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>CSS（Cascading Style Sheet，可译为“层叠样式表”或“级联样式表”）是一组格式设置规则，用于控制Web页面的外观。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;paragraph&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;first&quot;</span>&gt;</span>使用CSS布局的优点<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>1、表现和内容相分离 2、提高页面浏览速度 3、易于维护和改版 4、使用CSS布局更符合现在的W3C标准.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>判断出来了么？答案是：两个标题都是红色的！</p><p>让我们来一起算算六个样式规则各自的特殊性的值：</p><ul><li>第一个特殊性的值=<code>2_100+2_1=202</code></li><li>第二个特殊性的值=<code>2\*100+1=201</code></li><li>第三个特殊性的值=<code>1_100+1_10+3\*1=113</code></li><li>第四个特殊性的值=<code>1_100+1_10+2\*1=112</code></li><li>第五个特殊性的值=<code>1_100+1_10+1\*1=111</code></li><li>第六个特殊性的值=<code>1_100+2_10+3\*1=123</code></li></ul><p>清楚了吧，第一个样式规则以其 <code>202</code> 的高分一举夺得了本次样式选择器特殊性大赛的冠军，后面一些规则虽然看起来好像更复杂，但特殊性并不是拼谁的选择器表达式写得更长，<code>ID</code> 选择器才是王道！</p><p>理解选择器的特殊性很重要，特别是在修复 <code>bug</code> 的时候，因为你需要了解哪些规则优先及其原因。</p><p>如果你遇到了似乎没有起作用的 <code>CSS</code> 规则，很可能是出现了特殊性冲突。请在你的选择器中添加他的一个父元素的 <code>ID</code>，从而提高它的特殊性。如果这能解决问题，就说明样式表中其他地方很可能有更特殊的规则，它覆盖了你的规则。如果是这种情况，你可能需要检查代码，解决特殊性冲突，让代码尽可能简洁。</p>]]></content>
      
      
      <categories>
          
          <category> FE Css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）CSS3中:nth-child和:nth-of-type的区别深入理解</title>
      <link href="184.html"/>
      <url>184.html</url>
      
        <content type="html"><![CDATA[<p><code>:nth-child</code> 可以选择父元素下的字元素，<code>:nth-of-type</code> 也可以。但是它们到底有什么区别呢？</p><p>其实区别很简单：<code>:nth-of-type</code> 为什么要叫 <code>:nth-of-type</code>？因为它是以”<code>type</code>“来区分的。也就是说：<code>ele:nth-of-type(n)</code>是指父元素下第 <code>n</code> 个 <code>ele</code> 元素，</p><p>而 <code>ele:nth-child(n)</code> 是指父元素下第 <code>n</code> 个元素且这个元素为 <code>ele</code>，若不是，则选择失败。</p><p>eg:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>zero<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>one<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>two<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这个例子，<code>.demo li:nth-child(2)</code> 选择的是 <code>&lt;li&gt;one&lt;/li&gt;</code> 节点，而 <code>.demo li:nth-of-type(2)</code> 则选择的是 <code>&lt;li&gt;two&lt;/li&gt;</code> 节点。</p>]]></content>
      
      
      <categories>
          
          <category> FE Css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>css3 media媒体查询器用法总结</title>
      <link href="180.html"/>
      <url>180.html</url>
      
        <content type="html"><![CDATA[<p>随着响应式设计模型的诞生，Web 网站又要发生翻天腹地的改革浪潮，可能有些人会觉得在国内 IE6 用户居高不下的情况下，这些新的技术还不会广泛的蔓延下去，那你就错了，如今淘宝，凡客，携程等等公司都已经在大胆的尝试了这项技术，并完美的应用在了自己的网站上了。再不更新知识你就老了。我今天就总结一下响应式设计的核心 CSS 技术 Media(媒体查询器)的用法。</p><h2 id="准备工作-1：设置-Meta-标签"><a href="#准备工作-1：设置-Meta-标签" class="headerlink" title="准备工作 1：设置 Meta 标签"></a>准备工作 1：设置 Meta 标签</h2><p>首先我们在使用 Media 的时候需要先设置下面这段代码，来兼容移动设备的展示效果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码的几个参数解释：</p><ul><li><code>width = device-width</code>：宽度等于当前设备的宽度</li><li><code>initial-scale</code>：初始的缩放比例（默认设置为 1.0）</li><li><code>minimum-scale</code>：允许用户缩放到的最小比例（默认设置为 1.0）</li><li><code>maximum-scale</code>：允许用户缩放到的最大比例（默认设置为 1.0）</li><li><code>user-scalable</code>：用户是否可以手动缩放（默认设置为 no，因为我们不希望用户放大缩小页面）</li></ul><h2 id="准备工作-2：加载兼容文件-JS"><a href="#准备工作-2：加载兼容文件-JS" class="headerlink" title="准备工作 2：加载兼容文件 JS"></a>准备工作 2：加载兼容文件 JS</h2><p>因为 <code>IE8</code> 既不支持 <code>HTML5</code> 也不支持 <code>CSS3 Media</code>，所以我们需要加载两个 <code>JS</code> 文件，来保证我们的代码实现兼容效果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">  &lt;script src=&quot;https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">  &lt;script src=&quot;https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h2 id="准备工作-3：设置-IE-渲染方式默认为最高-这部分可以选择添加也可以不添加"><a href="#准备工作-3：设置-IE-渲染方式默认为最高-这部分可以选择添加也可以不添加" class="headerlink" title="准备工作 3：设置 IE 渲染方式默认为最高(这部分可以选择添加也可以不添加)"></a>准备工作 3：设置 IE 渲染方式默认为最高(这部分可以选择添加也可以不添加)</h2><p>现在有很多人的 IE 浏览器都升级到 IE9 以上了，所以这个时候就有又很多诡异的事情发生了，例如现在是 IE9 的浏览器，但是浏览器的文档模式却是 IE8。 为了防止这种情况，我们需要下面这段代码来让 IE 的文档模式永远都是最新的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>太给力了。 不过我最近又发现了一个更给力的写法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=Edge，chrome=1&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>怎么这段代码后面加了一个 <code>chrome=1</code>，这个 Google Chrome Frame（谷歌内嵌浏览器框架 GCF），如果有的用户电脑里面装了这个 chrome 的插件，就可以让电脑里面的 IE 不管是哪个版本的都可以使用 Webkit 引擎及 V8 引擎进行排版及运算，无比给力，不过如果用户没装这个插件，那这段代码就会让 IE 以最高的文档模式展现效果。这段代码我还是建议你们用上，不过不用也是可以的。</p><h2 id="进入-CSS3-Media-写法"><a href="#进入-CSS3-Media-写法" class="headerlink" title="进入 CSS3 Media 写法"></a>进入 CSS3 Media 写法</h2><p>我们先来看下下面这段代码，估计很多人在响应式的网站 CSS 很经常看到类似下面的这段代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">960px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个应该算是一个 media 的一个标准写法，上面这段 CSS 代码意思是：当页面小于 960px 的时候执行它下面的 CSS.这个应该没有太大疑问。</p><p>应该有人会发现上面这段代码里面有个 screen，他的意思是在告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体。但是目前我发现很多网站都会直接省略 screen,因为你的网站可能不需要考虑用户去打印时，你可以直接这样写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">960px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CSS2-Media-用法"><a href="#CSS2-Media-用法" class="headerlink" title="CSS2 Media 用法"></a>CSS2 Media 用法</h2><p>其实并不是只有 CSS3 才支持 Media 的用法，早在 CSS2 开始就已经支持 Media，具体用法，就是在 HTML 页面的 head 标签中插入如下的一段代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>上面其实是 CSS2 实现的衬线用法，那 CSS3 的 media 难道就只能支持上面这一个功能吗？答案当然不是，他还有很多用法。 例如我们想知道现在的移动设备是不是纵向放置的显示屏，可以这样写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen and (orientation:portrait)&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>我们把第一段的代码也用 CSS2 来实现，让它一样可以让页面宽度小于 960 的执行指定的样式文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">media</span>=<span class="string">&quot;screen and (max-width:960px)&quot;</span> <span class="attr">href</span>=<span class="string">&quot;style.css&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>既然 CSS2 可以实现 CSS 的这个效果为什么不用这个方法呢，很多人应该会问，但是上面这个方法，最大的弊端是他会增加页面 http 的请求次数，增加了页面负担，我们用 CSS3 把样式都写在一个文件里面才是最佳的方法。</p><h2 id="回归-CSS3-Media"><a href="#回归-CSS3-Media" class="headerlink" title="回归 CSS3 Media"></a>回归 CSS3 Media</h2><p>上面我们大概讲了下 CSS2 的媒体查询用法，现在我们重新回到 CSS3 的媒体查询，在第一段代码上面我用的是小于 960px 的尺寸的写法，那现在我们来实现等于 960px 尺寸的代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-device-width</span>: <span class="number">960px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是当浏览器尺寸大于 960px 时候的代码了：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">960px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: orange;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以混合使用上面的用法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">960px</span>) <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">1200px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: yellow;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的这段代码的意思是当页面宽度大于 960px 小于 1200px 的时候执行下面的 CSS。</p><h2 id="Media-所有参数汇总"><a href="#Media-所有参数汇总" class="headerlink" title="Media 所有参数汇总"></a>Media 所有参数汇总</h2><p>以上就是我们最常需要用到的媒体查询器的三个特性，大于，等于，小于的写法。媒体查询器的全部功能肯定不止这三个功能，下面是我总结的它的一些参数用法解释：</p><ul><li><code>width</code>:浏览器可视宽度。</li><li><code>height</code>:浏览器可视高度。</li><li><code>device-width</code>:设备屏幕的宽度。</li><li><code>device-height</code>:设备屏幕的高度。</li><li><code>orientation</code>:检测设备目前处于横向还是纵向状态。</li><li><code>aspect-ratio</code>:检测浏览器可视宽度和高度的比例。(例如：aspect-ratio:16/9)</li><li><code>device-aspect-ratio</code>:检测设备的宽度和高度的比例。</li><li><code>color</code>:检测颜色的位数。（例如：min-color:32 就会检测设备是否拥有 32 位颜色）</li><li><code>color-index</code>:检查设备颜色索引表中的颜色，他的值不能是负数。</li><li><code>monochrome</code>:检测单色楨缓冲区域中的每个像素的位数。（这个太高级，估计咱很少会用的到）</li><li><code>resolution</code>:检测屏幕或打印机的分辨率。(例如：min-resolution:300dpi 或 min-resolution:118dpcm)。</li><li><code>grid</code>：检测输出的设备是网格的还是位图设备。</li></ul>]]></content>
      
      
      <categories>
          
          <category> FE Css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML中_等6种空白空格的区别</title>
      <link href="167.html"/>
      <url>167.html</url>
      
        <content type="html"><![CDATA[<p><code>HTML</code> 提供了 5 种空格实体（<code>space entity</code>），它们拥有不同的宽度，非断行空格（<code>&amp;nbsp;</code>）是常规空格的宽度，可运行于所有主流浏览器。其他几种空格（<code>&amp;ensp; &amp;emsp; &amp;thinsp; &amp;zwnj; &amp;zwj;</code>）在不同浏览器中宽度各异。</p><h2 id="amp-nbsp"><a href="#amp-nbsp" class="headerlink" title="&amp;nbsp;"></a><code>&amp;nbsp;</code></h2><p>它叫<strong>不换行空格</strong>，全称 No-Break Space，它是最常见和我们使用最多的空格，大多数的人可能只接触了  ，它是按下 space 键产生的空格。在 HTML 中，如果你用空格键产生此空格，空格是不会累加的（只算 1 个）。要使用 html 实体表示才可累加，该空格占据宽度受字体影响明显而强烈。</p><h2 id="amp-ensp"><a href="#amp-ensp" class="headerlink" title="&amp;ensp;"></a><code>&amp;ensp;</code></h2><p>它叫<strong>半角空格</strong>，全称是 En Space，en 是字体排印学的计量单位，为 em 宽度的一半。根据定义，它等同于字体度的一半（如 16px 字体中就是 8px）。名义上是小写字母 n 的宽度。此空格传承空格家族一贯的特性：透明的，此空格有个相当稳健的特性，就是其占据的宽度正好是 1/2 个中文宽度，而且基本上不受字体影响。</p><h2 id="amp-emsp"><a href="#amp-emsp" class="headerlink" title="&amp;emsp;"></a><code>&amp;emsp;</code></h2><p>它叫<strong>全角空格</strong>，全称是 Em Space，em 是字体排印学的计量单位，相当于当前指定的点数。例如，1 em 在 16px 的字体中就是 16px。此空格也传承空格家族一贯的特性：透明的，此空格也有个相当稳健的特性，就是其占据的宽度正好是 1 个中文宽度，而且基本上不受字体影响。</p><h2 id="amp-thinsp"><a href="#amp-thinsp" class="headerlink" title="&amp;thinsp;"></a><code>&amp;thinsp;</code></h2><p>它叫<strong>窄空格</strong>，全称是 Thin Space。我们不妨称之为“瘦弱空格”，就是该空格长得比较瘦弱，身体单薄，占据的宽度比较小。它是 em 之六分之一宽。</p><h2 id="amp-zwnj"><a href="#amp-zwnj" class="headerlink" title="&amp;zwnj;"></a><code>&amp;zwnj;</code></h2><p>它叫<strong>零宽不连字</strong>，全称是 Zero Width Non Joiner，简称“ZWNJ”，是一个不打印字符，放在电子文本的两个字符之间，抑制本来会发生的连字，而是以这两个字符原本的字形来绘制。 ‌</p><h2 id="amp-zwj"><a href="#amp-zwj" class="headerlink" title="&amp;zwj;"></a><code>&amp;zwj;</code></h2><p>它叫<strong>零宽连字</strong>，全称是 Zero Width Joiner，简称“ZWJ”，是一个不打印字符，放在某些需要复杂排版语言（如阿拉伯语、印地语）的两个字符之间，使得这两个本不会发生连字的字符产生了连字效果。</p><p>此外，浏览器还会把以下字符当作空白进行解析：空格（<code>&amp;#x0020;</code>）、制表位（<code>&amp;#x0009;</code>）、换行（<code>&amp;#x000A;</code>）和回车（<code>&amp;#x000D;</code>）还有（<code>&amp;#12288;</code>）等等。</p>]]></content>
      
      
      <categories>
          
          <category> FE Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）IE6/IE7/IE8/IE9/FF的CSS Hacks</title>
      <link href="158.html"/>
      <url>158.html</url>
      
        <content type="html"><![CDATA[<h2 id="IE6-IE7-FF-的-CSS-Hacks"><a href="#IE6-IE7-FF-的-CSS-Hacks" class="headerlink" title="IE6/IE7/FF 的 CSS Hacks"></a>IE6/IE7/FF 的 CSS Hacks</h2><h3 id="区别-IE-和非-IE-浏览器"><a href="#区别-IE-和非-IE-浏览器" class="headerlink" title="区别 IE 和非 IE 浏览器"></a>区别 IE 和非 IE 浏览器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#tip</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue; <span class="comment">/*非IE 背景藍色*/</span></span><br><span class="line">  <span class="attribute">background</span>: red \<span class="number">9</span>; <span class="comment">/*IE6、IE7、IE8背景紅色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区别-IE6-IE7-IE8-FF"><a href="#区别-IE6-IE7-IE8-FF" class="headerlink" title="区别 IE6,IE7,IE8,FF"></a>区别 IE6,IE7,IE8,FF</h3><p>【区别符号】：<code>\9</code>、<code>*</code>、<code>_</code></p><p>【示例】：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#tip</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue; <span class="comment">/*Firefox 背景变蓝色*/</span></span><br><span class="line">  <span class="attribute">background</span>: red \<span class="number">9</span>; <span class="comment">/*IE8 背景变红色*/</span></span><br><span class="line">  *<span class="attribute">background</span>: black; <span class="comment">/*IE7 背景变黑色*/</span></span><br><span class="line">  _background: range; <span class="comment">/*IE6 背景变橘色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【说明】：因为 IE 系列浏览器可读<code>\9</code>，而 IE6 和 IE7 可读 <code>*</code>(米字号)，另外 IE6 可辨识 <code>_</code>(底线)，因此可以依照顺序写下来，就会让浏 览器正确的读取到自己看得懂得 CSS 语法，所以就可以有效区分 IE 各版本和非 IE 浏览器(像是 Firefox、Opera、Google Chrome、Safari 等)。</p><h3 id="区别-IE6、IE7、Firefox-方法-1"><a href="#区别-IE6、IE7、Firefox-方法-1" class="headerlink" title="区别 IE6、IE7、Firefox (方法 1)"></a>区别 IE6、IE7、Firefox (方法 1)</h3><p>【区别符号】：<code>*</code>、<code>_</code><br>【示例】：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#tip</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue; <span class="comment">/*Firefox背景变蓝色*/</span></span><br><span class="line">  *<span class="attribute">background</span>: black; <span class="comment">/*IE7 背景变黑色*/</span></span><br><span class="line">  _background: orange; <span class="comment">/*IE6 背景变橘色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【说明】：IE7 和 IE6 可读 <code>*</code>(米字号)，IE6 又可以读 <code>_</code>(底线)，但是 IE7 却无法读取 <code>_</code>，至于 Firefox(非 IE 浏览器)则完全无法辨识 <code>*</code> 和 <code>_</code>，因此就可以透过这样的差异性来区分 IE6、IE7、Firefox。</p><h3 id="区别-IE6、IE7、Firefox-方法-2"><a href="#区别-IE6、IE7、Firefox-方法-2" class="headerlink" title="区别 IE6、IE7、Firefox (方法 2)"></a>区别 IE6、IE7、Firefox (方法 2)</h3><p>【区别符号】：<code>*</code>、<code>!important</code><br>【示例】：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#tip</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue; <span class="comment">/*Firefox 背景变蓝色*/</span></span><br><span class="line">  *<span class="attribute">background</span>: green <span class="meta">!important</span>; <span class="comment">/*IE7 背景变绿色*/</span></span><br><span class="line">  *<span class="attribute">background</span>: orange; <span class="comment">/*IE6 背景变橘色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【说明】：IE7 可以辨识 <code>*</code> 和 <code>!important</code>，但是 IE6 只可以辨识 <code>*</code>，却无法辨识 <code>!important</code>，至于 Firefox 可以读取 <code>!important</code> 但不能辨识 <code>*</code> 因此可以透过这样的差异来有效区隔 IE6、IE7、Firefox。</p><h3 id="区别-IE7、Firefox"><a href="#区别-IE7、Firefox" class="headerlink" title="区别 IE7、Firefox"></a>区别 IE7、Firefox</h3><p>【区别符号】：<code>*</code>、<code>!important</code><br>【示例】：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#tip</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue; <span class="comment">/*Firefox 背景变蓝色*/</span></span><br><span class="line">  *<span class="attribute">background</span>: green <span class="meta">!important</span>; <span class="comment">/*IE7 背景变绿色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【说明】：因为 Firefox 可以辨识<code>!important</code> 但却无法辨识 <code>*</code>，而 IE7 则可以同时看懂 <code>_</code>、<code>!important</code>，因此可以两个辨识符号来区隔 IE7 和 Firefox。</p><h3 id="区别-IE6、IE7-方法-1"><a href="#区别-IE6、IE7-方法-1" class="headerlink" title="区别 IE6、IE7 (方法 1)"></a>区别 IE6、IE7 (方法 1)</h3><p>【区别符号】：<code>*</code>、<code>_</code><br>【示例】：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#tip</span> &#123;</span><br><span class="line">  *<span class="attribute">background</span>: black; <span class="comment">/*IE7 背景变黑色*/</span></span><br><span class="line">  _background: orange; <span class="comment">/*IE6 背景变橘色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【说明】：IE7 和 IE6 都可以辨识 <code>*</code>(米字号)，但 IE6 可以辨识 <code>_</code>(底线)，IE7 却无法辨识，透过 IE7 无法读取 <code>_</code> 的特性就能轻鬆区隔 IE6 和 IE7 之间的差异。</p><h3 id="区别-IE6、IE7-方法-2"><a href="#区别-IE6、IE7-方法-2" class="headerlink" title="区别 IE6、IE7 (方法 2)"></a>区别 IE6、IE7 (方法 2)</h3><p>【区别符号】：<code>!important</code><br>【示例】：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#tip</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: black <span class="meta">!important</span>; <span class="comment">/*IE7 背景变黑色*/</span></span><br><span class="line">  <span class="attribute">background</span>: orange; <span class="comment">/*IE6 背景变橘色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【说明】：因为 IE7 可读取 <code>!important;</code> 但 IE6 却不行，而 CSS 的读取步骤是从上到下，因此 IE6 读取时因无法辨识 <code>!important</code> 而直接跳到下一行读取 CSS，所以背景色会呈现橘色。</p><h3 id="区别-IE6、Firefox"><a href="#区别-IE6、Firefox" class="headerlink" title="区别 IE6、Firefox"></a>区别 IE6、Firefox</h3><p>【区别符号】：<code>_</code><br>【示例】：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#tip</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: black; <span class="comment">/*Firefox 背景变黑色*/</span></span><br><span class="line">  _background: orange; <span class="comment">/*IE6 背景变橘色*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【说明】：因为 IE6 可以辨识 <code>_</code>(底线)，但是 Firefox 却不行，因此可以透过这样的差异来区隔 Firefox 和 IE6，有效达成 CSS hack。</p><h3 id="IE-6-ONLY"><a href="#IE-6-ONLY" class="headerlink" title="IE-6 ONLY"></a>IE-6 ONLY</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* <span class="selector-tag">html</span> <span class="selector-id">#div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="NON-IE-7-ONLY"><a href="#NON-IE-7-ONLY" class="headerlink" title="NON IE-7 ONLY"></a>NON IE-7 ONLY</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#div</span> &#123;</span><br><span class="line">  _height: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hide-from-IE-6-and-LOWER"><a href="#Hide-from-IE-6-and-LOWER" class="headerlink" title="Hide from IE 6 and LOWER"></a>Hide from IE 6 and LOWER</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span><span class="comment">/**/</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span> &gt; <span class="selector-tag">body</span> <span class="selector-id">#div</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浏览器专属-CSS-Hack-区分-Firefox-Opera-Safari-Internet-Explorer"><a href="#浏览器专属-CSS-Hack-区分-Firefox-Opera-Safari-Internet-Explorer" class="headerlink" title="浏览器专属 CSS Hack:区分 Firefox / Opera / Safari / Internet Explorer"></a>浏览器专属 CSS Hack:区分 Firefox / Opera / Safari / Internet Explorer</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Opera */</span></span><br><span class="line"><span class="selector-tag">html</span><span class="selector-pseudo">:first</span>-child <span class="selector-id">#opera</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* IE 7 */</span></span><br><span class="line">*<span class="selector-pseudo">:first</span>-child + <span class="selector-tag">html</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* IE 7 */</span></span><br><span class="line"><span class="selector-tag">html</span> &gt; <span class="selector-tag">body</span> <span class="selector-id">#ie7</span> &#123;</span><br><span class="line">  *<span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* IE 6 */</span></span><br><span class="line">* <span class="selector-tag">html</span> <span class="selector-id">#div</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#f00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* IE 6 */</span></span><br><span class="line"><span class="selector-tag">body</span> <span class="selector-id">#ie6</span> &#123;</span><br><span class="line">  _display: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*IE7及其更低版本*/</span></span><br><span class="line">*<span class="selector-pseudo">:first</span>-child + <span class="selector-tag">html</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">*<span class="selector-tag">html</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*IE7,IE7以上和主流浏览器*/</span></span><br><span class="line"><span class="selector-tag">html</span> &gt; <span class="selector-tag">body</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*适合主流浏览器(IE7排除在外，IE7以下的也不行)*/</span></span><br><span class="line"><span class="selector-tag">html</span>&gt;<span class="comment">/**/</span><span class="selector-tag">body</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Firefox 1 - 2 */</span></span><br><span class="line"><span class="selector-tag">body</span><span class="selector-pseudo">:empty</span> <span class="selector-id">#firefox12</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Firefox */</span></span><br><span class="line"><span class="keyword">@-moz-document</span> url-prefix() &#123;</span><br><span class="line">  <span class="selector-id">#firefox</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Safari */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="selector-id">#safari</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Opera */</span></span><br><span class="line"><span class="keyword">@media</span> all <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">10000</span>), <span class="keyword">not</span> all <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">0</span>) &#123;</span><br><span class="line">  head ~ <span class="selector-tag">body</span> <span class="selector-id">#opera</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最新的浏览器-CSS-Hacks"><a href="#最新的浏览器-CSS-Hacks" class="headerlink" title="最新的浏览器 CSS Hacks"></a>最新的浏览器 CSS Hacks</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* IE6 and below */</span></span><br><span class="line">* <span class="selector-tag">html</span> <span class="selector-id">#uno</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* IE7 */</span></span><br><span class="line">*<span class="selector-pseudo">:first</span>-child + <span class="selector-tag">html</span> <span class="selector-id">#dos</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">* + <span class="selector-tag">html</span> <span class="selector-id">#dieciocho</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Safari 2-3 */</span></span><br><span class="line"><span class="selector-tag">html</span><span class="selector-attr">[xmlns*=<span class="string">&#x27;&#x27;</span>]</span> <span class="selector-tag">body</span><span class="selector-pseudo">:last-child</span> <span class="selector-id">#seis</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* webkit and opera */</span></span><br><span class="line"><span class="keyword">@media</span> all <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">0px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.big</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">11px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* webkit */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="selector-class">.big</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">11px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* opera */</span></span><br><span class="line"><span class="keyword">@media</span> all <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">10000</span>), <span class="keyword">not</span> all <span class="keyword">and</span> (<span class="attribute">-webkit-min-device-pixel-ratio</span>: <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="selector-class">.big</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">11px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* firefox * /</span></span><br><span class="line"><span class="comment">    @-moz-document url-prefix()&#123; .big&#123;padding:11px;&#125;&#125; /* all firefox */</span></span><br><span class="line"><span class="selector-id">#veinticinco</span>,</span><br><span class="line">x:-moz-any-link,</span><br><span class="line">x:default &#123;</span><br><span class="line">  color: red;</span><br><span class="line">&#125; <span class="comment">/* Firefox 3.0+ */</span></span><br><span class="line"><span class="selector-tag">html</span>&gt;<span class="comment">/**/</span><span class="selector-tag">body</span> <span class="selector-class">.big</span>, x:-moz-any-link, x:default &#123;</span><br><span class="line">  padding: <span class="number">11px</span>;</span><br><span class="line">&#125; <span class="comment">/* newest firefox */</span></span><br></pre></td></tr></table></figure><p><img data-src="http://cdn.flqin.com/css-hack.png" alt="css-hack"></p><p><strong>ps</strong>：IE6 不支持 <code>!important</code>，是指不支持 <code>important</code> 的优先级，并不影响 <code>css</code> 属性值的解析。比如 <code>color:green!important;color:red;</code>，除了在 IE6 下字体颜色解析为红色，其他（你懂的）浏览器下都是绿色。</p>]]></content>
      
      
      <categories>
          
          <category> FE Css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）前端冷知识集锦</title>
      <link href="131.html"/>
      <url>131.html</url>
      
        <content type="html"><![CDATA[<p>前端已经被玩儿坏了！像 <code>console.log()</code> 可以向控制台输出图片等炫酷的玩意已经不是什么新闻了，像用||操作符给变量赋默认值也是人尽皆知的旧闻了，今天看到 Quora 上一个帖子，瞬间又 GET 了好多前端技能，一些属于技巧，一些则是闻所未闻的冷知识，一时间还消化不过来。现分类整理出来分享给大家，也补充了一些平时的积累和扩展了一些内容。</p><h2 id="HTML-篇"><a href="#HTML-篇" class="headerlink" title="HTML 篇"></a>HTML 篇</h2><h3 id="浏览器地址栏运行-JavaScript-代码"><a href="#浏览器地址栏运行-JavaScript-代码" class="headerlink" title="浏览器地址栏运行 JavaScript 代码"></a>浏览器地址栏运行 JavaScript 代码</h3><p>这个很多人应该还是知道的，在浏览器地址栏可以直接运行 <code>JavaScript</code> 代码，做法是以 <code>javascript:</code> 开头后跟要执行的语句。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javascript: alert(<span class="string">&#x27;hello from address bar :)&#x27;</span>);</span><br></pre></td></tr></table></figure><p>将以上代码贴到浏览器地址栏回车后 <code>alert</code> 正常执行，一个弹窗神现。</p><p>需要注意的是如果是通过 <code>copy paste</code> 代码到浏览器地址栏的话，IE 及 Chrome 会自动去掉代码开头的 <code>javascript:</code>，所以需要手动添加起来才能正确执行，而 Firefox 中虽然不会自动去掉，但它根本就不支持在地址栏运行 JS 代码，sigh~</p><h3 id="浏览器地址栏运行-HTML-代码"><a href="#浏览器地址栏运行-HTML-代码" class="headerlink" title="浏览器地址栏运行 HTML 代码"></a>浏览器地址栏运行 HTML 代码</h3><p>如果说上面那条小秘密知道的人还算多的话，这条秘笈知道的人就要少一些了，在非 IE 内核的浏览器地址栏可以直接运行 <code>HTML</code> 代码！</p><p>比如在地址栏输入以下代码然后回车运行，会出现指定的页面内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data:text/html,</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="可以把浏览器当编辑器"><a href="#可以把浏览器当编辑器" class="headerlink" title="可以把浏览器当编辑器"></a>可以把浏览器当编辑器</h3><p>还是浏览器地址栏上做文章，将以下代码贴到地址栏运行后浏览器变成了一个原始而简单的编辑器，与 <code>Windows</code> 自带的 <code>notepad</code> 一样，吼吼。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data:text/html,</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">contenteditable</span>&gt;</span><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>归根结底多亏了 <code>HTML5</code> 中新加的 <code>contenteditable</code> 属性，当元素指定了该属性后，元素的内容成为可编辑状态。</p><p>推而广之，将以下代码放到 <code>console</code> 执行后，整个页面将变得可编辑，随意践踏吧~</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.contentEditable = <span class="string">&#x27;true&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="利用-a-标签自动解析-URL"><a href="#利用-a-标签自动解析-URL" class="headerlink" title="利用 a 标签自动解析 URL"></a>利用 a 标签自动解析 URL</h3><p>很多时候我们有从一个 <code>URL</code> 中提取域名，查询关键字，变量参数值等的需要，而万万没想到可以让浏览器方便地帮我们完成这一任务而不用我们写正则去抓取。方法就在 <code>JS</code> 代码里先创建一个 <code>a</code> 标签然后将需要解析的 <code>URL</code> 赋值给 <code>a</code> 的 <code>href</code> 属性，然后就得到了一切我们想要的了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">a.href = <span class="string">&#x27;http://www.cnblogs.com/wayou/p/&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.host);</span><br></pre></td></tr></table></figure><h3 id="页面拥有-ID-的元素会创建全局变量"><a href="#页面拥有-ID-的元素会创建全局变量" class="headerlink" title="页面拥有 ID 的元素会创建全局变量"></a>页面拥有 ID 的元素会创建全局变量</h3><p>在一张 <code>HTML</code> 页面中，所有设置了 <code>ID</code> 属性的元素会在 <code>JavaScript</code> 的执行环境中创建对应的全局变量，这意味着 <code>document.getElementById</code> 像人的阑尾一样显得多余了。但实际项目中最好老老实实该怎么写就怎么写，毕竟常规代码出乱子的机会要小得多。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;sample&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(sample);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="加载-CDN-文件时，可以省掉-HTTP-标识"><a href="#加载-CDN-文件时，可以省掉-HTTP-标识" class="headerlink" title="加载 CDN 文件时，可以省掉 HTTP 标识"></a>加载 CDN 文件时，可以省掉 HTTP 标识</h3><p>现在很流行的 <code>CDN</code> 即从专门的服务器加载一些通用的 <code>JS</code> 和 <code>CSS</code> 文件，出于安全考虑有的 <code>CDN</code> 服务器使用 <code>HTTPS</code> 方式连接，而有的是传统的 <code>HTTP</code>，其实我们在使用时可以忽略掉这个，将它从 <code>URL</code> 中省去。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;//domain.com/path/to/script.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="利用-script-标签保存任意信息"><a href="#利用-script-标签保存任意信息" class="headerlink" title="利用 script 标签保存任意信息"></a>利用 script 标签保存任意信息</h3><p>将 <code>script</code> 标签设置为 <code>type=&#39;text&#39;</code> 然后可以在里面保存任意信息，之后可以在 <code>JavaScript</code> 代码中很方便地获取。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;template&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This won&#x27;t display<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;template&#x27;</span>).innerHTML;</span><br></pre></td></tr></table></figure><h2 id="CSS-篇"><a href="#CSS-篇" class="headerlink" title="CSS 篇"></a>CSS 篇</h2><h3 id="关于-CSS-的恶作剧"><a href="#关于-CSS-的恶作剧" class="headerlink" title="关于 CSS 的恶作剧"></a>关于 CSS 的恶作剧</h3><p>相信你看完以下代码后能够预料到会出现什么效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: none <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="简单的文字模糊效果"><a href="#简单的文字模糊效果" class="headerlink" title="简单的文字模糊效果"></a>简单的文字模糊效果</h3><p>以下两行简单的 CSS3 代码可达到将文字模糊化处理的目的，出来的效果有点像使用 PS 的滤镜，so cool!</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: transparent;</span><br><span class="line">  <span class="attribute">text-shadow</span>: <span class="number">#111</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重边框"><a href="#多重边框" class="headerlink" title="多重边框"></a>多重边框</h3><p>利用重复指定 box-shadow 来达到多个边框的效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*CSS Border with Box-Shadow Example*/</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">6px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.2</span>), <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">12px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.2</span>), <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">18px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.2</span>), <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">24px</span> <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.2</span>);</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">50px</span> auto;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实时编辑-CSS"><a href="#实时编辑-CSS" class="headerlink" title="实时编辑 CSS"></a>实时编辑 CSS</h3><p>通过设置 <code>style</code> 标签的 <code>display:block</code> 样式可以让页面的 <code>style</code> 标签显示出来，并且加上 <code>contentEditable</code> 属性后可以让样式成为可编辑状态，更改后的样式效果也是实时更新呈现的。此技巧在 IE 下无效。拥有此技能者，逆天也！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">style</span>=<span class="string">&quot;display:block&quot;</span> <span class="attr">contenteditable</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">color</span>: blue;</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建长宽比固定的元素"><a href="#创建长宽比固定的元素" class="headerlink" title="创建长宽比固定的元素"></a>创建长宽比固定的元素</h3><p>通过设置父级窗口的 <code>padding-bottom</code> 可以达到让容器保持一定的长度比的目的，这在响应式页面设计中比较有用，能够保持元素不变形。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%; position: relative; padding-bottom: 20%;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: absolute; left: 0; top: 0; right: 0; bottom: 0;background-color:yellow;&quot;</span>&gt;</span>this content will have a constant aspect ratio that varies based on the width.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="CSS-中也可以做简单运算"><a href="#CSS-中也可以做简单运算" class="headerlink" title="CSS 中也可以做简单运算"></a>CSS 中也可以做简单运算</h3><p>通过 CSS 中的 <code>calc</code> 方法可以进行一些简单的运算，从而达到动态指定元素样式的目的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">background-position</span>: <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">50px</span>) <span class="built_in">calc</span>(<span class="number">100%</span> - <span class="number">20px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JavaScript-篇"><a href="#JavaScript-篇" class="headerlink" title="JavaScript 篇"></a>JavaScript 篇</h2><h3 id="生成随机字符串"><a href="#生成随机字符串" class="headerlink" title="生成随机字符串"></a>生成随机字符串</h3><p>利用 <code>Math.random</code> 和 <code>toString</code> 生成随机字符串，来自前一阵子看到的一篇博文。这里的技巧是利用了 <code>toString</code> 方法可以接收一个基数作为参数的原理，这个基数从 2 到 36 封顶。如果不指定，默认基数是 10 进制。略屌！</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateRandomAlphaNum</span>(<span class="params">len</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> rdmString = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">for</span> (; rdmString.length &lt; len; rdmString += <span class="built_in">Math</span>.random().toString(<span class="number">36</span>).substr(<span class="number">2</span>));</span><br><span class="line">  <span class="keyword">return</span> rdmString.substr(<span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="整数的操作"><a href="#整数的操作" class="headerlink" title="整数的操作"></a>整数的操作</h3><p><code>JavaScript</code> 中是没有整型概念的，但利用好位操作符可以轻松处理，同时获得效率上的提升。</p><p><code>|0</code> 和 <code>~~</code> 是很好的一个例子，使用这两者可以将浮点转成整型且效率方面要比同类的 <code>parseInt</code>, <code>Math.round</code> 要快。在处理像素及动画位移等效果的时候会很有用。性能比较见此。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = (<span class="number">12.4</span> / <span class="number">4.13</span>) | <span class="number">0</span>; <span class="comment">//结果为3</span></span><br><span class="line"><span class="keyword">var</span> bar = ~~(<span class="number">12.4</span> / <span class="number">4.13</span>); <span class="comment">//结果为3</span></span><br></pre></td></tr></table></figure><p>顺便说句， <code>!!</code> 将一个值方便快速转化为布尔值 <code>!!window===true</code>。</p><h3 id="重写原生浏览器方法以实现新功能"><a href="#重写原生浏览器方法以实现新功能" class="headerlink" title="重写原生浏览器方法以实现新功能"></a>重写原生浏览器方法以实现新功能</h3><p>下载的代码通过重写浏览器的 alert 让它可以记录弹窗的次数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oldAlert = <span class="built_in">window</span>.alert,</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">window</span>.alert = <span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    oldAlert(a + <span class="string">&quot;\n You&#x27;ve called alert &quot;</span> + count + <span class="string">&quot; times now. Stop, it&#x27;s evil!&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">&#x27;Hello World&#x27;</span>);</span><br></pre></td></tr></table></figure><h3 id="关于-console-的恶作剧"><a href="#关于-console-的恶作剧" class="headerlink" title="关于 console 的恶作剧"></a>关于 console 的恶作剧</h3><p>关于重写原生方法，这里有个恶作剧大家可以拿去寻开心。Chrome 的 <code>console.log</code> 是支持对文字添加样式的，甚至 <code>log</code> 图片都可以。于是可以重写掉默认的 <code>log</code> 方法，把将要 <code>log</code> 的文字应用到 <code>CSS</code> 的模糊效果，这样当有人试图调用 <code>console.log()</code> 的时候，出来的是模糊不清的文字。好冷，我表示没有笑。</p><p>是从这篇 G+帖子的评论里看到的。使用之后的效果是再次调用 <code>log</code> 会输出字迹模糊不清的文字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _log = <span class="built_in">console</span>.log;</span><br><span class="line"><span class="built_in">console</span>.log = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  _log.call(<span class="built_in">console</span>, <span class="string">&#x27;%c&#x27;</span> + [].slice.call(<span class="built_in">arguments</span>).join(<span class="string">&#x27; &#x27;</span>), <span class="string">&#x27;color:transparent;text-shadow:0 0 2px rgba(0,0,0,.5);&#x27;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="不声明第三个变量的值交换"><a href="#不声明第三个变量的值交换" class="headerlink" title="不声明第三个变量的值交换"></a>不声明第三个变量的值交换</h3><p>我们都知道交换两个变量值的常规做法，那就是声明一个中间变量来暂存。但鲜有人去挑战不声明中间变量的情况，下面的代码给出了这种实现。蛮有创意的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>,</span><br><span class="line">  b = <span class="number">2</span>;</span><br><span class="line">a = [b, (b = a)][<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h3 id="万物皆对象"><a href="#万物皆对象" class="headerlink" title="万物皆对象"></a>万物皆对象</h3><p>在 <code>JavaScript</code> 的世界，万物皆对象。除了 <code>null</code> 和 <code>undefined</code>，其他基本类型数字，字符串和布尔值都有对应有包装对象。对象的一个特征是你可以在它身上直接调用方法。对于数字基本类型，当试图在其身上调用 <code>toString</code> 方法会失败，但用括号括起来后再调用就不会失败了，内部实现是用相应的包装对象将基本类型转为对象。所以 <code>(1).toString()</code> 相当于 <code>new Number(1).toString()</code>。因此，你的确可以把基本类型数字，字符串，布尔等当对象使用的，只是注意语法要得体。</p><p>同时我们注意到，<code>JavaScript</code> 中数字是不分浮点和整形的，所有数字其实均是浮点类型，只是把小数点省略了而以，比如你看到的 <code>1</code> 可以写成 <code>1.</code>，这也就是为什么当你试图 <code>1.toString()</code> 时会报错，所以正确的写法应该是这样：<code>1..toString()</code>，或者如上面所述加上括号，这里括号的作用是纠正 JS 解析器，不要把 <code>1</code> 后面的点当成小数点。内部实现如上面所述，是将 <code>1.</code> 用包装对象转成对象再调用方法。</p><h3 id="If-语句的变形"><a href="#If-语句的变形" class="headerlink" title="If 语句的变形"></a>If 语句的变形</h3><p>当你需要写一个 if 语句的时候，不妨尝试另一种更简便的方法，用 <code>JavaScript</code> 中的逻辑操作符来代替。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> day = <span class="keyword">new</span> <span class="built_in">Date</span>().getDay() === <span class="number">0</span>;</span><br><span class="line"><span class="comment">//传统if语句</span></span><br><span class="line"><span class="keyword">if</span> (day) &#123;</span><br><span class="line">  alert(<span class="string">&#x27;Today is Sunday!&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运用逻辑与代替if</span></span><br><span class="line">day &amp;&amp; alert(<span class="string">&#x27;Today is Sunday!&#x27;</span>);</span><br></pre></td></tr></table></figure><p>比如上面的代码，首先得到今天的日期，如果是星期天，则弹窗，否则什么也不做。我们知道逻辑操作存在短路的情况，对于逻辑与表达式，只有两者都真才结果才为真，如果前面的 <code>day</code> 变量被判断为假了，那么对于整个与表达式来说结果就是假，所以就不会继续去执行后面的 <code>alert</code> 了，如果前面 <code>day</code> 为真，则还要继续执行后面的代码来确定整个表达式的真假。利用这点达到了 <code>if</code> 的效果。</p><p>对于传统的 <code>if</code> 语句，如果执行体代码超过了 1 条语句，则需要加花括号，而利用逗号表达式，可以执行任意条代码而不用加花括号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (conditoin) alert(<span class="number">1</span>), alert(<span class="number">2</span>), <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>上面 <code>if</code> 语句中，如果条件成立则执行三个操作，但我们不需要用花括号将这三句代码括起来。当然，这是不推荐的，这里是冷知识课堂:)</p><h3 id="禁止别人以-iframe-加载你的页面"><a href="#禁止别人以-iframe-加载你的页面" class="headerlink" title="禁止别人以 iframe 加载你的页面"></a>禁止别人以 iframe 加载你的页面</h3><p>下面的代码已经不言自明了，没什么好多说的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.location != <span class="built_in">window</span>.parent.location) <span class="built_in">window</span>.parent.location = <span class="built_in">window</span>.location;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FE Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>（转载）IE条件注释</title>
      <link href="130.html"/>
      <url>130.html</url>
      
        <content type="html"><![CDATA[<p>我们知道，IE6 的存在，因其预装于目前市场占有率最大的 Windows XP 操作系统。对于老态龙钟的 IE6，说拜拜还需要很长的时间。</p><p>IE 虽然给我们网页设计师，带来了不少多麻烦，还好，IE 条件注释，给我们解决浏览器兼容问题带来了一个很好的方法。</p><h2 id="什么是-IE-条件注释"><a href="#什么是-IE-条件注释" class="headerlink" title="什么是 IE 条件注释"></a>什么是 IE 条件注释</h2><p>IE 条件注释，顾名思义就是使用 IE 特有的条件语句来显示代码块。</p><p>这些巧妙的逻辑片段只能被 IE 浏览器所支持，其它的浏览器理解为纯粹的 HTML 注释，不起任何作用。条件注释在 IE5 中首次出现，并且得到了 Widnows 浏览器所有后续版本的支持。IE 条件注释及其有效，而且非常容易记住。通过这些技巧，我们可以为基于 Windows 的 IE5、6、7、8 添加一些特殊的行为。这样做的好处是，HTML 和 CSS 代码可以通过验证。主要的缺点是这些注释需要放在 HTML 页面中，而不是放在 CSS 中。这样，当你不需要这些东西，或者有所更改的时候，就需要维护很多的地方。好处是通过这种方式使用条件注释，可以很轻松的管理项目中的目标浏览器，并使得 CSS 补丁文件保持独立自由。更重要的是它帮助我们优化了 CSS 样式表，保证了主要样式表的干净，这对于大型网站来说就很重要了，也许你还没有感觉到它的可爱之处。</p><p>作为有 Web 标准意识的开发者，我们始终应该首先在大部分现有的兼容标准的浏览器上测试我们的设计，然后再为那些稍作细微修改就能回到正轨的浏览器提供补丁。</p><h2 id="条件注释使用方法"><a href="#条件注释使用方法" class="headerlink" title="条件注释使用方法"></a>条件注释使用方法</h2><h3 id="条件注释属性"><a href="#条件注释属性" class="headerlink" title="条件注释属性"></a>条件注释属性</h3><ul><li><strong>gt</strong> : greater than，选择条件版本以上版本，不包含条件版本</li><li><strong>lt</strong> : less than，选择条件版本以下版本，不包含条件版本</li><li><strong>gte</strong> : greater than or equal，选择条件版本以上版本，包含条件版本</li><li><strong>lte</strong> : less than or equal，选择条件版本以下版本，包含条件版本</li><li><strong>!</strong> : 选择条件版本以外所有版本，无论高低</li></ul><h3 id="The-Code"><a href="#The-Code" class="headerlink" title="The Code"></a>The Code</h3><p>我们概括性地说明一下你如何使用条件注释，首先，我们应该把你所有的 CSS 等 CSS 文件放在中。条件注释的基本结构和 HTML 的注释()是一样的。因此 ，IE 以外的浏览器将会把它们看 作是普通的注释而完全忽略它们。IE 将会根据 if 条件来判断是否如解析普通的页面内容一样解析条件注释里的内容。条件注释使用的是 HTML 的注释结构，因此他们只能使用在 HTML 文件里，而不能在 CSS 文件中使用。</p><h4 id="Target-ALL-VERSIONS-of-IE（-所有的-IE-可识别-）"><a href="#Target-ALL-VERSIONS-of-IE（-所有的-IE-可识别-）" class="headerlink" title="Target ALL VERSIONS of IE（ 所有的 IE 可识别 ）"></a>Target ALL VERSIONS of IE（ 所有的 IE 可识别 ）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if IE]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;all-ie-only.css&quot; /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Target-everything-EXCEPT-IE-（除-IE-外都可识别-）"><a href="#Target-everything-EXCEPT-IE-（除-IE-外都可识别-）" class="headerlink" title="Target everything EXCEPT IE （除 IE 外都可识别 ）"></a>Target everything EXCEPT IE （除 IE 外都可识别 ）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if !IE]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;not-ie.css&quot; /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Target-IE-7-ONLY-（-仅-IE7-可识别-）"><a href="#Target-IE-7-ONLY-（-仅-IE7-可识别-）" class="headerlink" title="Target IE 7 ONLY （ 仅 IE7 可识别 ）"></a>Target IE 7 ONLY （ 仅 IE7 可识别 ）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if IE 7]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie7.css&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Target-IE-6-ONLY（仅-IE6-可识别）"><a href="#Target-IE-6-ONLY（仅-IE6-可识别）" class="headerlink" title="Target IE 6 ONLY（仅 IE6 可识别）"></a>Target IE 6 ONLY（仅 IE6 可识别）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if IE 6]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie6.css&quot; /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Target-IE-5-ONLY（只有-IE5-可以识别）"><a href="#Target-IE-5-ONLY（只有-IE5-可以识别）" class="headerlink" title="Target IE 5 ONLY（只有 IE5 可以识别）"></a>Target IE 5 ONLY（只有 IE5 可以识别）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if IE 5]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie5.css&quot; /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Target-IE-5-5-ONLY（只有-IE5-5-可以识别）"><a href="#Target-IE-5-5-ONLY（只有-IE5-5-可以识别）" class="headerlink" title="Target IE 5.5 ONLY（只有 IE5.5 可以识别）"></a>Target IE 5.5 ONLY（只有 IE5.5 可以识别）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if IE 5.5000]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie55.css&quot; /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Target-IE-6-and-LOWER（IE6-和-IE6-以下的）"><a href="#Target-IE-6-and-LOWER（IE6-和-IE6-以下的）" class="headerlink" title="Target IE 6 and LOWER（IE6 和 IE6 以下的）"></a>Target IE 6 and LOWER（IE6 和 IE6 以下的）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if lt IE 7]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie6-and-down.css&quot; /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- [if lte IE 6]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie6-and-down.css&quot; /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br><span class="line">`` #### Target IE 7 and LOWER（IE7 和 IE7 以下的） ```html</span><br><span class="line"><span class="comment">&lt;!-- [if lt IE 8]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie7-and-down.css&quot; /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- [if lte IE 7]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie7-and-down.css&quot; /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Target-IE-8-and-LOWER（IE8-和-IE8-以下的）"><a href="#Target-IE-8-and-LOWER（IE8-和-IE8-以下的）" class="headerlink" title="Target IE 8 and LOWER（IE8 和 IE8 以下的）"></a>Target IE 8 and LOWER（IE8 和 IE8 以下的）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie8-and-down.css&quot; /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- [if lte IE 8]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie8-and-down.css&quot; /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Target-IE-6-and-HIGHER（IE6-和-IE6-以上的）"><a href="#Target-IE-6-and-HIGHER（IE6-和-IE6-以上的）" class="headerlink" title="Target IE 6 and HIGHER（IE6 和 IE6 以上的）"></a>Target IE 6 and HIGHER（IE6 和 IE6 以上的）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if gt IE 5.5]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie6-and-up.css&quot; /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- [if gte IE 6]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie6-and-up.css&quot; /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Target-IE-7-and-HIGHER（IE7-和-IE7-以上的）"><a href="#Target-IE-7-and-HIGHER（IE7-和-IE7-以上的）" class="headerlink" title="Target IE 7 and HIGHER（IE7 和 IE7 以上的）"></a>Target IE 7 and HIGHER（IE7 和 IE7 以上的）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if gt IE 6]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie7-and-up.css&quot; /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- [if gte IE 7]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie7-and-up.css&quot; /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Target-IE-8-and-HIGHER（IE8-和-IE8-以上的）"><a href="#Target-IE-8-and-HIGHER（IE8-和-IE8-以上的）" class="headerlink" title="Target IE 8 and HIGHER（IE8 和 IE8 以上的）"></a>Target IE 8 and HIGHER（IE8 和 IE8 以上的）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if gt IE 7]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie8-and-up.css&quot; /&gt;</span></span><br><span class="line"><span class="comment">    &lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- [if gte IE 8]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;ie8-and-up.css&quot; /&gt;</span></span><br><span class="line"><span class="comment">    &lt; ![endif]--&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Universal-IE-6-CSS（通用的-IE-6-样式）"><a href="#Universal-IE-6-CSS（通用的-IE-6-样式）" class="headerlink" title="Universal IE 6 CSS（通用的 IE 6 样式）"></a>Universal IE 6 CSS（通用的 IE 6 样式）</h4><p>处理 IE 6 和 IE6 以下的版本始终是一个超特殊的挑战。老态龙钟的 IE6，还保持着高额的市场占有率，还不能彻底的放弃它，不然会有许多的客户抱怨我们。不过也有些人正在放弃对它的支持，包括大企业，大型网络应用，甚至政府。有一个不失落的 ，不放弃的 解决办法，那就是使用一个特精简的样式 universal IE 6 CSS.，然后为 IE 7 和以上（和所有其他浏览器）的应用常规的 CSS。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if !IE 6]&gt;&lt;!--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- [if gte IE 7]&gt;</span></span><br><span class="line"><span class="comment">       &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen, projection&quot; href=&quot;REGULAR-STYLESHEET.css&quot; /&gt;</span></span><br><span class="line"><span class="comment">    &lt; ![endif]--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- [if lte IE 6]&gt;</span></span><br><span class="line"><span class="comment">        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; media=&quot;screen, projection&quot; href=&quot;http://universal-ie6-css.googlecode.com/files/ie6.0.3.css&quot; /&gt;</span></span><br><span class="line"><span class="comment">    &lt; ![endif]--&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> FE Misc </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
